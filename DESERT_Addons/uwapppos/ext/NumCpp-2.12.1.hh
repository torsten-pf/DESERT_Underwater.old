/// @section Description
/// A Templatized Header Only C++ Implementation of the Python Numpy Library
///
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
///
/// @section License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// @section Testing
/// **C++ Standards:**
/// C++14
/// C++17
/// C++20
///
/// **Compilers:**
/// Visual Studio: 2017, 2019
/// GNU: 6.5, 7.5, 8.4, 9.3, 10.1
/// Clang: 6, 7, 8, 9, 10
///
/// **Boost Versions:**
/// 1.68, 1.70, 1.72, and 1.73
///
#pragma once


/*** Start of inlined file: Coordinates.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A module for holding and working with coordinates
///
#pragma once


/*** Start of inlined file: Cartesian.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Cartesian Object
///
#pragma once

#include <cmath>
#include <iostream>


/*** Start of inlined file: NdArray.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds 1D and 2D arrays, the main work horse of the NumCpp library
///
#pragma once


/*** Start of inlined file: NdArrayCore.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds 1D and 2D arrays, the main work horse of the NumCpp library
///
#pragma once

#include <array>
#include <cmath>
#include <deque>
#include <filesystem>
#include <forward_list>
#include <fstream>
#include <initializer_list>
#include <iostream>
#include <iterator>
#include <list>
#include <memory>
#include <numeric>
#include <set>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>


/*** Start of inlined file: Constants.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds usefull constants
///
#pragma once

#include <cmath>
#include <complex>
#include <limits>

namespace nc::constants
{
    constexpr double c     = 3.e8;                                    ///< speed of light
    constexpr double e     = 2.718281828459045;                       ///< eulers number
    constexpr double inf   = std::numeric_limits<double>::infinity(); ///< infinity
    constexpr double pi    = 3.141592653589793238462643383279502884;  ///< Pi
    constexpr double twoPi = 2. * pi;                                 ///< 2Pi
    const double     nan   = std::nan("1");                           ///< NaN
    constexpr auto   j     = std::complex<double>(0, 1);              // sqrt(-1) unit imaginary number

    constexpr double DAYS_PER_WEEK           = 7;    ///< Number of days in a week
    constexpr double MINUTES_PER_HOUR        = 60;   ///< Number of minutes in an hour
    constexpr double SECONDS_PER_MINUTE      = 60;   ///< Number of seconds in a minute
    constexpr double MILLISECONDS_PER_SECOND = 1000; ///< Number of milliseconds in a second
    constexpr double SECONDS_PER_HOUR        = MINUTES_PER_HOUR * SECONDS_PER_MINUTE; ///< Number of seconds in an hour
    constexpr double HOURS_PER_DAY           = 24;                                    ///< Number of hours in a day
    constexpr double MINUTES_PER_DAY         = HOURS_PER_DAY * MINUTES_PER_HOUR;      ///< Number of minutes in a day
    constexpr double SECONDS_PER_DAY         = MINUTES_PER_DAY * SECONDS_PER_MINUTE;  ///< Number of seconds in a day
    constexpr double MILLISECONDS_PER_DAY =
        SECONDS_PER_DAY * MILLISECONDS_PER_SECOND;                       ///< Number of milliseconds in a day
    constexpr double SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK; ///< Number of seconds in a week
} // namespace nc::constants

/*** End of inlined file: Constants.hpp ***/


/*** Start of inlined file: DtypeInfo.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds info about the dtype
///
#pragma once

#include <complex>
#include <limits>


/*** Start of inlined file: StaticAsserts.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Some helper routines for checking types
///
#pragma once

#include <type_traits>


/*** Start of inlined file: TypeTraits.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Some helper routines for checking types
///
#pragma once

#include <complex>
#include <type_traits>

namespace nc
{

    // Class Description:
    /// Template class for determining if all of the types are arithmetic
    ///
    template<typename... Ts>
    struct all_arithmetic;

    // Class Description:
    /// Template class specialization for determining if all of the types are arithmetic
    ///
    template<typename Head, typename... Tail>
    struct all_arithmetic<Head, Tail...>
    {
        static constexpr bool value = std::is_arithmetic<Head>::value && all_arithmetic<Tail...>::value;
    };

    // Class Description:
    /// Template class specialization for determining if all of the types are arithmetic
    ///
    template<typename T>
    struct all_arithmetic<T>
    {
        static constexpr bool value = std::is_arithmetic<T>::value;
    };

    // Class Description:
    /// all_arithmetic helper
    ///
    template<typename... Ts>
    constexpr bool all_arithmetic_v = all_arithmetic<Ts...>::value;

    // Class Description:
    /// Template class for determining if all of the types are the same as another type
    ///
    template<typename T1, typename... Ts>
    struct all_same;

    // Class Description:
    /// Template class specialization for determining if all of the types are the same as another type
    ///
    template<typename T1, typename Head, typename... Tail>
    struct all_same<T1, Head, Tail...>
    {
        static constexpr bool value = std::is_same<T1, Head>::value && all_same<T1, Tail...>::value;
    };

    // Class Description:
    /// Template class specialization for determining if all of the types are the same as another type
    ///
    template<typename T1, typename T2>
    struct all_same<T1, T2>
    {
        static constexpr bool value = std::is_same<T1, T2>::value;
    };

    // Class Description:
    /// all_same helper
    ///
    template<typename... Ts>
    constexpr bool all_same_v = all_same<Ts...>::value;

    // Class Description:
    /// Template class for determining if dtype is a valid dtype for NdArray
    ///
    template<typename dtype>
    struct is_valid_dtype
    {
        static constexpr bool value =
            std::is_default_constructible<dtype>::value && std::is_nothrow_copy_constructible<dtype>::value &&
            std::is_nothrow_move_constructible<dtype>::value && std::is_nothrow_copy_assignable<dtype>::value &&
            std::is_nothrow_move_assignable<dtype>::value && std::is_nothrow_destructible<dtype>::value &&
            !std::is_void<dtype>::value && !std::is_pointer<dtype>::value && !std::is_array<dtype>::value &&
            !std::is_union<dtype>::value && !std::is_function<dtype>::value && !std::is_abstract<dtype>::value;
    };

    // Class Description:
    /// is_valid_dtype helper
    ///
    template<class dtype>
    constexpr bool is_valid_dtype_v = is_valid_dtype<dtype>::value;

    // Forward declare
    template<typename dtype, class Allocator>
    class NdArray;

    // Class Description:
    /// Template class for determining if dtype is a valid index type for NdArray
    ///
    template<typename>
    struct is_ndarray_int : std::false_type
    {
    };

    // Class Description:
    /// Template class for determining if dtype is a valid index typefor NdArray
    ///

    template<typename dtype, typename Allocator>
    struct is_ndarray_int<NdArray<dtype, Allocator>>
    {
        static constexpr bool value = std::is_integral_v<dtype>;
    };

    // Class Description:
    /// is_ndarray_int helper
    ///
    template<typename T>
    constexpr bool is_ndarray_int_v = is_ndarray_int<T>::value;

    // Class Description:
    /// is_ndarray_int
    ///
    template<typename T>
    using ndarray_int_concept = std::enable_if_t<is_ndarray_int_v<T>, int>;

    // Class Description:
    /// Template class for determining if type is std::complex<>
    ///
    template<class T>
    struct is_complex
    {
        static constexpr bool value = false;
    };

    // Class Description:
    /// Template class specialization for determining if type is std::complex<>
    ///
    template<class T>
    struct is_complex<std::complex<T>>
    {
        static constexpr bool value = true;
    };

    // Class Description:
    /// is_complex helper
    ///
    template<class T>
    constexpr bool is_complex_v = is_complex<T>::value;

    // Class Description:
    /// type trait to test if one value is larger than another at compile time
    ///
    template<std::size_t Value1, std::size_t Value2>
    struct greaterThan
    {
        static constexpr bool value = Value1 > Value2;
    };

    // Class Description:
    /// greaterThan helper
    ///
    template<std::size_t Value1, std::size_t Value2>
    constexpr bool greaterThan_v = greaterThan<Value1, Value2>::value;
} // namespace nc

/*** End of inlined file: TypeTraits.hpp ***/

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_VALID_DTYPE(dtype) \
    static_assert(nc::is_valid_dtype_v<dtype>, "Template type is not a valid dtype for NdArray")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_ARITHMETIC(dtype) \
    static_assert(std::is_arithmetic_v<dtype>, "Can only be used with arithmetic types")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_INTEGER(dtype) static_assert(std::is_integral_v<dtype>, "Can only be used with integer types")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_UNSIGNED_INTEGER(dtype) \
    static_assert(std::is_integral_v<dtype> && std::is_unsigned_v<dtype>, "Can only be used with integer types")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_FLOAT(dtype) static_assert(std::is_floating_point_v<dtype>, "Can only be used with float types")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_COMPLEX(dtype) static_assert(nc::is_complex_v<dtype>, "Can only be used with std::complex types")

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype)                        \
    static_assert(std::is_arithmetic_v<dtype> || nc::is_complex_v<dtype>, \
                  "Can only be used with arithmetic types or std::complex types")

/*** End of inlined file: StaticAsserts.hpp ***/

namespace nc
{

    /// Holds info about the dtype
    template<typename dtype>
    class DtypeInfo
    {
    public:

        /// For integer types: number of non-sign bits in the representation.
        /// For floating types : number of digits(in radix base) in the mantissa
        ///
        /// @return number of bits
        ///
        static constexpr int bits() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::digits;
        }

        /// Machine epsilon (the difference between 1 and the least
        /// value greater than 1 that is representable).
        ///
        /// @return dtype
        ///
        static constexpr dtype epsilon() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::epsilon();
        }

        /// True if type is integer.
        ///
        /// @return bool
        ///
        static constexpr bool isInteger() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::is_integer;
        }

        /// True if type is signed.
        ///
        /// @return bool
        ///
        static constexpr bool isSigned() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::is_signed;
        }

        /// Returns the minimum value of the dtype
        ///
        /// @return min value
        ///
        static constexpr dtype min() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::min();
        }

        /// Returns the maximum value of the dtype
        ///
        /// @return max value
        ///
        static constexpr dtype max() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::max();
        }
    };

    /// Holds info about the std::complex
    template<typename dtype>
    class DtypeInfo<std::complex<dtype>>
    {
    public:

        /// For integer types: number of non-sign bits in the representation.
        /// For floating types : number of digits(in radix base) in the mantissa
        ///
        /// @return number of bits
        ///
        static constexpr int bits() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::digits;
        }

        /// Machine epsilon (the difference between 1 and the least
        /// value greater than 1 that is representable).
        ///
        /// @return dtype
        ///
        static constexpr std::complex<dtype> epsilon() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return { DtypeInfo<dtype>::epsilon(), DtypeInfo<dtype>::epsilon() };
        }

        /// True if type is integer.
        ///
        /// @return bool
        ///
        static constexpr bool isInteger() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::is_integer;
        }

        /// True if type is signed.
        ///
        /// @return bool
        ///
        static constexpr bool isSigned() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return std::numeric_limits<dtype>::is_signed;
        }

        /// Returns the minimum value of the dtype
        ///
        /// @return min value
        ///
        static constexpr std::complex<dtype> min() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return { DtypeInfo<dtype>::min(), DtypeInfo<dtype>::min() };
        }

        /// Returns the maximum value of the dtype
        ///
        /// @return max value
        ///
        static constexpr std::complex<dtype> max() noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return { DtypeInfo<dtype>::max(), DtypeInfo<dtype>::max() };
        }
    };
} // namespace nc

/*** End of inlined file: DtypeInfo.hpp ***/


/*** Start of inlined file: Enums.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Enumerations
///
#pragma once

namespace nc
{

    // Class Description:
    /// Enum To describe an axis
    enum class Axis
    {
        NONE = 0,
        ROW,
        COL
    };

    // Class Description:
    /// Enum for endianess
    enum class Endian
    {
        NATIVE = 0,
        BIG,
        LITTLE
    };

    // Class Description:
    /// Policy for NdArray constructor that takes in a pointer to data
    enum class PointerPolicy
    {
        COPY,
        SHELL
    };

    // Class Description:
    /// Bias boolean
    enum class Bias : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// End Point boolean
    enum class EndPoint : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Increasing boolean
    enum class Increasing : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Is Roots boolean
    enum class IsRoots : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Replace boolean
    enum class Replace : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Print Elapsed Time boolean
    enum class PrintElapsedTime : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Print Results boolean
    enum class PrintResults : bool
    {
        YES = true,
        NO  = false
    };

    // Class Description:
    /// Right or Left side
    ///
    enum class Side
    {
        LEFT,
        RIGHT
    };

    // Class Description:
    /// Interpolation method
    ///
    enum class InterpolationMethod
    {
        LINEAR,
        LOWER,
        HIGHER,
        NEAREST,
        MIDPOINT
    };
} // namespace nc
/*** End of inlined file: Enums.hpp ***/


/*** Start of inlined file: Endian.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for determining and swaping endianess
///
#pragma once

#include <array>
#include <climits>


/*** Start of inlined file: Types.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Usefull types
///
#pragma once

#include <cstdint>

namespace nc
{
    //====================================Typedefs====================================
    using int64  = std::int64_t;
    using int32  = std::int32_t;
    using int16  = std::int16_t;
    using int8   = std::int8_t;
    using uint64 = std::uint64_t;
    using uint32 = std::uint32_t;
    using uint16 = std::uint16_t;
    using uint8  = std::uint8_t;
} // namespace nc

/*** End of inlined file: Types.hpp ***/

namespace nc::endian
{

    // Function Description:
    /// Determines the endianess of the system
    ///
    /// @return bool true if the system is little endian
    ///
    inline bool isLittleEndian() noexcept
    {
        union
        {
            uint32              i{};
            std::array<char, 4> c;
        } fourBytes = { 0x01020304 }; // NOLINT(cppcoreguidelines-avoid-magic-numbers)

        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-union-access)
        return fourBytes.c[0] == 4;
    }

    // Function Description:
    /// Swaps the bytes of the input value
    ///
    /// @param value
    /// @return byte swapped value
    ///
    template<typename dtype>
    dtype byteSwap(dtype value) noexcept
    {
        STATIC_ASSERT_INTEGER(dtype);
        static_assert(CHAR_BIT == 8, "CHAR_BIT != 8"); // NOLINT(cppcoreguidelines-avoid-magic-numbers)

        union
        {
            dtype                            value;
            std::array<uint8, sizeof(dtype)> value8;
        } source, dest;

        source.value = value;

        for (std::size_t k = 0; k < sizeof(dtype); ++k)
        {
            dest.value8[k] = source.value8[sizeof(dtype) - k - 1];
        }

        return dest.value;
    }
} // namespace nc::endian

/*** End of inlined file: Endian.hpp ***/


/*** Start of inlined file: Error.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Standard NumCpp errors
///
#pragma once

#include <iostream>
#include <stdexcept>
#include <string>

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define THROW_INVALID_ARGUMENT_ERROR(msg) \
    nc::error::throwError<std::invalid_argument>(__FILE__, __func__, __LINE__, msg)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define THROW_RUNTIME_ERROR(msg) nc::error::throwError<std::runtime_error>(__FILE__, __func__, __LINE__, msg)

namespace nc::error
{

    /// Makes the full error message string
    ///
    /// @param file: the file
    /// @param function: the function
    /// @param line: the line of the file
    /// @param msg: the message to throw (default "")
    ///
    template<typename ErrorType>
    void throwError(const std::string& file, const std::string& function, uint32 line, const std::string& msg = "")
    {
        std::string errMsg =
            "File: " + file + "\n\tFunction: " + function + "\n\tLine: " + std::to_string(line) + "\n\tError: " + msg;
        std::cerr << errMsg;
        throw ErrorType(errMsg);
    }
} // namespace nc::error

/*** End of inlined file: Error.hpp ***/


/*** Start of inlined file: StdComplexOperators.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Additional operator for std::complex<T>
///
#pragma once

#include <complex>


/*** Start of inlined file: essentiallyEqual.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// tests that 2 floating point values are "essentially equal"
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc::utils
{

    // Method Description:
    /// tests that 2 integer values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_integral<dtype>::value, int> = 0>
    bool essentiallyEqual(dtype inValue1, dtype inValue2) noexcept
    {
        return inValue1 == inValue2;
    }

    // Method Description:
    /// tests that 2 floating point values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    /// @param inEpsilon
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point<dtype>::value, int> = 0>
    bool essentiallyEqual(dtype inValue1, dtype inValue2, dtype inEpsilon) noexcept
    {
        const auto absValue1 = std::abs(inValue1);
        const auto absValue2 = std::abs(inValue2);
        return std::abs(inValue1 - inValue2) <= ((absValue1 > absValue2 ? absValue2 : absValue1) * std::abs(inEpsilon));
    }

    // Method Description:
    /// tests that 2 floating point values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point<dtype>::value, int> = 0>
    bool essentiallyEqual(dtype inValue1, dtype inValue2) noexcept
    {
        return essentiallyEqual(inValue1, inValue2, DtypeInfo<dtype>::epsilon());
    }
} // namespace nc::utils

/*** End of inlined file: essentiallyEqual.hpp ***/

namespace nc
{

    // Method Description:
    /// Less than operator for std::complex<T>
    ///
    /// @param lhs
    /// @param rhs
    /// @return bool true if lhs < rhs
    ///
    template<typename T>
    bool operator<(const std::complex<T>& lhs, const std::complex<T>& rhs) noexcept
    {
        if (!utils::essentiallyEqual(lhs.real(), rhs.real()))
        {
            return lhs.real() < rhs.real();
        }

        return lhs.imag() < rhs.imag();
    }

    // Method Description:
    /// Less than or equal operator for std::complex<T>
    ///
    /// @param lhs
    /// @param rhs
    /// @return bool true if lhs <= rhs
    ///
    template<typename T>
    bool operator<=(const std::complex<T>& lhs, const std::complex<T>& rhs) noexcept
    {
        if (!utils::essentiallyEqual(lhs.real(), rhs.real()))
        {
            return lhs.real() <= rhs.real();
        }

        return lhs.imag() <= rhs.imag();
    }

    // Method Description:
    /// Greater than operator for std::complex<T>
    ///
    /// @param lhs
    /// @param rhs
    /// @return bool true if lhs > rhs
    ///
    template<typename T>
    bool operator>(const std::complex<T>& lhs, const std::complex<T>& rhs) noexcept
    {
        return !(lhs <= rhs);
    }

    // Method Description:
    /// Greater than or equal operator for std::complex<T>
    ///
    /// @param lhs
    /// @param rhs
    /// @return bool true if lhs >= rhs
    ///
    template<typename T>
    bool operator>=(const std::complex<T>& lhs, const std::complex<T>& rhs) noexcept
    {
        return !(lhs < rhs);
    }

    // Method Description:
    /// Greater than or equal operator for std::complex<T>
    ///
    /// @param value
    /// @return std::complex<Out>
    ///
    template<typename Out, typename In>
    std::complex<Out> complex_cast(const std::complex<In>& value) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(Out);

        return std::complex<Out>(static_cast<Out>(value.real()), static_cast<Out>(value.imag()));
    }
} // namespace nc

/*** End of inlined file: StdComplexOperators.hpp ***/


/*** Start of inlined file: StlAlgorithms.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Macro to define whether or not c++17 parallel algorithm policies are supported
///
#pragma once

#include <algorithm>
#include <iterator>
#include <numeric>
#include <utility>

#if defined(__cpp_lib_parallel_algorithm) && defined(NUMCPP_USE_MULTITHREAD)
#define PARALLEL_ALGORITHMS_SUPPORTED
#define CONDITIONAL_NO_EXCEPT
#include <execution>
#else
#define CONDITIONAL_NO_EXCEPT noexcept
#endif

namespace nc::stl_algorithms
{

    // Method Description:
    /// Tests if all of the elements of a range satisy a predicate
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param p: unary predicate function
    /// @return bool
    ///
    template<class InputIt, class UnaryPredicate>
    bool all_of(InputIt first, InputIt last, UnaryPredicate p) CONDITIONAL_NO_EXCEPT
    {
        return std::all_of(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            p);
    }

    // Method Description:
    /// Tests if any of the elements of a range satisy a predicate
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param p: unary predicate function
    /// @return bool
    ///
    template<class InputIt, class UnaryPredicate>
    bool any_of(InputIt first, InputIt last, UnaryPredicate p) CONDITIONAL_NO_EXCEPT
    {
        return std::any_of(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            p);
    }

    // Method Description:
    /// Copies from one container to another
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param destination: the first iterator of the destination
    /// @return OutputIt
    ///
    template<class InputIt, class OutputIt>
    OutputIt copy(InputIt first, InputIt last, OutputIt destination) CONDITIONAL_NO_EXCEPT
    {
        return std::copy(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            destination);
    }

    // Method Description:
    /// Counts the values in the range
    ///
    /// @param first: the first iterator of container
    /// @param last: the last iterator of container
    /// @param value: the initial value
    /// @return count
    ///
    template<class InputIt, class T>
    typename std::iterator_traits<InputIt>::difference_type
        count(InputIt first, InputIt last, const T& value) CONDITIONAL_NO_EXCEPT
    {
        return std::count(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            value);
    }

    // Method Description:
    /// Test if two ranges are equal
    ///
    /// @param first1: the first iterator of first container
    /// @param last1: the last iterator of first container
    /// @param first2: the first iterator of second container
    /// @return bool
    ///
    template<class InputIt1, class InputIt2>
    bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2) CONDITIONAL_NO_EXCEPT
    {
        return std::equal(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2);
    }

    // Method Description:
    /// Test if two ranges are equal
    ///
    /// @param first1: the first iterator of first container
    /// @param last1: the last iterator of first container
    /// @param first2: the first iterator of second container
    /// @param p: binary predicate to compare the elements
    /// @return bool
    ///
    template<class InputIt1, class InputIt2, class BinaryPredicate>
    bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p) CONDITIONAL_NO_EXCEPT
    {
        return std::equal(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            p);
    }

    // Method Description:
    /// Fills the range with the value
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param value: the function to apply to the input iterators
    ///
    template<class ForwardIt, class T>
    void fill(ForwardIt first, ForwardIt last, const T& value) CONDITIONAL_NO_EXCEPT
    {
        return std::fill(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            value);
    }

    // Method Description:
    /// Returns the first element in the range [first, last)
    /// that satisfies specific criteria:
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param value: the value to find
    /// @return InputIt
    ///
    template<class InputIt, class T>
    InputIt find(InputIt first, InputIt last, const T& value) CONDITIONAL_NO_EXCEPT
    {
        return std::find(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            value);
    }

    // Method Description:
    /// Runs the function on each element of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param f: the function to apply to the input iterators
    ///
    template<class InputIt, class UnaryFunction>
    void for_each(InputIt first, InputIt last, UnaryFunction f)
    {
        std::for_each(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            f);
    }

    // Method Description:
    /// Returns true if the array is sorted
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @return bool true if sorted
    ///
    template<class ForwardIt>
    bool is_sorted(ForwardIt first, ForwardIt last) CONDITIONAL_NO_EXCEPT
    {
        return std::is_sorted(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Returns true if the array is sorted
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: comparitor function
    /// @return bool true if sorted
    ///
    template<class ForwardIt, class Compare>
    bool is_sorted(ForwardIt first, ForwardIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        return std::is_sorted(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Returns the maximum element of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @return ForwordIt
    ///
    template<class ForwardIt>
    ForwardIt max_element(ForwardIt first, ForwardIt last) CONDITIONAL_NO_EXCEPT
    {
        return std::max_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Returns the maximum element of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: the comparitor function
    /// @return ForwordIt
    ///
    template<class ForwardIt, class Compare>
    ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        return std::max_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Returns the minimum element of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @return ForwardIt
    template<class ForwardIt>
    ForwardIt min_element(ForwardIt first, ForwardIt last) CONDITIONAL_NO_EXCEPT
    {
        return std::min_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Returns the minimum element of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: the comparitor function
    /// @return ForwordIt
    ///
    template<class ForwardIt, class Compare>
    ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        return std::min_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Runs the minimum and maximum elements of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @return std::pair
    ///
    template<class ForwardIt>
    std::pair<ForwardIt, ForwardIt> minmax_element(ForwardIt first, ForwardIt last) CONDITIONAL_NO_EXCEPT
    {
        return std::minmax_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Runs the minimum and maximum elements of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: the comparitor function
    /// @return std::pair
    ///
    template<class ForwardIt, class Compare>
    std::pair<ForwardIt, ForwardIt> minmax_element(ForwardIt first, ForwardIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        return std::minmax_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Tests if none of the elements of a range satisy a predicate
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param p: unary predicate function
    /// @return bool
    ///
    template<class InputIt, class UnaryPredicate>
    bool none_of(InputIt first, InputIt last, UnaryPredicate p) CONDITIONAL_NO_EXCEPT
    {
        return std::none_of(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            p);
    }

    // Method Description:
    /// Sorts up to the nth element
    ///
    /// @param first: the first iterator of the range
    /// @param nth: the element that should be sorted
    /// @param last: the last iterator of the range
    ///
    template<class RandomIt>
    void nth_element(RandomIt first, RandomIt nth, RandomIt last) CONDITIONAL_NO_EXCEPT
    {
        std::nth_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            nth,
            last);
    }

    // Method Description:
    /// Sorts up to the nth element
    ///
    /// @param first: the first iterator of the range
    /// @param nth: the element that should be sorted
    /// @param last: the last iterator of the range
    /// @param comp: the comparitor function
    ///
    template<class RandomIt, class Compare>
    void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        std::nth_element(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            nth,
            last,
            comp);
    }

    // Method Description:
    /// replaces a value in the range with another value
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param oldValue: the value to replace
    /// @param newValue: the replacement value
    ///
    template<class ForwardIt, class T>
    void replace(ForwardIt first, ForwardIt last, const T& oldValue, const T& newValue) CONDITIONAL_NO_EXCEPT
    {
        std::replace(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            oldValue,
            newValue);
    }

    // Method Description:
    /// reverses the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    ///
    template<class BidirIt>
    void reverse(BidirIt first, BidirIt last) CONDITIONAL_NO_EXCEPT
    {
        std::reverse(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Rotates the elements of a range
    ///
    /// @param first: the first iterator of the range
    /// @param firstN: the element that should appear at the beginning of the rotated range
    /// @param last: the last iterator of the range
    ///
    template<class ForwardIt>
    void rotate(ForwardIt first, ForwardIt firstN, ForwardIt last) CONDITIONAL_NO_EXCEPT
    {
        std::rotate(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            firstN,
            last);
    }

    // Method Description:
    /// finds the difference of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt>
    OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination)
    {
        return std::set_difference(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination);
    }

    // Method Description:
    /// finds the difference of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @param comp: comparitor function
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt, class Compare>
    OutputIt set_difference(InputIt1 first1,
                            InputIt1 last1,
                            InputIt2 first2,
                            InputIt2 last2,
                            OutputIt destination,
                            Compare  comp) CONDITIONAL_NO_EXCEPT
    {
        return std::set_difference(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination,
            comp);
    }

    // Method Description:
    /// finds the intersection of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt>
    OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination)
        CONDITIONAL_NO_EXCEPT
    {
        return std::set_intersection(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination);
    }

    // Method Description:
    /// finds the intersection of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @param comp: comparitor function
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt, class Compare>
    OutputIt set_intersection(InputIt1 first1,
                              InputIt1 last1,
                              InputIt2 first2,
                              InputIt2 last2,
                              OutputIt destination,
                              Compare  comp) CONDITIONAL_NO_EXCEPT
    {
        return std::set_intersection(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination,
            comp);
    }

    // Method Description:
    /// finds the union of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt>
    OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination)
        CONDITIONAL_NO_EXCEPT
    {
        return std::set_union(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination);
    }

    // Method Description:
    /// finds the union of two ranges
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param last2: the first iterator of the destination
    /// @param destination: the function to apply to the input iterators
    /// @param comp: comparitor function
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt, class Compare>
    OutputIt
        set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp)
            CONDITIONAL_NO_EXCEPT
    {
        return std::set_union(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            last2,
            destination,
            comp);
    }

    // Method Description:
    /// Sorts the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    ///
    template<class RandomIt>
    void sort(RandomIt first, RandomIt last) CONDITIONAL_NO_EXCEPT
    {
        return std::sort(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Sorts the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: the comparitor function
    ///
    template<class RandomIt, class Compare>
    void sort(RandomIt first, RandomIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        return std::sort(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Sorts the range preserving order
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    ///
    template<class RandomIt>
    void stable_sort(RandomIt first, RandomIt last) CONDITIONAL_NO_EXCEPT
    {
        std::stable_sort(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last);
    }

    // Method Description:
    /// Sorts the range preserving order
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param comp: the comparitor function
    ///
    template<class RandomIt, class Compare>
    void stable_sort(RandomIt first, RandomIt last, Compare comp) CONDITIONAL_NO_EXCEPT
    {
        std::stable_sort(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            comp);
    }

    // Method Description:
    /// Transforms the elements of the range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param destination: the first iterator of the destination
    /// @param unaryFunction: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt, class OutputIt, class UnaryOperation>
    OutputIt transform(InputIt first, InputIt last, OutputIt destination, UnaryOperation unaryFunction)
    {
        return std::transform(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            destination,
            unaryFunction);
    }

    // Method Description:
    /// Transforms the elements of the range
    ///
    /// @param first1: the first iterator of the source
    /// @param last1: the last iterator of the source
    /// @param first2: the first iterator of the second source
    /// @param destination: the first iterator of the destination
    /// @param unaryFunction: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt1, class InputIt2, class OutputIt, class BinaryOperation>
    OutputIt
        transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt destination, BinaryOperation unaryFunction)
    {
        return std::transform(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first1,
            last1,
            first2,
            destination,
            unaryFunction);
    }

    // Method Description:
    /// Copies the unique elements of a range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param destination: the first iterator of the destination
    /// @return OutputIt
    ///
    template<class InputIt, class OutputIt>
    constexpr OutputIt unique_copy(InputIt first, InputIt last, OutputIt destination) CONDITIONAL_NO_EXCEPT
    {
        return std::unique_copy(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            destination);
    }

    // Method Description:
    /// Copies the unique elements of a range
    ///
    /// @param first: the first iterator of the source
    /// @param last: the last iterator of the source
    /// @param destination: the first iterator of the destination
    /// @param binaryFunction: the function to apply to the input iterators
    /// @return OutputIt
    ///
    template<class InputIt, class OutputIt, class BinaryPredicate>
    constexpr OutputIt unique_copy(InputIt first, InputIt last, OutputIt destination, BinaryPredicate binaryFunction)
        CONDITIONAL_NO_EXCEPT
    {
        return std::unique_copy(
#ifdef PARALLEL_ALGORITHMS_SUPPORTED
            std::execution::par_unseq,
#endif
            first,
            last,
            destination,
            binaryFunction);
    }
} // namespace nc::stl_algorithms

/*** End of inlined file: StlAlgorithms.hpp ***/


/*** Start of inlined file: Shape.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A Shape Class for NdArrays
///
#pragma once

#include <iostream>
#include <string>


/*** Start of inlined file: num2str.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Converts the number into a string
///
#pragma once

#include <string>

namespace nc::utils
{

    /// Converts the number into a string
    ///
    /// @param inNumber
    ///
    /// @return std::string
    ///
    template<typename dtype>
    std::string num2str(dtype inNumber)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::to_string(inNumber);
    }
} // namespace nc::utils

/*** End of inlined file: num2str.hpp ***/

namespace nc
{

    /// A Shape Class for NdArrays
    class Shape
    {
    public:
        //====================================Attributes==============================
        uint32 rows{ 0 };
        uint32 cols{ 0 };

        /// Constructor
        ///
        constexpr Shape() = default;

        /// Constructor
        ///
        /// @param inSquareSize
        ///
        constexpr explicit Shape(uint32 inSquareSize) noexcept :
            rows(inSquareSize),
            cols(inSquareSize)
        {
        }

        /// Constructor
        ///
        /// @param inRows
        /// @param inCols
        ///
        constexpr Shape(uint32 inRows, uint32 inCols) noexcept :
            rows(inRows),
            cols(inCols)
        {
        }

        /// Equality operator
        ///
        /// @param inOtherShape
        ///
        /// @return bool
        ///
        bool operator==(const Shape& inOtherShape) const noexcept
        {
            return rows == inOtherShape.rows && cols == inOtherShape.cols;
        }

        /// Not equality operator
        ///
        /// @param inOtherShape
        ///
        /// @return bool
        ///
        bool operator!=(const Shape& inOtherShape) const noexcept
        {
            return !(*this == inOtherShape);
        }

        /// Returns the size of the shape
        ///
        /// @return size
        ///
        [[nodiscard]] uint32 size() const noexcept
        {
            return rows * cols;
        }

        /// Returns whether the shape is null (constructed with the
        /// default constructor).
        ///
        /// @return bool
        ///
        [[nodiscard]] bool isnull() const noexcept
        {
            return rows == 0 && cols == 0;
        }

        /// Returns whether the shape is square or not.
        ///
        /// @return bool
        ///
        [[nodiscard]] bool issquare() const noexcept
        {
            return rows == cols;
        }

        /// Returns the shape as a string representation
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out = "[" + utils::num2str(rows) + ", " + utils::num2str(cols) + "]\n";
            return out;
        }

        /// Prints the shape to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        /// IO operator for the Shape class
        ///
        /// @param inOStream
        /// @param inShape
        ///
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inOStream, const Shape& inShape)
        {
            inOStream << inShape.str();
            return inOStream;
        }
    };
} // namespace nc

/*** End of inlined file: Shape.hpp ***/


/*** Start of inlined file: Slice.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A Class for slicing into NdArrays
///

#pragma once

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

namespace nc
{

    /// A Class for slicing into NdArrays
    class Slice
    {
    public:
        //====================================Attributes==============================
        int32 start{ 0 };
        int32 stop{ 1 };
        int32 step{ 1 };

        /// Constructor
        ///
        constexpr Slice() = default;

        /// Constructor
        ///
        /// @param inStop (index not included)
        ///
        constexpr explicit Slice(int32 inStop) noexcept :
            stop(inStop)
        {
        }

        /// Constructor
        ///
        /// @param inStart
        /// @param inStop (index not included)
        ///
        constexpr Slice(int32 inStart, int32 inStop) noexcept :
            start(inStart),
            stop(inStop)
        {
        }

        /// Constructor
        ///
        /// @param inStart
        /// @param inStop (not included)
        /// @param inStep
        ///
        constexpr Slice(int32 inStart, int32 inStop, int32 inStep) noexcept :
            start(inStart),
            stop(inStop),
            step(inStep)
        {
        }

        /// Equality operator
        ///
        /// @param inOtherSlice
        ///
        /// @return bool
        ///
        bool operator==(const Slice& inOtherSlice) const noexcept
        {
            return start == inOtherSlice.start && stop == inOtherSlice.stop && step == inOtherSlice.step;
        }

        /// Not equality operator
        ///
        /// @param inOtherSlice
        ///
        /// @return bool
        ///
        bool operator!=(const Slice& inOtherSlice) const noexcept
        {
            return !(*this == inOtherSlice);
        }

        /// Prints the shape to the console
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out =
                "[" + utils::num2str(start) + ":" + utils::num2str(stop) + ":" + utils::num2str(step) + "]\n";
            return out;
        }

        /// Prints the shape to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        /// Make the slice all positive and does some error checking
        ///
        /// @param inArraySize
        ///
        void makePositiveAndValidate(uint32 inArraySize)
        {
            /// convert the start value
            if (start < 0)
            {
                start += static_cast<int32>(inArraySize);
            }
            if (start > static_cast<int32>(inArraySize - 1))
            {
                THROW_INVALID_ARGUMENT_ERROR("Invalid start value for array of size " + utils::num2str(inArraySize));
            }

            /// convert the stop value
            if (stop < 0)
            {
                stop += static_cast<int32>(inArraySize);
            }
            if (stop > static_cast<int32>(inArraySize))
            {
                THROW_INVALID_ARGUMENT_ERROR("Invalid stop value for array of size " + utils::num2str(inArraySize));
            }

            /// do some error checking
            if (start < stop)
            {
                if (step < 0)
                {
                    THROW_INVALID_ARGUMENT_ERROR("Invalid slice values [" + utils::num2str(start) + ", " +
                                                 utils::num2str(stop) + ", " + utils::num2str(step) + ']');
                }
            }

            if (stop < start)
            {
                if (step > 0)
                {
                    THROW_INVALID_ARGUMENT_ERROR("Invalid slice values [" + utils::num2str(start) + ", " +
                                                 utils::num2str(stop) + ", " + utils::num2str(step) + ']');
                }

                /// otherwise flip things around for my own sanity
                std::swap(start, stop);
                step *= -1;
            }
        }

        /// Returns the number of elements that the slice contains.
        /// be aware that this method will also make the slice all
        /// positive!
        ///
        /// @param inArraySize
        ///
        uint32 numElements(uint32 inArraySize)
        {
            makePositiveAndValidate(inArraySize);

            uint32 num = 0;
            for (int32 i = start; i < stop; i += step)
            {
                ++num;
            }
            return num;
        }

        /// Returns the indices that coorespond to the slice
        /// be aware that this method will also make the slice all
        /// positive!
        ///
        /// @param inArrayDimSize: the size of the dimension that is being sliced
        ///
        std::vector<uint32> toIndices(uint32 inArrayDimSize)
        {
            std::vector<uint32> indices;
            indices.reserve(numElements(inArrayDimSize));
            for (int32 i = start; i < stop; i += step)
            {
                indices.push_back(static_cast<uint32>(i));
            }
            return indices;
        }

        /// IO operator for the Slice class
        ///
        /// @param inOStream
        /// @param inSlice
        ///
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inOStream, const Slice& inSlice)
        {
            inOStream << inSlice.str();
            return inOStream;
        }
    };
} // namespace nc

/*** End of inlined file: Slice.hpp ***/


/*** Start of inlined file: NdArrayIterators.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Custom iterators for the NdArray class
///
#pragma once

#include <iterator>

namespace nc
{

    // Class Description:
    /// Custom const_iterator for NdArray
    template<typename dtype, typename PointerType, typename DifferenceType>
    class NdArrayConstIterator
    {
    private:
        using self_type = NdArrayConstIterator<dtype, PointerType, DifferenceType>;

    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = dtype;
        using pointer           = PointerType;
        using reference         = const value_type&;
        using difference_type   = DifferenceType;

        // Method Description:
        /// Default Constructor
        ///
        NdArrayConstIterator() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param ptr: the iterator pointer
        ///
        explicit NdArrayConstIterator(pointer ptr) noexcept :
            ptr_(ptr)
        {
        }

        // Method Description:
        /// Iterator dereference
        ///
        /// @return reference
        ///
        reference operator*() const noexcept
        {
            return *ptr_;
        }

        // Method Description:
        /// Iterator pointer operator
        ///
        /// @return pointer
        ///
        pointer operator->() const noexcept
        {
            return ptr_;
        }

        // Method Description:
        /// Iterator prefix incrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator++() noexcept
        {
            ++ptr_;
            return *this;
        }

        // Method Description:
        /// Iterator postfix incrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator++(int) noexcept
        {
            self_type tmp = *this;
            ++*this;
            return tmp;
        }

        // Method Description:
        /// Iterator prefix decrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator--() noexcept
        {
            --ptr_;
            return *this;
        }

        // Method Description:
        /// Iterator postfix decrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator--(int) noexcept
        {
            self_type tmp = *this;
            --*this;
            return tmp;
        }

        // Method Description:
        /// Iterator addition assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator+=(const difference_type offset) noexcept
        {
            ptr_ += offset;
            return *this;
        }

        // Method Description:
        /// Iterator addition operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator+(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp += offset;
        }

        // Method Description:
        /// Iterator subtraction assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator-=(const difference_type offset) noexcept
        {
            return *this += -offset;
        }

        // Method Description:
        /// Iterator subtraction operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator-(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp -= offset;
        }

        // Method Description:
        /// Iterator difference operator
        ///
        /// @param rhs
        /// @return difference_type
        ///
        difference_type operator-(const self_type& rhs) const noexcept
        {
            return ptr_ - rhs.ptr_;
        }

        // Method Description:
        /// Iterator access operator
        ///
        /// @param offset
        /// @return reference
        ///
        reference operator[](const difference_type offset) const noexcept
        {
            return *(*this + offset);
        }

        // Method Description:
        /// Iterator equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator==(const self_type& rhs) const noexcept
        {
            return ptr_ == rhs.ptr_;
        }

        // Method Description:
        /// Iterator not-equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator!=(const self_type& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Method Description:
        /// Iterator less than operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator<(const self_type& rhs) const noexcept
        {
            return ptr_ < rhs.ptr_;
        }

        // Method Description:
        /// Iterator greater than operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator>(const self_type& rhs) const noexcept
        {
            return rhs < *this;
        }

        // Method Description:
        /// Iterator less than equal operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator<=(const self_type& rhs) const noexcept
        {
            return !(rhs < *this);
        }

        // Method Description:
        /// Iterator greater than equal operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator>=(const self_type& rhs) const noexcept
        {
            return !(*this < rhs);
        }

    private:
        pointer ptr_{ nullptr };
    };

    // Method Description:
    /// Iterator addition operator
    ///
    /// @param offset
    /// @param next
    /// @return bool
    ///
    template<class dtype, typename PointerType, typename DifferenceType>
    NdArrayConstIterator<dtype, PointerType, DifferenceType>
        operator+(typename NdArrayConstIterator<dtype, PointerType, DifferenceType>::difference_type offset,
                  NdArrayConstIterator<dtype, PointerType, DifferenceType>                           next) noexcept
    {
        return next += offset;
    }

    // Class Description:
    /// Custom iterator for NdArray
    template<typename dtype, typename PointerType, typename DifferenceType>
    class NdArrayIterator : public NdArrayConstIterator<dtype, PointerType, DifferenceType>
    {
    private:
        using MyBase    = NdArrayConstIterator<dtype, PointerType, DifferenceType>;
        using self_type = NdArrayIterator<dtype, PointerType, DifferenceType>;

    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = dtype;
        using pointer           = PointerType;
        using reference         = value_type&;
        using difference_type   = DifferenceType;

        using MyBase::MyBase;

        // Method Description:
        /// Iterator dereference
        ///
        /// @return reference
        ///
        reference operator*() const noexcept
        {
            return const_cast<reference>(MyBase::operator*());
        }

        // Method Description:
        /// Iterator pointer operator
        ///
        /// @return pointer
        ///
        pointer operator->() const noexcept
        {
            return const_cast<pointer>(MyBase::operator->());
        }

        // Method Description:
        /// Iterator prefix incrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator++() noexcept
        {
            MyBase::operator++();
            return *this;
        }

        // Method Description:
        /// Iterator postfix incrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator++(int) noexcept
        {
            self_type tmp = *this;
            MyBase::operator++();
            return tmp;
        }

        // Method Description:
        /// Iterator prefix decrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator--() noexcept
        {
            MyBase::operator--();
            return *this;
        }

        // Method Description:
        /// Iterator postfix decrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator--(int) noexcept
        {
            self_type tmp = *this;
            MyBase::operator--();
            return tmp;
        }

        // Method Description:
        /// Iterator addition assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator+=(const difference_type offset) noexcept
        {
            MyBase::operator+=(offset);
            return *this;
        }

        // Method Description:
        /// Iterator addition operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator+(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp += offset;
        }

        // Method Description:
        /// Iterator subtraction assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator-=(const difference_type offset) noexcept
        {
            MyBase::operator-=(offset);
            return *this;
        }

        using MyBase::operator-;

        // Method Description:
        /// Iterator difference operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator-(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp -= offset;
        }

        // Method Description:
        /// Iterator access operator
        ///
        /// @param offset
        /// @return reference
        ///
        reference operator[](const difference_type offset) const noexcept
        {
            return const_cast<reference>(MyBase::operator[](offset));
        }
    };

    // Method Description:
    /// Iterator addition operator
    ///
    /// @param offset
    /// @param next
    /// @return NdArrayIterator
    ///
    template<class dtype, typename PointerType, typename DifferenceType>
    NdArrayIterator<dtype, PointerType, DifferenceType>
        operator+(typename NdArrayIterator<dtype, PointerType, DifferenceType>::difference_type offset,
                  NdArrayIterator<dtype, PointerType, DifferenceType>                           next) noexcept
    {
        return next += offset;
    }

    // Class Description:
    /// Custom column const_iterator for NdArray
    template<typename dtype, typename SizeType, typename PointerType, typename DifferenceType>
    class NdArrayConstColumnIterator
    {
    private:
        using self_type = NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType>;

    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = dtype;
        using size_type         = SizeType;
        using pointer           = PointerType;
        using reference         = const value_type&;
        using difference_type   = DifferenceType;

        // Method Description:
        /// Default Constructor
        ///
        NdArrayConstColumnIterator() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param ptr: the iterator pointer
        /// @param numRows: the number of rows in the array
        /// @param numCols: the number of cols in the array
        ///
        NdArrayConstColumnIterator(pointer ptr, SizeType numRows, SizeType numCols) noexcept :
            ptr_(ptr),
            currPtr_(ptr),
            numRows_(static_cast<difference_type>(numRows)),
            numCols_(static_cast<difference_type>(numCols)),
            size_(numRows_ * numCols_)
        {
        }

        // Method Description:
        /// Iterator dereference
        ///
        /// @return reference
        ///
        reference operator*() const noexcept
        {
            return *currPtr_;
        }

        // Method Description:
        /// Iterator pointer operator
        ///
        /// @return pointer
        ///
        pointer operator->() const noexcept
        {
            return currPtr_;
        }

        // Method Description:
        /// Iterator prefix incrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator++() noexcept
        {
            return *this += 1;
        }

        // Method Description:
        /// Iterator postfix incrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator++(int) noexcept
        {
            self_type tmp = *this;
            ++*this;
            return tmp;
        }

        // Method Description:
        /// Iterator prefix decrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator--() noexcept
        {
            return *this -= 1;
        }

        // Method Description:
        /// Iterator postfix decrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator--(int) noexcept
        {
            self_type tmp = *this;
            --*this;
            return tmp;
        }

        // Method Description:
        /// Iterator addition assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator+=(const difference_type offset) noexcept
        {
            currPtr_ = colIdx2Ptr(ptr2ColIdx(currPtr_) + offset);
            return *this;
        }

        // Method Description:
        /// Iterator addition operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator+(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp += offset;
        }

        // Method Description:
        /// Iterator subtraction assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator-=(const difference_type offset) noexcept
        {
            return *this += -offset;
        }

        // Method Description:
        /// Iterator subtraction operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator-(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp -= offset;
        }

        // Method Description:
        /// Iterator difference operator
        ///
        /// @param rhs
        /// @return difference_type
        ///
        difference_type operator-(const self_type& rhs) const noexcept
        {
            return ptr2ColIdx(currPtr_) - ptr2ColIdx(rhs.currPtr_);
        }

        // Method Description:
        /// Iterator access operator
        ///
        /// @param offset
        /// @return reference
        ///
        reference operator[](const difference_type offset) const noexcept
        {
            return *(*this + offset);
        }

        // Method Description:
        /// Iterator equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator==(const self_type& rhs) const noexcept
        {
            return currPtr_ == rhs.currPtr_;
        }

        // Method Description:
        /// Iterator not-equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator!=(const self_type& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Method Description:
        /// Iterator less than operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator<(const self_type& rhs) const noexcept
        {
            return *this - rhs < 0;
        }

        // Method Description:
        /// Iterator greater than operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator>(const self_type& rhs) const noexcept
        {
            return *this - rhs > 0;
        }

        // Method Description:
        /// Iterator less than equal operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator<=(const self_type& rhs) const noexcept
        {
            return !(rhs < *this);
        }

        // Method Description:
        /// Iterator greater than equal operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator>=(const self_type& rhs) const noexcept
        {
            return !(*this < rhs);
        }

    private:
        pointer         ptr_{};
        pointer         currPtr_{};
        difference_type numRows_{ 0 };
        difference_type numCols_{ 0 };
        difference_type size_{ 0 };

        // Method Description:
        /// Converts a pointer to column order index
        ///
        /// @param ptr
        /// @return difference_type
        ///
        difference_type ptr2ColIdx(pointer ptr) const noexcept
        {
            if (ptr == nullptr)
            {
                return size_;
            }

            const auto rowIdx = ptr - ptr_;
            if (rowIdx >= size_)
            {
                return size_;
            }

            const auto row = rowIdx / numCols_;
            const auto col = rowIdx % numCols_;
            return row + col * numRows_;
        }

        // Method Description:
        /// Converts column order index to a pointer
        ///
        /// @param colIdx
        /// @return pointer
        ///
        pointer colIdx2Ptr(difference_type colIdx) const noexcept
        {
            if (colIdx >= size_)
            {
                return nullptr;
            }

            const auto row    = colIdx % numRows_;
            const auto col    = colIdx / numRows_;
            const auto rowIdx = col + row * numCols_;
            return ptr_ + rowIdx;
        }
    };

    // Method Description:
    /// Iterator addition operator
    ///
    /// @param offset
    /// @param next
    /// @return bool
    ///
    template<class dtype, typename SizeType, typename PointerType, typename DifferenceType>
    NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType> operator+(
        typename NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType>::difference_type offset,
        NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType> next) noexcept
    {
        return next += offset;
    }

    // Class Description:
    /// Custom column iterator for NdArray
    template<typename dtype, typename SizeType, typename PointerType, typename DifferenceType>
    class NdArrayColumnIterator : public NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType>
    {
    private:
        using MyBase    = NdArrayConstColumnIterator<dtype, SizeType, PointerType, DifferenceType>;
        using self_type = NdArrayColumnIterator<dtype, SizeType, PointerType, DifferenceType>;

    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = dtype;
        using size_type         = SizeType;
        using pointer           = PointerType;
        using reference         = value_type&;
        using difference_type   = DifferenceType;

        using MyBase::MyBase;

        // Method Description:
        /// Iterator dereference
        ///
        /// @return reference
        ///
        reference operator*() const noexcept
        {
            return const_cast<reference>(MyBase::operator*());
        }

        // Method Description:
        /// Iterator pointer operator
        ///
        /// @return pointer
        ///
        pointer operator->() const noexcept
        {
            return const_cast<pointer>(MyBase::operator->());
        }

        // Method Description:
        /// Iterator prefix incrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator++() noexcept
        {
            MyBase::operator++();
            return *this;
        }

        // Method Description:
        /// Iterator postfix incrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator++(int) noexcept
        {
            self_type tmp = *this;
            MyBase::operator++();
            return tmp;
        }

        // Method Description:
        /// Iterator prefix decrament operator
        ///
        /// @return NdArrayConstIterator&
        ///
        self_type& operator--() noexcept
        {
            MyBase::operator--();
            return *this;
        }

        // Method Description:
        /// Iterator postfix decrament operator
        ///
        /// @return NdArrayConstIterator
        ///
        self_type operator--(int) noexcept
        {
            self_type tmp = *this;
            MyBase::operator--();
            return tmp;
        }

        // Method Description:
        /// Iterator addition assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator+=(const difference_type offset) noexcept
        {
            MyBase::operator+=(offset);
            return *this;
        }

        // Method Description:
        /// Iterator addition operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator+(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp += offset;
        }

        // Method Description:
        /// Iterator subtraction assignement operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator&
        ///
        self_type& operator-=(const difference_type offset) noexcept
        {
            MyBase::operator-=(offset);
            return *this;
        }

        using MyBase::operator-;

        // Method Description:
        /// Iterator difference operator
        ///
        /// @param offset
        /// @return NdArrayConstIterator
        ///
        self_type operator-(const difference_type offset) const noexcept
        {
            self_type tmp = *this;
            return tmp -= offset;
        }

        // Method Description:
        /// Iterator access operator
        ///
        /// @param offset
        /// @return reference
        ///
        reference operator[](const difference_type offset) const noexcept
        {
            return const_cast<reference>(MyBase::operator[](offset));
        }
    };

    // Method Description:
    /// Iterator addition operator
    ///
    /// @param offset
    /// @param next
    /// @return bool
    ///
    template<class dtype, typename SizeType, typename PointerType, typename DifferenceType>
    NdArrayColumnIterator<dtype, SizeType, PointerType, DifferenceType>
        operator+(typename NdArrayColumnIterator<dtype, SizeType, PointerType, DifferenceType>::difference_type offset,
                  NdArrayColumnIterator<dtype, SizeType, PointerType, DifferenceType> next) noexcept
    {
        return next += offset;
    }
} // namespace nc

/*** End of inlined file: NdArrayIterators.hpp ***/


/*** Start of inlined file: essentiallyEqualComplex.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// tests that 2 floating point values are "essentially equal"
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc::utils
{

    /// tests that 2 complex values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_integral<dtype>::value, int> = 0>
    bool essentiallyEqual(const std::complex<dtype>& inValue1, const std::complex<dtype>& inValue2) noexcept
    {
        return inValue1 == inValue2;
    }

    /// tests that 2 complex values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    /// @param inEpsilon
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point<dtype>::value, int> = 0>
    bool essentiallyEqual(const std::complex<dtype>& inValue1,
                          const std::complex<dtype>& inValue2,
                          const std::complex<dtype>& inEpsilon) noexcept
    {
        const auto absValue1 = std::abs(inValue1);
        const auto absValue2 = std::abs(inValue2);
        return std::abs(inValue1 - inValue2) <= ((absValue1 > absValue2 ? absValue2 : absValue1) * std::abs(inEpsilon));
    }

    /// tests that 2 floating point values are "essentially equal"
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return bool
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point<dtype>::value, int> = 0>
    bool essentiallyEqual(const std::complex<dtype>& inValue1, const std::complex<dtype>& inValue2) noexcept
    {
        return essentiallyEqual(inValue1, inValue2, DtypeInfo<std::complex<dtype>>::epsilon());
    }
} // namespace nc::utils

/*** End of inlined file: essentiallyEqualComplex.hpp ***/


/*** Start of inlined file: power.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Raises the input value to an integer power
///
#pragma once

#include <complex>

namespace nc::utils
{

    /// Raises the input value to an integer power
    ///
    /// @param inValue
    /// @param inPower
    ///
    /// @return inValue raised to inPower
    ///
    template<typename dtype>
    dtype power(dtype inValue, uint8 inPower) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (inPower == 0)
        {
            return static_cast<dtype>(1);
        }

        dtype returnVal = inValue;
        for (uint8 exponent = 1; exponent < inPower; ++exponent)
        {
            returnVal *= inValue;
        }
        return returnVal;
    }
} // namespace nc::utils

/*** End of inlined file: power.hpp ***/


/*** Start of inlined file: sqr.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Squares in input value
///
#pragma once

namespace nc::utils
{

    /// Squares in input value
    ///
    /// @param inValue
    ///
    /// @return squared value
    ///
    template<typename dtype>
    constexpr dtype sqr(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return inValue * inValue;
    }
} // namespace nc::utils

/*** End of inlined file: sqr.hpp ***/


/*** Start of inlined file: value2str.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Converts the number into a string
///
#pragma once

#include <complex>
#include <sstream>
#include <string>

namespace nc::utils
{

    /// Converts the value into a string
    ///
    /// @param inValue
    ///
    /// @return std::string
    ///
    template<typename dtype>
    std::string value2str(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        std::stringstream ss;
        ss << inValue;
        return ss.str();
    }
} // namespace nc::utils

/*** End of inlined file: value2str.hpp ***/

namespace nc
{
    namespace type_traits
    {

        // Class Description:
        /// Template class for determining if dtype is a valid index type for NdArray
        ///
        template<typename>
        struct is_ndarray_int : std::false_type
        {
        };

        // Class Description:
        /// Template class for determining if dtype is a valid index typefor NdArray
        ///

        template<typename dtype, typename Allocator>
        struct is_ndarray_int<NdArray<dtype, Allocator>>
        {
            static constexpr bool value = std::is_integral_v<dtype>;
        };

        // Class Description:
        /// is_ndarray_int helper
        ///
        template<typename T>
        constexpr bool is_ndarray_int_v = is_ndarray_int<T>::value;

        // Class Description:
        /// Template class for determining if dtype is an unsigned integer type
        ///
        template<typename>
        struct is_ndarray_signed_int : std::false_type
        {
        };

        // Class Description:
        /// Template class for determining if dtype is an unsigned integer type
        ///

        template<typename dtype, typename Allocator>
        struct is_ndarray_signed_int<NdArray<dtype, Allocator>>
        {
            static constexpr bool value = std::is_signed_v<dtype>;
        };

        // Class Description:
        /// is_ndarray_int helper
        ///
        template<typename T>
        constexpr bool is_ndarray_signed_int_v = is_ndarray_signed_int<T>::value;

        // Class Description:
        /// is_ndarray_int
        ///
        template<typename T>
        using ndarray_int_concept = std::enable_if_t<is_ndarray_int_v<T>, int>;
    } // namespace type_traits

    // Class Description:
    /// Holds 1D and 2D arrays, the main work horse of the NumCpp library
    template<typename dtype, class Allocator = std::allocator<dtype>>
    class NdArray
    {
    private:
        STATIC_ASSERT_VALID_DTYPE(dtype);
        static_assert(std::is_same_v<dtype, typename Allocator::value_type>,
                      "value_type and Allocator::value_type must match");

        using AllocType   = typename std::allocator_traits<Allocator>::template rebind_alloc<dtype>;
        using AllocTraits = std::allocator_traits<AllocType>;

    public:
        using self_type       = NdArray<dtype, Allocator>;
        using value_type      = dtype;
        using allocator_type  = Allocator;
        using pointer         = typename AllocTraits::pointer;
        using const_pointer   = typename AllocTraits::const_pointer;
        using reference       = dtype&;
        using const_reference = const dtype&;
        using size_type       = uint32;
        using index_type      = int32;
        using difference_type = typename AllocTraits::difference_type;

        using iterator               = NdArrayIterator<dtype, pointer, difference_type>;
        using const_iterator         = NdArrayConstIterator<dtype, const_pointer, difference_type>;
        using reverse_iterator       = std::reverse_iterator<iterator>;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;

        using column_iterator         = NdArrayColumnIterator<dtype, size_type, pointer, difference_type>;
        using const_column_iterator   = NdArrayConstColumnIterator<dtype, size_type, const_pointer, difference_type>;
        using reverse_column_iterator = std::reverse_iterator<column_iterator>;
        using const_reverse_column_iterator = std::reverse_iterator<const_column_iterator>;

        // Method Description:
        /// Defualt Constructor, not very usefull...
        ///
        NdArray() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param inSquareSize: square number of rows and columns
        ///
        explicit NdArray(size_type inSquareSize) :
            shape_{ inSquareSize, inSquareSize },
            size_{ inSquareSize * inSquareSize }
        {
            newArray();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inNumRows
        /// @param inNumCols
        ///
        NdArray(size_type inNumRows, size_type inNumCols) :
            shape_{ inNumRows, inNumCols },
            size_{ inNumRows * inNumCols }
        {
            newArray();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inShape
        ///
        explicit NdArray(const Shape& inShape) :
            shape_{ inShape },
            size_{ shape_.size() }
        {
            newArray();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inList
        ///
        NdArray(std::initializer_list<dtype> inList) :
            shape_{ 1, static_cast<uint32>(inList.size()) },
            size_{ shape_.size() }
        {
            newArray();
            if (size_ > 0)
            {
                stl_algorithms::copy(inList.begin(), inList.end(), begin());
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inList: 2D initializer list
        ///
        NdArray(const std::initializer_list<std::initializer_list<dtype>>& inList) :
            shape_{ static_cast<uint32>(inList.size()), 0 }
        {
            for (const auto& list : inList)
            {
                if (shape_.cols == 0)
                {
                    shape_.cols = static_cast<uint32>(list.size());
                }
                else if (list.size() != shape_.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "All rows of the initializer list needs to have the same number of elements");
                }
            }

            size_ = shape_.size();
            newArray();
            uint32 row = 0;
            for (const auto& list : inList)
            {
                const auto ptr = begin() += row * shape_.cols;
                stl_algorithms::copy(list.begin(), list.end(), ptr);
                ++row;
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inArray
        /// @param policy: the policy to use the pointer, copy or non-owning shell. default copy
        ///
        template<size_t ArraySize, std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
        NdArray(std::array<dtype, ArraySize>& inArray, PointerPolicy policy = PointerPolicy::COPY) :
            shape_{ 1, static_cast<uint32>(ArraySize) },
            size_{ shape_.size() }
        {
            switch (policy)
            {
                case PointerPolicy::COPY:
                {
                    newArray();
                    if (size_ > 0)
                    {
                        stl_algorithms::copy(inArray.begin(), inArray.end(), begin());
                    }
                    break;
                }
                case PointerPolicy::SHELL:
                {
                    array_   = inArray.data();
                    ownsPtr_ = false;
                    break;
                }
                default:
                {
                    THROW_RUNTIME_ERROR("Unimplemented PointerPolicy type");
                }
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param in2dArray
        /// @param policy: the policy to use the pointer, copy or non-owning shell. default copy
        ///
        template<size_t Dim0Size, size_t Dim1Size>
        NdArray(std::array<std::array<dtype, Dim1Size>, Dim0Size>& in2dArray,
                PointerPolicy                                      policy = PointerPolicy::COPY) :
            shape_{ static_cast<uint32>(Dim0Size), static_cast<uint32>(Dim1Size) },
            size_{ shape_.size() }
        {
            switch (policy)
            {
                case PointerPolicy::COPY:
                {
                    newArray();
                    if (size_ > 0)
                    {
                        const auto start = in2dArray.front().begin();
                        stl_algorithms::copy(start, start + size_, begin());
                    }
                    break;
                }
                case PointerPolicy::SHELL:
                {
                    array_   = in2dArray.front().data();
                    ownsPtr_ = false;
                    break;
                }
                default:
                {
                    THROW_RUNTIME_ERROR("Unimplemented PointerPolicy type");
                }
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inVector
        /// @param policy: the policy to use the pointer, copy or non-owning shell. default copy
        ///
        template<std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
        NdArray(std::vector<dtype>& inVector, PointerPolicy policy = PointerPolicy::COPY) :
            shape_{ 1, static_cast<uint32>(inVector.size()) },
            size_{ shape_.size() }
        {
            switch (policy)
            {
                case PointerPolicy::COPY:
                {
                    newArray();
                    if (size_ > 0)
                    {
                        stl_algorithms::copy(inVector.begin(), inVector.end(), begin());
                    }
                    break;
                }
                case PointerPolicy::SHELL:
                {
                    array_   = inVector.data();
                    ownsPtr_ = false;
                    break;
                }
                default:
                {
                    THROW_RUNTIME_ERROR("Unimplemented PointerPolicy type");
                }
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param in2dVector
        ///
        explicit NdArray(const std::vector<std::vector<dtype>>& in2dVector) :
            shape_{ static_cast<uint32>(in2dVector.size()), 0 }
        {
            for (const auto& row : in2dVector)
            {
                if (shape_.cols == 0)
                {
                    shape_.cols = static_cast<uint32>(row.size());
                }
                else if (row.size() != shape_.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR("All rows of the 2d vector need to have the same number of elements");
                }
            }

            size_ = shape_.size();

            newArray();
            auto currentPosition = begin();
            for (const auto& row : in2dVector)
            {
                stl_algorithms::copy(row.begin(), row.end(), currentPosition);
                currentPosition += shape_.cols;
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param in2dArray
        /// @param policy: the policy to use the pointer, copy or non-owning shell. default copy
        ///
        template<size_t Dim1Size>
        NdArray(std::vector<std::array<dtype, Dim1Size>>& in2dArray, PointerPolicy policy = PointerPolicy::COPY) :
            shape_{ static_cast<uint32>(in2dArray.size()), static_cast<uint32>(Dim1Size) },
            size_{ shape_.size() }
        {
            switch (policy)
            {
                case PointerPolicy::COPY:
                {
                    newArray();
                    if (size_ > 0)
                    {
                        const auto start = in2dArray.front().begin();
                        stl_algorithms::copy(start, start + size_, begin());
                    }
                    break;
                }
                case PointerPolicy::SHELL:
                {
                    array_   = in2dArray.front().data();
                    ownsPtr_ = false;
                    break;
                }
                default:
                {
                    THROW_RUNTIME_ERROR("Unimplemented PointerPolicy type");
                }
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inDeque
        ///
        template<std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
        explicit NdArray(const std::deque<dtype>& inDeque) :
            shape_{ 1, static_cast<uint32>(inDeque.size()) },
            size_{ shape_.size() }
        {
            newArray();
            if (size_ > 0)
            {
                stl_algorithms::copy(inDeque.begin(), inDeque.end(), begin());
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param in2dDeque
        ///
        explicit NdArray(const std::deque<std::deque<dtype>>& in2dDeque) :
            shape_{ static_cast<uint32>(in2dDeque.size()), 0 }
        {
            for (const auto& row : in2dDeque)
            {
                if (shape_.cols == 0)
                {
                    shape_.cols = static_cast<uint32>(row.size());
                }
                else if (row.size() != shape_.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR("All rows of the 2d vector need to have the same number of elements");
                }
            }

            size_ = shape_.size();

            newArray();
            auto currentPosition = begin();
            for (const auto& row : in2dDeque)
            {
                stl_algorithms::copy(row.begin(), row.end(), currentPosition);
                currentPosition += shape_.cols;
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inList
        ///
        explicit NdArray(const std::list<dtype>& inList) :
            shape_{ 1, static_cast<uint32>(inList.size()) },
            size_{ shape_.size() }
        {
            newArray();
            if (size_ > 0)
            {
                stl_algorithms::copy(inList.begin(), inList.end(), begin());
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inFirst
        /// @param inLast
        ///
        template<typename Iterator,
                 std::enable_if_t<std::is_same_v<typename std::iterator_traits<Iterator>::value_type, dtype>, int> = 0>
        NdArray(Iterator inFirst, Iterator inLast) :
            shape_{ 1, static_cast<uint32>(std::distance(inFirst, inLast)) },
            size_{ shape_.size() }
        {
            newArray();
            if (size_ > 0)
            {
                stl_algorithms::copy(inFirst, inLast, begin());
            }
        }

        // Method Description:
        /// Constructor. Copies the contents of the buffer into the array
        ///
        /// @param inPtr: pointer to beginning of buffer
        /// @param size: number of elements in buffer
        ///
        template<typename UIntType,
                 std::enable_if_t<std::is_integral_v<UIntType> && !std::is_same_v<UIntType, bool>, int> = 0>
        NdArray(const_pointer inPtr, UIntType size) :
            NdArray(inPtr, 1, size)
        {
        }

        // Method Description:
        /// Constructor. Copies the contents of the buffer into the array
        ///
        /// @param inPtr: pointer to beginning of buffer
        /// @param numRows: number of rows of the buffer
        /// @param numCols: number of cols of the buffer
        ///
        template<typename UIntType1,
                 typename UIntType2,
                 std::enable_if_t<std::is_integral_v<UIntType1> && !std::is_same_v<UIntType1, bool>, int> = 0,
                 std::enable_if_t<std::is_integral_v<UIntType2> && !std::is_same_v<UIntType2, bool>, int> = 0>
        NdArray(const_pointer inPtr, UIntType1 numRows, UIntType2 numCols) :
            shape_(numRows, numCols),
            size_{ shape_.size() }
        {
            newArray();
            if (inPtr != nullptr && size_ > 0)
            {
                stl_algorithms::copy(inPtr, inPtr + size_, begin());
            }
        }

        // Method Description:
        /// Constructor. Copies the contents of the buffer into the array, or acts as a
        ///              non-owning shell
        ///
        /// @param inPtr: pointer to beginning of buffer
        /// @param size: number of elements in buffer
        /// @param policy: the policy to use the pointer, copy or non-owning shell. default copy
        ///
        template<typename UIntType,
                 std::enable_if_t<std::is_integral_v<UIntType> && !std::is_same_v<UIntType, bool>, int> = 0>
        NdArray(pointer inPtr, UIntType size, PointerPolicy policy) :
            NdArray(inPtr, 1, size, policy)
        {
        }

        // Method Description:
        /// Constructor. Copies the contents of the buffer into the array, or acts as a
        ///              non-owning shell
        ///
        /// @param inPtr: pointer to beginning of buffer
        /// @param numRows: number of rows of the buffer
        /// @param numCols: number of cols of the buffer
        /// @param policy: the policy to use the pointer, copy or non-owning shell
        ///
        template<typename UIntType1,
                 typename UIntType2,
                 std::enable_if_t<std::is_integral_v<UIntType1> && !std::is_same_v<UIntType1, bool>, int> = 0,
                 std::enable_if_t<std::is_integral_v<UIntType2> && !std::is_same_v<UIntType2, bool>, int> = 0>
        NdArray(pointer inPtr, UIntType1 numRows, UIntType2 numCols, PointerPolicy policy) :
            shape_(numRows, numCols),
            size_{ shape_.size() }
        {
            switch (policy)
            {
                case PointerPolicy::COPY:
                {
                    newArray();
                    if (inPtr != nullptr && size_ > 0)
                    {
                        stl_algorithms::copy(inPtr, inPtr + size_, begin());
                    }
                    break;
                }
                case PointerPolicy::SHELL:
                {
                    array_   = inPtr;
                    ownsPtr_ = false;
                    break;
                }
                default:
                {
                    THROW_RUNTIME_ERROR("Unimplemented PointerPolicy type");
                }
            }
        }

        // Method Description:
        /// Copy Constructor
        ///
        /// @param inOtherArray
        ///
        NdArray(const self_type& inOtherArray) :
            shape_{ inOtherArray.shape_ },
            size_{ inOtherArray.size_ },
            endianess_{ inOtherArray.endianess_ }
        {
            newArray();
            if (size_ > 0)
            {
                stl_algorithms::copy(inOtherArray.cbegin(), inOtherArray.cend(), begin());
            }
        }

        // Method Description:
        /// Move Constructor
        ///
        /// @param inOtherArray
        ///
        NdArray(self_type&& inOtherArray) noexcept :
            shape_{ inOtherArray.shape_ },
            size_{ inOtherArray.size_ },
            endianess_{ inOtherArray.endianess_ },
            array_{ inOtherArray.array_ },
            ownsPtr_{ inOtherArray.ownsPtr_ }
        {
            inOtherArray.shape_.rows = inOtherArray.shape_.cols = 0;
            inOtherArray.size_                                  = 0;
            inOtherArray.ownsPtr_                               = false;
            inOtherArray.array_                                 = nullptr;
        }

        // Method Description:
        /// Destructor
        ///
        ~NdArray() noexcept
        {
            deleteArray();
        }

        // Method Description:
        /// Cast to bool operator
        /// @returns bool false if empty, otherwise true
        ///
        explicit operator bool() const noexcept
        {
            return isempty();
        }

        // Method Description:
        /// Assignment operator, performs a deep copy
        ///
        /// @param rhs
        /// @return NdArray<dtype>
        ///
        self_type& operator=(const self_type& rhs)
        {
            if (&rhs != this)
            {
                if (rhs.size_ > 0)
                {
                    newArray(rhs.shape_);
                    endianess_ = rhs.endianess_;

                    stl_algorithms::copy(rhs.cbegin(), rhs.cend(), begin());
                }
            }

            return *this;
        }

        // Method Description:
        /// Assignment operator, sets the entire array to a single
        /// scalar value.
        ///
        /// @param inValue
        /// @return NdArray<dtype>
        ///
        self_type& operator=(value_type inValue) noexcept
        {
            if (array_ != nullptr)
            {
                stl_algorithms::fill(begin(), end(), inValue);
            }

            return *this;
        }

        // Method Description:
        /// Move operator, performs a deep move
        ///
        /// @param rhs
        /// @return NdArray<dtype>
        ///
        self_type& operator=(self_type&& rhs) noexcept
        {
            if (&rhs != this)
            {
                deleteArray();
                shape_     = rhs.shape_;
                size_      = rhs.size_;
                endianess_ = rhs.endianess_;
                array_     = rhs.array_;
                ownsPtr_   = rhs.ownsPtr_;

                rhs.shape_.rows = rhs.shape_.cols = rhs.size_ = 0;
                rhs.array_                                    = nullptr;
                rhs.ownsPtr_                                  = false;
            }

            return *this;
        }

        // Method Description:
        /// 1D access operator with no bounds checking
        ///
        /// @param inIndex
        /// @return value
        ///
        reference operator[](index_type inIndex) noexcept
        {
            return const_cast<reference>(const_cast<const self_type*>(this)->operator[](inIndex));
        }

        // Method Description:
        /// const 1D access operator with no bounds checking
        ///
        /// @param inIndex
        /// @return value
        ///
        [[nodiscard]] const_reference operator[](index_type inIndex) const noexcept
        {
            if (inIndex < 0)
            {
                inIndex += size_;
            }

            return array_[inIndex];
        }

        // Method Description:
        /// 2D access operator with no bounds checking
        ///
        /// @param inRowIndex
        /// @param inColIndex
        /// @return value
        ///
        reference operator()(index_type inRowIndex, index_type inColIndex) noexcept
        {
            return const_cast<reference>(const_cast<const self_type*>(this)->operator()(inRowIndex, inColIndex));
        }

        // Method Description:
        /// const 2D access operator with no bounds checking
        ///
        /// @param inRowIndex
        /// @param inColIndex
        /// @return value
        ///
        [[nodiscard]] const_reference operator()(index_type inRowIndex, index_type inColIndex) const noexcept
        {
            if (inRowIndex < 0)
            {
                inRowIndex += shape_.rows;
            }

            if (inColIndex < 0)
            {
                inColIndex += shape_.cols;
            }

            return array_[inRowIndex * shape_.cols + inColIndex];
        }

        // Method Description:
        /// 1D Slicing access operator with no bounds checking
        /// returned array is of the range [start, stop).
        ///
        /// @param inSlice
        /// @return NdArray
        ///
        [[nodiscard]] self_type operator[](Slice inSlice) const
        {
            return operator[](toIndices(inSlice, Axis::NONE));
        }

        // Method Description:
        /// Returns the values from the input mask with no bounds checking
        ///
        /// @param inMask
        /// @return NdArray
        ///
        [[nodiscard]] self_type operator[](const NdArray<bool>& inMask) const
        {
            return operator[](inMask.flatnonzero());
        }

        // Method Description:
        /// Returns the values from the input indices with no bounds checking
        ///
        /// @param inIndices
        /// @return NdArray
        ///
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type operator[](const Indices& inIndices) const
        {
            auto      outArray = self_type(1, static_cast<size_type>(inIndices.size()));
            size_type i        = 0;
            for (auto& index : inIndices)
            {
                outArray[i++] = operator[](static_cast<index_type>(index));
            }

            return outArray;
        }

        // Method Description:
        /// 2D Slicing access operator with no bounds checking
        /// returned array is of the range [start, stop).
        ///
        /// @param inRowSlice
        /// @param inColSlice
        /// @return NdArray
        ///
        [[nodiscard]] self_type operator()(Slice inRowSlice, Slice inColSlice) const
        {
            return operator()(toIndices(inRowSlice, Axis::ROW), toIndices(inColSlice, Axis::COL));
        }

        // Method Description:
        /// 2D Slicing access operator with no bounds checking
        /// returned array is of the range [start, stop).
        ///
        /// @param inRowSlice
        /// @param inColIndex
        /// @return NdArray
        ///
        [[nodiscard]] self_type operator()(Slice inRowSlice, index_type inColIndex) const
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return operator()(toIndices(inRowSlice, Axis::ROW), colIndices);
        }

        // Method Description:
        /// 2D Slicing access operator with no bounds checking
        /// returned array is of the range [start, stop).
        ///
        /// @param inRowIndex
        /// @param inColSlice
        /// @return NdArray
        ///
        [[nodiscard]] self_type operator()(index_type inRowIndex, Slice inColSlice) const
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return operator()(rowIndices, toIndices(inColSlice, Axis::COL));
        }

        // Method Description:
        /// 2D index access operator with no bounds checking
        /// returned array is of the range.
        ///
        /// @param rowIndices
        /// @param colIndex
        /// @return NdArray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type operator()(const Indices& rowIndices, index_type colIndex) const
        {
            const NdArray<index_type> colIndices = { colIndex };
            return operator()(rowIndices, colIndices);
        }

        // Method Description:
        /// 2D index access operator with no bounds checking
        /// returned array is of the range.
        ///
        /// @param rowIndices
        /// @param colSlice
        /// @return NdArray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type operator()(const Indices& rowIndices, Slice colSlice) const
        {
            return operator()(rowIndices, toIndices(colSlice, Axis::COL));
        }

        // Method Description:
        /// 2D index access operator with no bounds checking
        /// returned array is of the range.
        ///
        /// @param rowIndex
        /// @param colIndices
        /// @return NdArray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type operator()(index_type rowIndex, const Indices& colIndices) const
        {
            const NdArray<index_type> rowIndices = { rowIndex };
            return operator()(rowIndices, colIndices);
        }

        // Method Description:
        /// 2D index access operator with no bounds checking
        /// returned array is of the range.
        ///
        /// @param rowSlice
        /// @param colIndices
        /// @return NdArray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type operator()(Slice rowSlice, const Indices& colIndices) const
        {
            return operator()(toIndices(rowSlice, Axis::ROW), colIndices);
        }

        // Method Description:
        /// 2D index access operator with no bounds checking
        /// returned array is of the range.
        ///
        /// @param rowIndices
        /// @param colIndices
        /// @return NdArray
        ///
        template<typename RowIndices,
                 typename ColIndices,
                 type_traits::ndarray_int_concept<RowIndices> = 0,
                 type_traits::ndarray_int_concept<ColIndices> = 0>
        [[nodiscard]] self_type operator()(const RowIndices& rowIndices, const ColIndices& colIndices) const
        {
            self_type returnArray(rowIndices.size(), colIndices.size());

            size_type rowCounter = 0;
            for (auto rowIter = rowIndices.begin(); rowIter != rowIndices.end(); ++rowIter)
            {
                size_type colCounter = 0;
                for (auto colIter = colIndices.begin(); colIter != colIndices.end(); ++colIter)
                {
                    returnArray(rowCounter, colCounter++) = operator()(*rowIter, *colIter);
                }

                ++rowCounter;
            }

            return returnArray;
        }

        // Method Description:
        /// Returns a Slice object for slicing a row to the end of
        /// array.
        ///
        /// @param inStartIdx (default 0)
        /// @param inStepSize (default 1)
        /// @return Slice
        ///
        [[nodiscard]] Slice cSlice(index_type inStartIdx = 0, size_type inStepSize = 1) const
        {
            return Slice(inStartIdx, shape_.cols, inStepSize); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns a Slice object for slicing a column to the end
        /// of the array.
        ///
        /// @param inStartIdx (default 0)
        /// @param inStepSize (default 1)
        /// @return Slice
        ///
        [[nodiscard]] Slice rSlice(index_type inStartIdx = 0, size_type inStepSize = 1) const
        {
            return Slice(inStartIdx, shape_.rows, inStepSize); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// 1D access method with bounds checking
        ///
        /// @param inIndex
        /// @return value
        ///
        reference at(index_type inIndex)
        {
            return const_cast<reference>(const_cast<const self_type*>(this)->at(inIndex));
        }

        // Method Description:
        /// const 1D access method with bounds checking
        ///
        /// @param inIndex
        /// @return value
        ///
        [[nodiscard]] const_reference at(index_type inIndex) const
        {
            // this doesn't allow for calling the first element as -size_...
            // but why would you really want to do that anyway?
            if (std::abs(inIndex) > static_cast<int64>(size_ - 1))
            {
                std::string errStr = "Input index " + utils::num2str(inIndex);
                errStr += " is out of bounds for array of size " + utils::num2str(size_) + ".";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            return operator[](inIndex); // cppcheck-suppress returnTempReference
        }

        // Method Description:
        /// 2D access method with bounds checking
        ///
        /// @param inRowIndex
        /// @param inColIndex
        /// @return value
        ///
        reference at(index_type inRowIndex, index_type inColIndex)
        {
            return const_cast<reference>(const_cast<const self_type*>(this)->at(inRowIndex, inColIndex));
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param inRowIndex
        /// @param inColIndex
        /// @return value
        ///
        [[nodiscard]] const_reference at(index_type inRowIndex, index_type inColIndex) const
        {
            // this doesn't allow for calling the first element as -size_...
            // but why would you really want to do that anyway?
            if (std::abs(inRowIndex) > static_cast<index_type>(shape_.rows - 1))
            {
                std::string errStr = "Row index " + utils::num2str(inRowIndex);
                errStr += " is out of bounds for array of size " + utils::num2str(shape_.rows) + ".";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            // this doesn't allow for calling the first element as -size_...
            // but why would you really want to do that anyway?
            if (std::abs(inColIndex) > static_cast<index_type>(shape_.cols - 1))
            {
                std::string errStr = "Column index " + utils::num2str(inColIndex);
                errStr += " is out of bounds for array of size " + utils::num2str(shape_.cols) + ".";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            return operator()(inRowIndex, inColIndex); // cppcheck-suppress returnTempReference
        }

        // Method Description:
        /// const 1D access method with bounds checking
        ///
        /// @param inSlice
        /// @return Ndarray
        ///
        [[nodiscard]] self_type at(const Slice& inSlice) const
        {
            return at(toIndices(inSlice, Axis::NONE));
        }

        // Method Description:
        /// const 1D access method with bounds checking
        ///
        /// @param inMask
        /// @return Ndarray
        ///
        [[nodiscard]] self_type at(const NdArray<bool>& inMask) const
        {
            if (inMask.shape() != shape_)
            {
                THROW_INVALID_ARGUMENT_ERROR("Input mask must have the same dimensions as array.");
            }

            return operator[](inMask);
        }

        // Method Description:
        /// const 1D access method with bounds checking
        ///
        /// @param inIndices
        /// @return Ndarray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type at(const Indices& inIndices) const
        {
            stl_algorithms::for_each(inIndices.begin(),
                                     inIndices.end(),
                                     [this](auto index)
                                     {
                                         auto indexSigned = static_cast<index_type>(index);
                                         if (indexSigned < 0)
                                         {
                                             indexSigned += size_;
                                         }

                                         if (indexSigned < 0 || indexSigned > static_cast<index_type>(size_ - 1))
                                         {
                                             THROW_INVALID_ARGUMENT_ERROR("Index exceeds matrix dimensions");
                                         }
                                     });

            return operator[](inIndices);
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param inRowSlice
        /// @param inColSlice
        /// @return Ndarray
        ///
        [[nodiscard]] self_type at(const Slice& inRowSlice, const Slice& inColSlice) const
        {
            return at(toIndices(inRowSlice, Axis::ROW), toIndices(inColSlice, Axis::COL));
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param inRowSlice
        /// @param inColIndex
        /// @return Ndarray
        ///
        [[nodiscard]] self_type at(const Slice& inRowSlice, index_type inColIndex) const
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return at(toIndices(inRowSlice, Axis::ROW), colIndices);
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param inRowIndex
        /// @param inColSlice
        /// @return Ndarray
        ///
        [[nodiscard]] self_type at(index_type inRowIndex, const Slice& inColSlice) const
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return at(rowIndices, toIndices(inColSlice, Axis::COL));
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param rowIndices
        /// @param colIndex
        /// @return Ndarray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type at(const Indices& rowIndices, index_type colIndex) const
        {
            const NdArray<index_type> colIndices = { colIndex };
            return at(rowIndices, colIndices);
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param rowIndices
        /// @param colSlice
        /// @return Ndarray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type at(const Indices& rowIndices, Slice colSlice) const
        {
            return at(rowIndices, toIndices(colSlice, Axis::COL));
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param rowIndex
        /// @param colIndices
        /// @return Ndarray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type at(index_type rowIndex, const Indices& colIndices) const
        {
            const NdArray<index_type> rowIndices = { rowIndex };
            return at(rowIndices, colIndices);
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param rowSlice
        /// @param colIndices
        /// @return Ndarray
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        [[nodiscard]] self_type at(Slice rowSlice, const Indices& colIndices) const
        {
            return at(toIndices(rowSlice, Axis::ROW), colIndices);
        }

        // Method Description:
        /// const 2D access method with bounds checking
        ///
        /// @param rowIndices
        /// @param colIndices
        /// @return Ndarray
        ///
        template<typename RowIndices,
                 typename ColIndices,
                 type_traits::ndarray_int_concept<RowIndices> = 0,
                 type_traits::ndarray_int_concept<ColIndices> = 0>
        [[nodiscard]] self_type at(const RowIndices& rowIndices, const ColIndices& colIndices) const
        {
            stl_algorithms::for_each(rowIndices.begin(),
                                     rowIndices.end(),
                                     [this](auto row)
                                     {
                                         auto rowSigned = static_cast<index_type>(row);
                                         if (rowSigned < 0)
                                         {
                                             rowSigned += shape_.rows;
                                         }

                                         if (rowSigned < 0 || rowSigned > static_cast<index_type>(shape_.rows - 1))
                                         {
                                             THROW_INVALID_ARGUMENT_ERROR("Row index exceeds matrix dimensions");
                                         }
                                     });

            stl_algorithms::for_each(colIndices.begin(),
                                     colIndices.end(),
                                     [this](auto col)
                                     {
                                         auto colSigned = static_cast<index_type>(col);
                                         if (colSigned < 0)
                                         {
                                             colSigned += shape_.cols;
                                         }

                                         if (colSigned < 0 || colSigned > static_cast<index_type>(shape_.cols - 1))
                                         {
                                             THROW_INVALID_ARGUMENT_ERROR("Column index exceeds matrix dimensions");
                                         }
                                     });

            return operator()(rowIndices, colIndices);
        }

        // Method Description:
        /// iterator to the beginning of the flattened array
        /// @return iterator
        ///
        [[nodiscard]] iterator begin() noexcept
        {
            return iterator(array_);
        }

        // Method Description:
        /// iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return iterator
        ///
        [[nodiscard]] iterator begin(size_type inRow)
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return begin() += (inRow * shape_.cols);
        }

        // Method Description:
        /// const iterator to the beginning of the flattened array
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator begin() const noexcept
        {
            return cbegin();
        }

        // Method Description:
        /// const iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator begin(size_type inRow) const
        {
            return cbegin(inRow);
        }

        // Method Description:
        /// const iterator to the beginning of the flattened array
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cbegin() const noexcept
        {
            return const_iterator(array_);
        }

        // Method Description:
        /// const iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cbegin(size_type inRow) const
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return cbegin() += (inRow * shape_.cols);
        }

        // Method Description:
        /// column_iterator to the beginning of the flattened array
        /// @return column_iterator
        ///
        [[nodiscard]] column_iterator colbegin() noexcept
        {
            return column_iterator(array_, shape_.rows, shape_.cols);
        }

        // Method Description:
        /// column_iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return column_iterator
        ///
        [[nodiscard]] column_iterator colbegin(size_type inCol)
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return colbegin() += (inCol * shape_.rows);
        }

        // Method Description:
        /// const column_iterator to the beginning of the flattened array
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator colbegin() const noexcept
        {
            return ccolbegin();
        }

        // Method Description:
        /// const column_iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator colbegin(size_type inCol) const
        {
            return ccolbegin(inCol);
        }

        // Method Description:
        /// const_column_iterator to the beginning of the flattened array
        ///
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator ccolbegin() const noexcept
        {
            return const_column_iterator(array_, shape_.rows, shape_.cols);
        }

        // Method Description:
        /// const_column_iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator ccolbegin(size_type inCol) const
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return ccolbegin() += (inCol * shape_.rows);
        }

        // Method Description:
        /// reverse_iterator to the beginning of the flattened array
        /// @return reverse_iterator
        ///
        [[nodiscard]] reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(end());
        }

        // Method Description:
        /// reverse_iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return reverse_iterator
        ///
        [[nodiscard]] reverse_iterator rbegin(size_type inRow)
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return rbegin() += (shape_.rows - inRow - 1) * shape_.cols;
        }

        // Method Description:
        /// const iterator to the beginning of the flattened array
        /// @return const_iterator
        ///
        [[nodiscard]] const_reverse_iterator rbegin() const noexcept
        {
            return crbegin();
        }

        // Method Description:
        /// const iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return const_iterator
        ///
        [[nodiscard]] const_reverse_iterator rbegin(size_type inRow) const
        {
            return crbegin(inRow);
        }

        // Method Description:
        /// const_reverse_iterator to the beginning of the flattened array
        ///
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator crbegin() const noexcept
        {
            return const_reverse_iterator(cend());
        }

        // Method Description:
        /// const_reverse_iterator to the beginning of the input row
        ///
        /// @param inRow
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator crbegin(size_type inRow) const
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return crbegin() += (shape_.rows - inRow - 1) * shape_.cols;
        }

        // Method Description:
        /// reverse_column_iterator to the beginning of the flattened array
        /// @return reverse_column_iterator
        ///
        [[nodiscard]] reverse_column_iterator rcolbegin() noexcept
        {
            return reverse_column_iterator(colend());
        }

        // Method Description:
        /// reverse_column_iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return reverse_column_iterator
        ///
        [[nodiscard]] reverse_column_iterator rcolbegin(size_type inCol)
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return rcolbegin() += (shape_.cols - inCol - 1) * shape_.rows;
        }

        // Method Description:
        /// const iterator to the beginning of the flattened array
        /// @return const_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator rcolbegin() const noexcept
        {
            return crcolbegin();
        }

        // Method Description:
        /// const iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return const_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator rcolbegin(size_type inCol) const
        {
            return crcolbegin(inCol);
        }

        // Method Description:
        /// const_reverse_column_iterator to the beginning of the flattened array
        ///
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator crcolbegin() const noexcept
        {
            return const_reverse_column_iterator(ccolend());
        }

        // Method Description:
        /// const_reverse_column_iterator to the beginning of the input column
        ///
        /// @param inCol
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator crcolbegin(size_type inCol) const
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return crcolbegin() += (shape_.cols - inCol - 1) * shape_.rows;
        }

        // Method Description:
        /// iterator to 1 past the end of the flattened array
        /// @return iterator
        ///
        [[nodiscard]] iterator end() noexcept
        {
            return begin() += size_;
        }

        // Method Description:
        /// iterator to the 1 past end of the row
        ///
        /// @param inRow
        /// @return iterator
        ///
        [[nodiscard]] iterator end(size_type inRow)
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return begin(inRow) += shape_.cols;
        }

        // Method Description:
        /// const iterator to 1 past the end of the flattened array
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator end() const noexcept
        {
            return cend();
        }

        // Method Description:
        /// const iterator to the 1 past end of the row
        ///
        /// @param inRow
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator end(size_type inRow) const
        {
            return cend(inRow);
        }

        // Method Description:
        /// const iterator to 1 past the end of the flattened array
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cend() const noexcept
        {
            return cbegin() += size_;
        }

        // Method Description:
        /// const iterator to 1 past the end of the input row
        ///
        /// @param inRow
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cend(size_type inRow) const
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return cbegin(inRow) += shape_.cols;
        }

        // Method Description:
        /// reverse_iterator to 1 past the end of the flattened array
        /// @return reverse_iterator
        ///
        [[nodiscard]] reverse_iterator rend() noexcept
        {
            return rbegin() += size_;
        }

        // Method Description:
        /// reverse_iterator to the 1 past end of the row
        ///
        /// @param inRow
        /// @return reverse_iterator
        ///
        [[nodiscard]] reverse_iterator rend(size_type inRow)
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return rbegin(inRow) += shape_.cols;
        }

        // Method Description:
        /// const_reverse_iterator to 1 past the end of the flattened array
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator rend() const noexcept
        {
            return crend();
        }

        // Method Description:
        /// const_reverse_iterator to the 1 past end of the row
        ///
        /// @param inRow
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator rend(size_type inRow) const
        {
            return crend(inRow);
        }

        // Method Description:
        /// const_reverse_iterator to 1 past the end of the flattened array
        ///
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator crend() const noexcept
        {
            return crbegin() += size_;
        }

        // Method Description:
        /// const_reverse_iterator to 1 past the end of the input row
        ///
        /// @param inRow
        /// @return const_reverse_iterator
        ///
        [[nodiscard]] const_reverse_iterator crend(size_type inRow) const
        {
            if (inRow >= shape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("input row is greater than the number of rows in the array.");
            }

            return crbegin(inRow) += shape_.cols;
        }

        // Method Description:
        /// column_iterator to 1 past the end of the flattened array
        /// @return column_iterator
        ///
        [[nodiscard]] column_iterator colend() noexcept
        {
            return colbegin() += size_;
        }

        // Method Description:
        /// column_iterator to the 1 past end of the column
        ///
        /// @param inCol
        /// @return column_iterator
        ///
        [[nodiscard]] column_iterator colend(size_type inCol)
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return colbegin(inCol) += shape_.rows;
        }

        // Method Description:
        /// const column_iterator to 1 past the end of the flattened array
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator colend() const noexcept
        {
            return ccolend();
        }

        // Method Description:
        /// const column_iterator to the 1 past end of the column
        ///
        /// @param inCol
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator colend(size_type inCol) const
        {
            return ccolend(inCol);
        }

        // Method Description:
        /// const_column_iterator to 1 past the end of the flattened array
        ///
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator ccolend() const noexcept
        {
            return ccolbegin() += size_;
        }

        // Method Description:
        /// const_column_iterator to 1 past the end of the input col
        ///
        /// @param inCol
        /// @return const_column_iterator
        ///
        [[nodiscard]] const_column_iterator ccolend(size_type inCol) const
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return ccolbegin(inCol) += shape_.rows;
        }

        // Method Description:
        /// reverse_column_iterator to 1 past the end of the flattened array
        /// @return reverse_column_iterator
        ///
        [[nodiscard]] reverse_column_iterator rcolend() noexcept
        {
            return rcolbegin() += size_;
        }

        // Method Description:
        /// reverse_column_iterator to the 1 past end of the column
        ///
        /// @param inCol
        /// @return reverse_column_iterator
        ///
        [[nodiscard]] reverse_column_iterator rcolend(size_type inCol)
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return rcolbegin(inCol) += shape_.rows;
        }

        // Method Description:
        /// const_reverse_column_iterator to 1 past the end of the flattened array
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator rcolend() const noexcept
        {
            return crcolend();
        }

        // Method Description:
        /// const_reverse_column_iterator to the 1 past end of the column
        ///
        /// @param inCol
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator rcolend(size_type inCol) const
        {
            return crcolend(inCol);
        }

        // Method Description:
        /// const_reverse_column_iterator to 1 past the end of the flattened array
        ///
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator crcolend() const noexcept
        {
            return crcolbegin() += size_;
        }

        // Method Description:
        /// const_reverse_column_iterator to 1 past the end of the input col
        ///
        /// @param inCol
        /// @return const_reverse_column_iterator
        ///
        [[nodiscard]] const_reverse_column_iterator crcolend(size_type inCol) const
        {
            if (inCol >= shape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("input col is greater than the number of cols in the array.");
            }

            return crcolbegin(inCol) += shape_.rows;
        }

        // Method Description:
        /// Returns True if all elements evaluate to True or non zero
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.all.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<bool> all(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto function = [](dtype i) -> bool { return !utils::essentiallyEqual(i, dtype{ 0 }); };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<bool> returnArray = { stl_algorithms::all_of(cbegin(), cend(), function) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<bool> returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = stl_algorithms::all_of(cbegin(row), cend(row), function);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().all(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Returns True if any elements evaluate to True or non zero
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.any.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<bool> any(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto function = [](dtype i) -> bool { return !utils::essentiallyEqual(i, dtype{ 0 }); };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<bool> returnArray = { stl_algorithms::any_of(cbegin(), cend(), function) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<bool> returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = stl_algorithms::any_of(cbegin(row), cend(row), function);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().any(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return indices of the maximum values along the given axis.
        /// Only the first index is returned.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.argmax.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<size_type> argmax(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<size_type> returnArray = { static_cast<size_type>(
                        stl_algorithms::max_element(cbegin(), cend(), comparitor) - cbegin()) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<size_type> returnArray(1, shape_.rows);
                    for (size_type row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = static_cast<size_type>(
                            stl_algorithms::max_element(cbegin(row), cend(row), comparitor) - cbegin(row));
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().argmax(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return indices of the minimum values along the given axis.
        /// Only the first index is returned.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.argmin.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<size_type> argmin(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<size_type> returnArray = { static_cast<size_type>(
                        stl_algorithms::min_element(cbegin(), cend(), comparitor) - cbegin()) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<size_type> returnArray(1, shape_.rows);
                    for (size_type row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = static_cast<size_type>(
                            stl_algorithms::min_element(cbegin(row), cend(row), comparitor) - cbegin(row));
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().argmin(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Returns the indices that would sort this array.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.argsort.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<size_type> argsort(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    std::vector<size_type> idx(size_);
                    std::iota(idx.begin(), idx.end(), 0);

                    const auto function = [this](size_type i1, size_type i2) noexcept -> bool
                    { return (*this)[i1] < (*this)[i2]; };

                    stl_algorithms::stable_sort(idx.begin(), idx.end(), function);
                    return NdArray<size_type>(idx); // NOLINT(modernize-return-braced-init-list)
                }
                case Axis::COL:
                {
                    NdArray<size_type>     returnArray(shape_);
                    std::vector<size_type> idx(shape_.cols);

                    for (index_type row = 0; row < static_cast<index_type>(shape_.rows); ++row)
                    {
                        std::iota(idx.begin(), idx.end(), 0);

                        const auto function = [this, row](size_type i1, size_type i2) noexcept -> bool
                        { return operator()(row, i1) < operator()(row, i2); };

                        stl_algorithms::stable_sort(idx.begin(), idx.end(), function);

                        for (index_type col = 0; col < static_cast<index_type>(shape_.cols); ++col)
                        {
                            returnArray(row, col) = idx[static_cast<size_type>(col)];
                        }
                    }
                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().argsort(Axis::COL).transpose();
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Returns a copy of the array, cast to a specified type.
        /// Arithmetic to Arithmetic
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html
        ///
        /// @return NdArray
        ///
        template<typename dtypeOut,
                 typename dtype_                                       = dtype,
                 std::enable_if_t<std::is_same_v<dtype_, dtype>, int>  = 0,
                 std::enable_if_t<std::is_arithmetic_v<dtype_>, int>   = 0,
                 std::enable_if_t<std::is_arithmetic_v<dtypeOut>, int> = 0>
        [[nodiscard]] NdArray<dtypeOut> astype() const
        {
            if constexpr (std::is_same_v<dtypeOut, dtype>)
            {
                return *this;
            }
            else
            {
                NdArray<dtypeOut> outArray(shape_);
                stl_algorithms::transform(cbegin(),
                                          cend(),
                                          outArray.begin(),
                                          [](dtype value) -> dtypeOut { return static_cast<dtypeOut>(value); });

                return outArray;
            }
        }

        // Method Description:
        /// Returns a copy of the array, cast to a specified type.
        /// Arithmetic to Complex
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html
        ///
        /// @return NdArray
        ///
        template<typename dtypeOut,
                 typename dtype_                                      = dtype,
                 std::enable_if_t<std::is_same_v<dtype_, dtype>, int> = 0,
                 std::enable_if_t<std::is_arithmetic_v<dtype_>, int>  = 0,
                 std::enable_if_t<is_complex_v<dtypeOut>, int>        = 0>
        [[nodiscard]] NdArray<dtypeOut> astype() const
        {
            NdArray<dtypeOut> outArray(shape_);

            const auto function = [](const_reference value) -> dtypeOut
            { return std::complex<typename dtypeOut::value_type>(value); };

            stl_algorithms::transform(cbegin(), cend(), outArray.begin(), function);

            return outArray;
        }

        // Method Description:
        /// Returns a copy of the array, cast to a specified type.
        /// Complex to Complex
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html
        ///
        /// @return NdArray
        ///
        template<typename dtypeOut,
                 typename dtype_                                      = dtype,
                 std::enable_if_t<std::is_same_v<dtype_, dtype>, int> = 0,
                 std::enable_if_t<is_complex_v<dtype_>, int>          = 0,
                 std::enable_if_t<is_complex_v<dtypeOut>, int>        = 0>
        [[nodiscard]] NdArray<dtypeOut> astype() const
        {
            if constexpr (std::is_same_v<dtypeOut, dtype>)
            {
                return *this;
            }
            else
            {
                const auto function = [](const_reference value) noexcept -> dtypeOut
                { return complex_cast<typename dtypeOut::value_type>(value); };

                NdArray<dtypeOut> outArray(shape_);
                stl_algorithms::transform(cbegin(), cend(), outArray.begin(), function);
                return outArray;
            }
        }

        // Method Description:
        /// Returns a copy of the array, cast to a specified type.
        /// Complex to Arithmetic
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html
        ///
        /// @return NdArray
        ///
        template<typename dtypeOut,
                 typename dtype_                                       = dtype,
                 std::enable_if_t<std::is_same_v<dtype_, dtype>, int>  = 0,
                 std::enable_if_t<is_complex_v<dtype_>, int>           = 0,
                 std::enable_if_t<std::is_arithmetic_v<dtypeOut>, int> = 0>
        [[nodiscard]] NdArray<dtypeOut> astype() const
        {
            NdArray<dtypeOut> outArray(shape_);

            const auto function = [](const_reference value) -> dtypeOut { return static_cast<dtypeOut>(value.real()); };

            stl_algorithms::transform(cbegin(), cend(), outArray.begin(), function);

            return outArray;
        }

        // Method Description:
        /// Returns a copy of the last element of the flattened array.
        ///
        /// @return dtype
        ///
        [[nodiscard]] const_reference back() const noexcept
        {
            return *(cend() - 1);
        }

        // Method Description:
        /// Returns a reference the last element of the flattened array.
        ///
        /// @return dtype
        ///
        reference back() noexcept
        {
            return *(end() - 1);
        }

        // Method Description:
        /// Returns a copy of the last element of the input row.
        ///
        /// @return dtype
        ///
        [[nodiscard]] const_reference back(size_type row) const
        {
            return *(cend(row) - 1);
        }

        // Method Description:
        /// Returns a reference the last element of the input row.
        ///
        /// @return dtype
        ///
        reference back(size_type row)
        {
            return *(end(row) - 1);
        }

        // Method Description:
        /// Swap the bytes of the array elements in place
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.byteswap.html
        ///
        /// @return NdArray
        ///
        self_type& byteswap() noexcept
        {
            STATIC_ASSERT_INTEGER(dtype);

            stl_algorithms::for_each(begin(),
                                     end(),
                                     [](dtype& value) noexcept -> void { value = endian::byteSwap(value); });

            switch (endianess_)
            {
                case Endian::NATIVE:
                {
                    endianess_ = endian::isLittleEndian() ? Endian::BIG : Endian::LITTLE;
                    break;
                }
                case Endian::LITTLE:
                {
                    endianess_ = Endian::BIG;
                    break;
                }
                case Endian::BIG:
                {
                    endianess_ = Endian::LITTLE;
                    break;
                }
            }

            return *this;
        }

        // Method Description:
        /// Returns an array whose values are limited to [min, max].
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.clip.html
        ///
        /// @param inMin: min value to clip to
        /// @param inMax: max value to clip to
        /// @return clipped value
        ///
        [[nodiscard]] self_type clip(value_type inMin, value_type inMax) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            self_type outArray(shape_);
            stl_algorithms::transform(cbegin(),
                                      cend(),
                                      outArray.begin(),
                                      [inMin, inMax](dtype value) noexcept -> dtype
                                      {
#ifdef __cpp_lib_clamp
                                          const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool
                                          { return lhs < rhs; };

                                          return std::clamp(value, inMin, inMax, comparitor);
#else
                    if (value < inMin)
                    {
                        return inMin;
                    }
                    else if (value > inMax)
                    {
                        return inMax;
                    }

                    return value;
#endif
                                      });

            return outArray;
        }

        // Method Description:
        /// Returns the full column of the array
        ///
        /// @param inColumn: the column index
        /// @return self_type
        ///
        [[nodiscard]] self_type column(size_type inColumn) const
        {
            return operator()(rSlice(), inColumn);
        }

        // Method Description:
        /// Returns the full column of the array
        ///
        /// @param inCols: the column indices
        /// @return self_type
        ///
        [[nodiscard]] self_type columns(const NdArray<size_type>& inCols) const
        {
            auto       returnArray = self_type(shape_.rows, inCols.size());
            const auto rSlice      = returnArray.rSlice();

            for (size_type i = 0; i < inCols.size(); ++i)
            {
                returnArray.put(rSlice, i, column(inCols[i]));
            }

            return returnArray;
        }

        // Method Description:
        /// returns whether or not a value is included the array
        ///
        /// @param inValue
        /// @param inAxis (Optional, default NONE)
        /// @return bool
        ///
        [[nodiscard]] NdArray<bool> contains(value_type inValue, Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<bool> returnArray = { stl_algorithms::find(cbegin(), cend(), inValue) != cend() };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<bool> returnArray(1, shape_.rows);
                    for (size_type row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = stl_algorithms::find(cbegin(row), cend(row), inValue) != cend(row);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().contains(inValue, Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return a copy of the array
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.copy.html
        ///
        /// @return NdArray
        ///
        [[nodiscard]] self_type copy() const
        {
            return self_type(*this);
        }

        // Method Description:
        /// Return the cumulative product of the elements along the given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.cumprod.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type cumprod(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type returnArray(1, size_);
                    returnArray[0] = front();
                    for (size_type i = 1; i < size_; ++i)
                    {
                        returnArray[i] = returnArray[i - 1] * array_[i];
                    }

                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(shape_);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(row, 0) = operator()(row, 0);
                        for (uint32 col = 1; col < shape_.cols; ++col)
                        {
                            returnArray(row, col) = returnArray(row, col - 1) * operator()(row, col);
                        }
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().cumprod(Axis::COL).transpose();
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return the cumulative sum of the elements along the given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.cumsum.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type cumsum(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type returnArray(1, size_);
                    returnArray[0] = front();
                    for (size_type i = 1; i < size_; ++i)
                    {
                        returnArray[i] = returnArray[i - 1] + array_[i];
                    }

                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(shape_);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(row, 0) = operator()(row, 0);
                        for (uint32 col = 1; col < shape_.cols; ++col)
                        {
                            returnArray(row, col) = returnArray(row, col - 1) + operator()(row, col);
                        }
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().cumsum(Axis::COL).transpose();
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Returns the raw pointer to the underlying data
        /// @return pointer
        ///
        [[nodiscard]] pointer data() noexcept
        {
            return array_;
        }

        // Method Description:
        /// Returns the raw pointer to the underlying data
        /// @return const_pointer
        ///
        [[nodiscard]] const_pointer data() const noexcept
        {
            return array_;
        }

        // Method Description:
        /// Releases the internal data pointer so that the destructor
        /// will not call delete on it, and returns the raw pointer
        /// to the underlying data.
        /// @return pointer
        ///
        [[nodiscard]] pointer dataRelease() noexcept
        {
            ownsPtr_ = false;
            return data();
        }

        // Method Description:
        /// Return specified diagonals.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.diagonal.html
        ///
        /// @param inOffset: Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults
        /// to 0.
        /// @param inAxis: (Optional, default ROW) axis the offset is applied to
        /// @return NdArray
        ///
        [[nodiscard]] self_type diagonal(index_type inOffset = 0, Axis inAxis = Axis::ROW) const
        {
            switch (inAxis)
            {
                case Axis::COL:
                {
                    std::vector<dtype> diagnolValues;
                    size_type          col = 0;
                    for (index_type row = inOffset; row < static_cast<index_type>(shape_.rows); ++row)
                    {
                        if (row < 0)
                        {
                            ++col;
                            continue;
                        }
                        if (col >= shape_.cols)
                        {
                            break;
                        }

                        diagnolValues.push_back(operator()(static_cast<size_type>(row), col));
                        ++col;
                    }

                    return self_type(diagnolValues);
                }
                case Axis::ROW:
                {
                    return transpose().diagonal(inOffset, Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return size of the axis dimension
        ///
        /// @param inAxis: the array axis
        /// @return size of the dimension
        ///
        [[nodiscard]] size_type dimSize(Axis inAxis) const noexcept
        {
            switch (inAxis)
            {
                case Axis::NONE:
                {
                    return size();
                }
                case Axis::ROW:
                {
                    return numRows();
                }
                case Axis::COL:
                {
                    return numCols();
                }
                default:
                {
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Dot product of two arrays.
        ///
        /// For 2-D arrays it is equivalent to matrix multiplication,
        /// and for 1-D arrays to inner product of vectors.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.dot.html
        ///
        /// @param inOtherArray
        /// @return dot product
        ///
        [[nodiscard]] self_type dot(const self_type& inOtherArray) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            if (shape_ == inOtherArray.shape_ && (shape_.rows == 1 || shape_.cols == 1))
            {
                dtype     dotProduct  = std::inner_product(cbegin(), cend(), inOtherArray.cbegin(), dtype{ 0 });
                self_type returnArray = { dotProduct };
                return returnArray;
            }
            if (shape_.cols == inOtherArray.shape_.rows)
            {
                // 2D array, use matrix multiplication
                self_type returnArray(shape_.rows, inOtherArray.shape_.cols);
                auto      otherArrayT = inOtherArray.transpose();

                for (uint32 i = 0; i < shape_.rows; ++i)
                {
                    for (uint32 j = 0; j < otherArrayT.shape_.rows; ++j)
                    {
                        returnArray(i, j) =
                            std::inner_product(otherArrayT.cbegin(j), otherArrayT.cend(j), cbegin(i), dtype{ 0 });
                    }
                }

                return returnArray;
            }

            std::string errStr = "shapes of [" + utils::num2str(shape_.rows) + ", " + utils::num2str(shape_.cols) + "]";
            errStr += " and [" + utils::num2str(inOtherArray.shape_.rows) + ", " +
                      utils::num2str(inOtherArray.shape_.cols) + "]";
            errStr += " are not consistent.";
            THROW_INVALID_ARGUMENT_ERROR(errStr);

            return self_type(); // get rid of compiler warning
        }

        // Method Description:
        /// Dump a binary file of the array to the specified file.
        /// The array can be read back with nc::load.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.dump.html
        ///
        /// @param inFilename
        ///
        void dump(const std::string& inFilename) const
        {
            std::filesystem::path f(inFilename);
            if (!f.has_extension())
            {
                f.replace_extension("bin");
            }

            std::ofstream ofile(f.c_str(), std::ios::binary);
            if (!ofile.good())
            {
                THROW_RUNTIME_ERROR("Unable to open the input file:\n\t" + inFilename);
            }

            if (array_ != nullptr)
            {
                ofile.write(reinterpret_cast<const char*>(array_), size_ * sizeof(dtype));
            }
            ofile.close();
        }

        // Method Description:
        /// Return the NdArrays endianess
        ///
        /// @return Endian
        ///
        [[nodiscard]] Endian endianess() const noexcept
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return endianess_;
        }

        // Method Description:
        /// Fill the array with a scalar value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.fill.html
        ///
        /// @param inFillValue
        /// @return None
        ///
        self_type& fill(value_type inFillValue) noexcept
        {
            stl_algorithms::fill(begin(), end(), inFillValue);
            return *this;
        }

        // Method Description:
        /// Return the indices of the flattened array of the
        /// elements that are non-zero.
        ///
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<size_type> flatnonzero() const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            std::vector<size_type> indices;
            size_type              idx = 0;
            for (auto value : *this)
            {
                if (!utils::essentiallyEqual(value, dtype{ 0 }))
                {
                    indices.push_back(idx);
                }
                ++idx;
            }

            return NdArray<size_type>(indices); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Return a copy of the array collapsed into one dimension.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.flatten.html
        ///
        /// @return NdArray
        ///
        [[nodiscard]] self_type flatten() const
        {
            self_type outArray(1, size_);
            stl_algorithms::copy(cbegin(), cend(), outArray.begin());
            return outArray;
        }

        // Method Description:
        /// Returns a copy of the first element of the flattened array.
        ///
        /// @return dtype
        ///
        [[nodiscard]] const_reference front() const noexcept
        {
            return *cbegin();
        }

        // Method Description:
        /// Returns a reference to the first element of the flattened array.
        ///
        /// @return dtype
        ///
        reference front() noexcept
        {
            return *begin();
        }

        // Method Description:
        /// Returns a copy of the first element of the input row.
        ///
        /// @return dtype
        ///
        [[nodiscard]] const_reference front(size_type row) const
        {
            return *cbegin(row);
        }

        // Method Description:
        /// Returns a reference to the first element of the input row.
        ///
        /// @return dtype
        ///
        reference front(size_type row)
        {
            return *begin(row);
        }

        // Method Description:
        /// Returns a new flat array with the givin flat input indices.
        ///
        /// @param inIndices
        /// @return values
        ///
        [[nodiscard]] self_type getByIndices(const NdArray<size_type>& inIndices) const
        {
            return operator[](inIndices);
        }

        // Method Description:
        /// Takes in a boolean mask the same size as the array
        /// and returns a flattened array with the values cooresponding
        /// to the input mask.
        ///
        /// @param inMask
        /// @return values
        ///
        [[nodiscard]] self_type getByMask(const NdArray<bool>& inMask) const
        {
            return operator[](inMask);
        }

        // Method Description:
        /// Return if the NdArray is empty. ie the default constructor
        /// was used.
        ///
        /// @return boolean
        ///
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        bool isempty() const noexcept
        {
            return size_ == 0;
        }

        // Method Description:
        /// Return if the NdArray is flat. ie the number of columns or
        /// rows is equal to one.
        ///
        /// @return boolean
        ///
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        bool isflat() const noexcept
        {
            return !isscalar() && (shape_.rows == 1 || shape_.cols == 1);
        }

        // Method Description:
        /// Return if the NdArray is scalar
        ///
        /// @return boolean
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        bool isscalar() const noexcept
        {
            return size_ == 1;
        }

        // Method Description:
        /// Return if the NdArray is sorted.
        ///
        /// @param inAxis
        /// @return boolean
        ///
        [[nodiscard]] NdArray<bool> issorted(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    return { stl_algorithms::is_sorted(cbegin(), cend(), comparitor) };
                }
                case Axis::COL:
                {
                    NdArray<bool> returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = stl_algorithms::is_sorted(cbegin(row), cend(row), comparitor);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().issorted(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return if the NdArray is square.
        ///
        /// @return boolean
        ///
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        bool issquare() const noexcept
        {
            return shape_.issquare();
        }

        // Method Description:
        /// Copy an element of an array to a standard C++ scalar and return it.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.item.html
        ///
        /// @return array element
        ///
        [[nodiscard]] value_type item() const
        {
            if (!isscalar())
            {
                THROW_INVALID_ARGUMENT_ERROR("Can only convert an array of size 1 to a C++ scalar");
            }

            return front();
        }

        // Method Description:
        /// Return the maximum along a given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.max.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type max(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type returnArray = { *stl_algorithms::max_element(cbegin(), cend(), comparitor) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = *stl_algorithms::max_element(cbegin(row), cend(row), comparitor);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().max(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return the minimum along a given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.min.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type min(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type returnArray = { *stl_algorithms::min_element(cbegin(), cend(), comparitor) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = *stl_algorithms::min_element(cbegin(row), cend(row), comparitor);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().min(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return the median along a given axis.
        /// If the dtype is floating point then the middle elements will be
        /// averaged for arrays of even number of elements.
        /// If the dtype is integral then the middle elements will be intager
        /// averaged (rounded down to integer) for arrays of even number of elements.
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type median(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            if (size_ == 0)
            {
                THROW_RUNTIME_ERROR("Median is undefined for an array of size = 0.");
            }

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type copyArray(*this);

                    const size_type middleIdx = size_ / 2; // integer division
                    stl_algorithms::nth_element(copyArray.begin(),
                                                copyArray.begin() + middleIdx,
                                                copyArray.end(),
                                                comparitor);

                    dtype medianValue = copyArray.array_[middleIdx];
                    if (size_ % 2 == 0)
                    {
                        const size_type lhsIndex = middleIdx - 1;
                        stl_algorithms::nth_element(copyArray.begin(),
                                                    copyArray.begin() + lhsIndex,
                                                    copyArray.end(),
                                                    comparitor);
                        medianValue =
                            (medianValue + copyArray.array_[lhsIndex]) / dtype{ 2 }; // potentially integer division, ok
                    }

                    return { medianValue };
                }
                case Axis::COL:
                {
                    self_type copyArray(*this);
                    self_type returnArray(1, shape_.rows);

                    const bool isEven = shape_.cols % 2 == 0;
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        const uint32 middleIdx = shape_.cols / 2; // integer division
                        stl_algorithms::nth_element(copyArray.begin(row),
                                                    copyArray.begin(row) + middleIdx,
                                                    copyArray.end(row),
                                                    comparitor);

                        dtype medianValue = copyArray(row, middleIdx);
                        if (isEven)
                        {
                            const size_type lhsIndex = middleIdx - 1;
                            stl_algorithms::nth_element(copyArray.begin(row),
                                                        copyArray.begin(row) + lhsIndex,
                                                        copyArray.end(row),
                                                        comparitor);
                            medianValue = (medianValue + copyArray(row, lhsIndex)) /
                                          dtype{ 2 }; // potentially integer division, ok
                        }

                        returnArray(0, row) = medianValue;
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().median(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Fills the array with nans.
        ///
        ///
        self_type& nans() noexcept

        {
            STATIC_ASSERT_FLOAT(dtype);

            fill(constants::nan);
            return *this;
        }

        // Method Description:
        /// Returns the number of bytes held by the array
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.nbytes.html
        ///
        /// @return number of bytes
        ///
        [[nodiscard]] uint64 nbytes() const noexcept
        {
            return static_cast<uint64>(sizeof(dtype) * size_);
        }

        // Method Description:
        /// Return the array with the same data viewed with a
        /// different byte order. only works for integer types.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.newbyteorder.html
        ///
        /// @param inEndianess
        /// @return NdArray
        ///
        [[nodiscard]] self_type newbyteorder(Endian inEndianess) const
        {
            STATIC_ASSERT_INTEGER(dtype);

            const bool nativeIsLittle = endian::isLittleEndian();

            switch (endianess_)
            {
                case Endian::NATIVE:
                {
                    switch (inEndianess)
                    {
                        case Endian::NATIVE:
                        {
                            return NdArray(*this);
                        }
                        case Endian::BIG:
                        {
                            if (nativeIsLittle)
                            {
                                self_type outArray(shape_);

                                stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                                outArray.endianess_ = Endian::BIG;
                                return outArray;
                            }
                            else
                            {
                                auto outArray       = NdArray(*this);
                                outArray.endianess_ = Endian::BIG;
                                return outArray;
                            }
                        }
                        case Endian::LITTLE:
                        {
                            if (nativeIsLittle)
                            {
                                auto outArray       = NdArray(*this);
                                outArray.endianess_ = Endian::LITTLE;
                                return outArray;
                            }
                            else
                            {
                                self_type outArray(shape_);

                                stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                                outArray.endianess_ = Endian::LITTLE;
                                return outArray;
                            }
                        }
                        default:
                        {
                            THROW_INVALID_ARGUMENT_ERROR("Unimplemented endian type.");
                            return {}; // get rid of compiler warning
                        }
                    }
                    break;
                }
                case Endian::BIG:
                {
                    switch (inEndianess)
                    {
                        case Endian::NATIVE:
                        {
                            if (nativeIsLittle)
                            {
                                self_type outArray(shape_);

                                stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                                outArray.endianess_ = Endian::NATIVE;
                                return outArray;
                            }
                            else
                            {
                                auto outArray       = NdArray(*this);
                                outArray.endianess_ = Endian::NATIVE;
                                return outArray;
                            }
                        }
                        case Endian::BIG:
                        {
                            return NdArray(*this);
                        }
                        case Endian::LITTLE:
                        {
                            self_type outArray(shape_);

                            stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                            outArray.endianess_ = Endian::LITTLE;
                            return outArray;
                        }
                        default:
                        {
                            THROW_INVALID_ARGUMENT_ERROR("Unimplemented endian type.");
                            return {}; // get rid of compiler warning
                        }
                    }
                    break;
                }
                case Endian::LITTLE:
                {
                    switch (inEndianess)
                    {
                        case Endian::NATIVE:
                        {
                            if (nativeIsLittle)
                            {
                                auto outArray       = NdArray(*this);
                                outArray.endianess_ = Endian::NATIVE;
                                return outArray;
                            }
                            else
                            {
                                self_type outArray(shape_);

                                stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                                outArray.endianess_ = Endian::NATIVE;
                                return outArray;
                            }
                        }
                        case Endian::BIG:
                        {
                            self_type outArray(shape_);

                            stl_algorithms::transform(cbegin(), end(), outArray.begin(), endian::byteSwap<dtype>);

                            outArray.endianess_ = Endian::BIG;
                            return outArray;
                        }
                        case Endian::LITTLE:
                        {
                            return NdArray(*this);
                        }
                        default:
                        {
                            THROW_INVALID_ARGUMENT_ERROR("Unimplemented endian type.");
                            return {}; // get rid of compiler warning
                        }
                    }
                    break;
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented endian type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Returns True if none elements evaluate to True or non zero
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.any.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<bool> none(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto function = [](dtype i) -> bool { return !utils::essentiallyEqual(i, dtype{ 0 }); };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    NdArray<bool> returnArray = { stl_algorithms::none_of(cbegin(), cend(), function) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    NdArray<bool> returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = stl_algorithms::none_of(cbegin(row), cend(row), function);
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().none(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Return the row/col indices of the array of the
        /// elements that are non-zero.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.nonzero.html
        ///
        /// @return std::pair<NdArray, NdArray> where first is the row indices and second is the
        /// column indices
        ///
        [[nodiscard]] std::pair<NdArray<size_type>, NdArray<size_type>> nonzero() const;

        // Method Description:
        /// Returns the number of columns in the array
        ///
        ///
        /// @return size_type
        ///
        [[nodiscard]] size_type numCols() const noexcept
        {
            return shape_.cols;
        }

        // Method Description:
        /// Returns the number of rows in the array
        ///
        ///
        /// @return size_type
        ///
        [[nodiscard]] size_type numRows() const noexcept
        {
            return shape_.rows;
        }

        // Method Description:
        /// Fills the array with ones
        ///
        ///
        self_type& ones() noexcept
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            fill(dtype{ 1 });
            return *this;
        }

        // Method Description:
        /// Returns whether or not the array object owns the underlying data
        ///
        /// @return bool
        ///
        bool ownsInternalData() noexcept
        {
            return ownsPtr_;
        }

        // Method Description:
        /// Rearranges the elements in the array in such a way that
        /// value of the element in kth position is in the position it
        /// would be in a sorted array. All elements smaller than the kth
        /// element are moved before this element and all equal or greater
        /// are moved behind it. The ordering of the elements in the two
        /// partitions is undefined.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.partition.html
        ///
        /// @param inKth: kth element
        /// @param inAxis (Optional, default NONE)
        /// @return None
        ///
        self_type& partition(size_type inKth, Axis inAxis = Axis::NONE)
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool
            { return lhs < rhs; }; // cppcheck-suppress returnTempReference

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    if (inKth >= size_)
                    {
                        std::string errStr = "kth(=" + utils::num2str(inKth);
                        errStr += ") out of bounds (" + utils::num2str(size_) + ")";
                        THROW_INVALID_ARGUMENT_ERROR(errStr);
                    }

                    stl_algorithms::nth_element(begin(), begin() + inKth, end(), comparitor);
                    break;
                }
                case Axis::COL:
                {
                    if (inKth >= shape_.cols)
                    {
                        std::string errStr = "kth(=" + utils::num2str(inKth);
                        errStr += ") out of bounds (" + utils::num2str(shape_.cols) + ")";
                        THROW_INVALID_ARGUMENT_ERROR(errStr);
                    }

                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        stl_algorithms::nth_element(begin(row), begin(row) + inKth, end(row), comparitor);
                    }
                    break;
                }
                case Axis::ROW:
                {
                    if (inKth >= shape_.rows)
                    {
                        std::string errStr = "kth(=" + utils::num2str(inKth);
                        errStr += ") out of bounds (" + utils::num2str(shape_.rows) + ")";
                        THROW_INVALID_ARGUMENT_ERROR(errStr);
                    }

                    self_type transposedArray = transpose();
                    for (uint32 row = 0; row < transposedArray.shape_.rows; ++row)
                    {
                        stl_algorithms::nth_element(transposedArray.begin(row),
                                                    transposedArray.begin(row) + inKth,
                                                    transposedArray.end(row),
                                                    comparitor);
                    }
                    *this = transposedArray.transpose();
                    break;
                }
            }

            return *this;
        }

        // Method Description:
        /// Prints the array to the console.
        ///
        ///
        void print() const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            std::cout << *this;
        }

        // Method Description:
        /// Return the product of the array elements over the given axis
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.prod.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type prod(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    dtype     product     = std::accumulate(cbegin(), cend(), dtype{ 1 }, std::multiplies<dtype>());
                    self_type returnArray = { product };
                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) =
                            std::accumulate(cbegin(row), cend(row), dtype{ 1 }, std::multiplies<dtype>());
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().prod(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Peak to peak (maximum - minimum) value along a given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.ptp.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type ptp(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    const auto result      = stl_algorithms::minmax_element(cbegin(), cend(), comparitor);
                    self_type  returnArray = { *result.second - *result.first };
                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        const auto result   = stl_algorithms::minmax_element(cbegin(row), cend(row), comparitor);
                        returnArray(0, row) = *result.second - *result.first;
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().ptp(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// set the flat index element to the value
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inIndex
        /// @param inValue
        ///
        self_type& put(index_type inIndex, const value_type& inValue)
        {
            at(inIndex) = inValue;

            return *this;
        }

        // Method Description:
        /// set the 2D row/col index element to the value
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRow
        /// @param inCol
        /// @param inValue
        ///
        self_type& put(index_type inRow, index_type inCol, const value_type& inValue)
        {
            at(inRow, inCol) = inValue;

            return *this;
        }

        // Method Description:
        /// Set a.flat[n] = values for all n in indices.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inIndices
        /// @param inValue
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(const Indices& inIndices, const value_type& inValue)
        {
            for (auto index : inIndices)
            {
                put(index, inValue);
            }

            return *this;
        }

        // Method Description:
        /// Set a.flat[n] = values[n] for all n in indices.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inIndices
        /// @param inValues
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(const Indices& inIndices, const self_type& inValues)
        {
            if (inValues.isscalar())
            {
                return put(inIndices, inValues.item());
            }
            else if (inIndices.size() != inValues.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input indices do not match values dimensions.");
            }

            size_type counter = 0;
            for (auto index : inIndices)
            {
                put(index, inValues[counter++]);
            }

            return *this;
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inSlice
        /// @param inValue
        /// @return reference to self
        ///
        self_type& put(const Slice& inSlice, const value_type& inValue)
        {
            return put(toIndices(inSlice, Axis::NONE), inValue);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inSlice
        /// @param inValues
        /// @return reference to self
        ///
        self_type& put(const Slice& inSlice, const self_type& inValues)
        {
            return put(toIndices(inSlice, Axis::NONE), inValues);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColIndices
        /// @param inValue
        /// @return reference to self
        ///
        template<typename RowIndices,
                 typename ColIndices,
                 type_traits::ndarray_int_concept<RowIndices> = 0,
                 type_traits::ndarray_int_concept<ColIndices> = 0>
        self_type& put(const RowIndices& inRowIndices, const ColIndices& inColIndices, const value_type& inValue)
        {
            stl_algorithms::for_each(inRowIndices.begin(),
                                     inRowIndices.end(),
                                     [this, &inColIndices, &inValue](const auto row)
                                     {
                                         stl_algorithms::for_each(inColIndices.begin(),
                                                                  inColIndices.end(),
                                                                  [this, row, &inValue](const auto col)
                                                                  { this->put(row, col, inValue); });
                                     });

            return *this;
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColSlice
        /// @param inValue
        /// @return reference to self
        ///
        template<typename RowIndices, type_traits::ndarray_int_concept<RowIndices> = 0>
        self_type& put(const RowIndices& inRowIndices, const Slice& inColSlice, const value_type& inValue)
        {
            return put(inRowIndices, toIndices(inColSlice, Axis::COL), inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColIndices
        /// @param inValue
        /// @return reference to self
        ///
        template<typename ColIndices, type_traits::ndarray_int_concept<ColIndices> = 0>
        self_type& put(const Slice& inRowSlice, const ColIndices& inColIndices, const value_type& inValue)
        {
            return put(toIndices(inRowSlice, Axis::ROW), inColIndices, inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColSlice
        /// @param inValue
        /// @return reference to self
        ///
        self_type& put(const Slice& inRowSlice, const Slice& inColSlice, const value_type& inValue)
        {
            return put(toIndices(inRowSlice, Axis::ROW), toIndices(inColSlice, Axis::COL), inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColIndex
        /// @param inValue
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(const Indices& inRowIndices, index_type inColIndex, const value_type& inValue)
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return put(inRowIndices, colIndices, inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColIndex
        /// @param inValue
        /// @return reference to self
        ///
        self_type& put(const Slice& inRowSlice, index_type inColIndex, const value_type& inValue)
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return put(toIndices(inRowSlice, Axis::ROW), colIndices, inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndex
        /// @param inColIndices
        /// @param inValue
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(index_type inRowIndex, const Indices& inColIndices, const value_type& inValue)
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return put(rowIndices, inColIndices, inValue);
        }

        // Method Description:
        /// Set the slice indices to the input value.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndex
        /// @param inColSlice
        /// @param inValue
        /// @return reference to self
        ///
        self_type& put(index_type inRowIndex, const Slice& inColSlice, const value_type& inValue)
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return put(rowIndices, toIndices(inColSlice, Axis::COL), inValue);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColIndices
        /// @param inValues
        /// @return reference to self
        ///
        template<typename RowIndices,
                 typename ColIndices,
                 type_traits::ndarray_int_concept<RowIndices> = 0,
                 type_traits::ndarray_int_concept<ColIndices> = 0>
        self_type& put(const RowIndices& inRowIndices, const ColIndices& inColIndices, const self_type& inValues)
        {
            std::vector<size_type> indices;
            indices.reserve(inRowIndices.size() * inColIndices.size());
            std::for_each(inRowIndices.begin(),
                          inRowIndices.end(),
                          [this, &inColIndices, &indices](auto row)
                          {
                              if constexpr (std::is_signed_v<decltype(row)>)
                              {
                                  if (row < 0)
                                  {
                                      row += shape_.rows;
                                  }
                                  // still
                                  if (row < 0)
                                  {
                                      THROW_INVALID_ARGUMENT_ERROR("row index exceeds matrix dimensions");
                                  }
                              }
                              std::for_each(inColIndices.begin(),
                                            inColIndices.end(),
                                            [this, row, &indices](auto col)
                                            {
                                                if constexpr (std::is_signed_v<decltype(col)>)
                                                {
                                                    if (col < 0)
                                                    {
                                                        col += shape_.cols;
                                                    }
                                                    // still
                                                    if (col < 0)
                                                    {
                                                        THROW_INVALID_ARGUMENT_ERROR(
                                                            "col index exceeds matrix dimensions");
                                                    }
                                                }
                                                indices.push_back(row * shape_.cols + col);
                                            });
                          });

            return put(NdArray<size_type>(indices.data(), indices.size(), PointerPolicy::SHELL), inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColSlice
        /// @param inValues
        /// @return reference to self
        ///
        template<typename RowIndices, type_traits::ndarray_int_concept<RowIndices> = 0>
        self_type& put(const RowIndices& inRowIndices, Slice inColSlice, const self_type& inValues)
        {
            return put(inRowIndices, toIndices(inColSlice, Axis::COL), inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColIndices
        /// @param inValues
        /// @return reference to self
        ///
        template<typename ColIndices, type_traits::ndarray_int_concept<ColIndices> = 0>
        self_type& put(Slice inRowSlice, const ColIndices& inColIndices, const self_type& inValues)
        {
            return put(toIndices(inRowSlice, Axis::ROW), inColIndices, inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColSlice
        /// @param inValues
        /// @return reference to self
        ///
        self_type& put(Slice inRowSlice, Slice inColSlice, const self_type& inValues)
        {
            return put(toIndices(inRowSlice, Axis::ROW), toIndices(inColSlice, Axis::COL), inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndices
        /// @param inColIndex
        /// @param inValues
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(const Indices& inRowIndices, index_type inColIndex, const self_type& inValues)
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return put(inRowIndices, colIndices, inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowSlice
        /// @param inColIndex
        /// @param inValues
        /// @return reference to self
        ///
        self_type& put(const Slice& inRowSlice, index_type inColIndex, const self_type& inValues)
        {
            const NdArray<index_type> colIndices = { inColIndex };
            return put(toIndices(inRowSlice, Axis::ROW), colIndices, inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndex
        /// @param inColIndices
        /// @param inValues
        /// @return reference to self
        ///
        template<typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        self_type& put(index_type inRowIndex, const Indices& inColIndices, const self_type& inValues)
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return put(rowIndices, inColIndices, inValues);
        }

        // Method Description:
        /// Set the slice indices to the input values.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
        ///
        /// @param inRowIndex
        /// @param inColSlice
        /// @param inValues
        /// @return reference to self
        ///
        self_type& put(index_type inRowIndex, const Slice& inColSlice, const self_type& inValues)
        {
            const NdArray<index_type> rowIndices = { inRowIndex };
            return put(rowIndices, toIndices(inColSlice, Axis::COL), inValues);
        }

        // Method Description:
        /// Set the mask indices to the input value.
        ///
        /// @param inMask
        /// @param inValue
        ///
        self_type& putMask(const NdArray<bool>& inMask, const value_type& inValue)
        {
            if (inMask.shape() != shape_)
            {
                THROW_INVALID_ARGUMENT_ERROR("input inMask must be the same shape as the array it is masking.");
            }

            return put(inMask.flatnonzero(), inValue);
        }

        // Method Description:
        /// Set the mask indices to the input values.
        ///
        /// @param inMask
        /// @param inValues
        ///
        self_type& putMask(const NdArray<bool>& inMask, const self_type& inValues)
        {
            if (inMask.shape() != shape_)
            {
                THROW_INVALID_ARGUMENT_ERROR("input inMask must be the same shape as the array it is masking.");
            }

            if (inValues.isscalar())
            {
                put(inMask.flatnonzero(), inValues.item());
            }
            else
            {
                put(inMask.flatnonzero(), inValues);
            }

            return *this;
        }

        // Method Description:
        /// Flattens the array but does not make a copy.
        ///
        /// Numpy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html
        ///
        /// @return NdArray
        ///
        self_type& ravel()
        {
            reshape(size_);
            return *this;
        }

        // Method Description:
        /// Repeat elements of an array.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.repeat.html
        ///
        /// @param inNumRows
        /// @param inNumCols
        /// @return NdArray
        ///
        [[nodiscard]] self_type repeat(size_type inNumRows, size_type inNumCols) const
        {
            self_type returnArray(shape_.rows * inNumRows, shape_.cols * inNumCols);

            for (size_type row = 0; row < inNumRows; ++row)
            {
                for (size_type col = 0; col < inNumCols; ++col)
                {
                    std::vector<size_type> indices(shape_.size());

                    const size_type rowStart = row * shape_.rows;
                    const size_type colStart = col * shape_.cols;

                    const size_type rowEnd = (row + 1) * shape_.rows;
                    const size_type colEnd = (col + 1) * shape_.cols;

                    size_type counter = 0;
                    for (size_type rowIdx = rowStart; rowIdx < rowEnd; ++rowIdx)
                    {
                        for (size_type colIdx = colStart; colIdx < colEnd; ++colIdx)
                        {
                            indices[counter++] = rowIdx * returnArray.shape_.cols + colIdx;
                        }
                    }

                    returnArray.put(NdArray<size_type>(indices), *this);
                }
            }

            return returnArray;
        }

        // Method Description:
        /// Repeat elements of an array.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.repeat.html
        ///
        /// @param inRepeatShape
        /// @return NdArray
        ///
        [[nodiscard]] self_type repeat(const Shape& inRepeatShape) const
        {
            return repeat(inRepeatShape.rows, inRepeatShape.cols);
        }

        // Method Description:
        /// Replaces a value of the array with another value
        ///
        /// @param oldValue: the value to replace
        /// @param newValue: the value to replace with
        ///
        self_type& replace(value_type oldValue, value_type newValue)
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            stl_algorithms::replace(begin(), end(), oldValue, newValue);
            return *this;
        }

        // Method Description:
        /// The new shape should be compatible with the original shape. If an single integer,
        /// then the result will be a 1-D array of that length. One shape dimension
        /// can be -1. In this case, the value is inferred from the length of the
        /// array and remaining dimensions.
        ///
        /// NOTE: array shape is modified. If a copy is desired then the user should call the copy method:
        /// auto aNew = a.reshape(newSize).copy()
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.reshape.html
        ///
        /// @param inSize
        /// @returns reference to self
        ///
        self_type& reshape(size_type inSize)
        {
            if (inSize != size_)
            {
                std::string errStr = "Cannot reshape array of size " + utils::num2str(size_) + " into shape ";
                errStr += "[" + utils::num2str(1) + ", " + utils::num2str(inSize) + "]";
                THROW_RUNTIME_ERROR(errStr);
            }

            shape_.rows = 1;
            shape_.cols = inSize;

            return *this;
        }

        // Method Description:
        /// The new shape should be compatible with the original shape. If an single integer,
        /// then the result will be a 1-D array of that length. One shape dimension
        /// can be -1. In this case, the value is inferred from the length of the
        /// array and remaining dimensions.
        ///
        /// NOTE: array shape is modified. If a copy is desired then the user should call the copy method:
        /// auto aNew = a.reshape(newRows, newCols).copy()
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.reshape.html
        ///
        /// @param inNumRows
        /// @param inNumCols
        /// @returns reference to self
        ///
        self_type& reshape(index_type inNumRows, index_type inNumCols)
        {
            if (inNumRows < 0)
            {
                if (size_ % inNumCols == 0)
                {
                    return reshape(size_ / inNumCols, inNumCols);
                }

                std::string errStr = "Cannot reshape array of size " + utils::num2str(size_) + " into a shape ";
                errStr += "with " + utils::num2str(inNumCols) + " columns";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            if (inNumCols < 0)
            {
                if (size_ % inNumRows == 0)
                {
                    return reshape(inNumRows, size_ / inNumRows);
                }

                std::string errStr = "Cannot reshape array of size " + utils::num2str(size_) + " into a shape ";
                errStr += "with " + utils::num2str(inNumRows) + " rows";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            if (static_cast<size_type>(inNumRows * inNumCols) != size_)
            {
                std::string errStr = "Cannot reshape array of size " + utils::num2str(size_) + " into shape ";
                errStr += "[" + utils::num2str(inNumRows) + ", " + utils::num2str(inNumCols) + "]";
                THROW_INVALID_ARGUMENT_ERROR(errStr);
            }

            shape_.rows = static_cast<size_type>(inNumRows);
            shape_.cols = static_cast<size_type>(inNumCols);

            return *this;
        }

        // Method Description:
        /// The new shape should be compatible with the original shape. If an single integer,
        /// then the result will be a 1-D array of that length. One shape dimension
        /// can be -1. In this case, the value is inferred from the length of the
        /// array and remaining dimensions.
        ///
        /// NOTE: array shape is modified. If a copy is desired then the user should call the copy method:
        /// auto aNew = a.reshape(newShape).copy()
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.reshape.html
        ///
        /// @param inShape
        /// @returns reference to self
        ///
        self_type& reshape(const Shape& inShape)
        {
            return reshape(inShape.rows, inShape.cols);
        }

        // Method Description:
        /// Change shape and size of array in-place. All previous
        /// data of the array is lost.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.resize.html
        ///
        /// @param inNumRows
        /// @param inNumCols
        ///
        self_type& resizeFast(size_type inNumRows, size_type inNumCols)
        {
            newArray(Shape(inNumRows, inNumCols));
            return *this;
        }

        // Method Description:
        /// Change shape and size of array in-place. All previous
        /// data of the array is lost.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.resize.html
        ///
        /// @param inShape
        ///
        self_type& resizeFast(const Shape& inShape)
        {
            return resizeFast(inShape.rows, inShape.cols);
        }

        // Method Description:
        /// Return a new array with the specified shape. If new shape
        /// is larger than old shape then array will be padded with zeros.
        /// If new shape is smaller than the old shape then the data will
        /// be discarded.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.resize.html
        ///
        /// @param inNumRows
        /// @param inNumCols
        ///
        self_type& resizeSlow(size_type inNumRows, size_type inNumCols)
        {
            std::vector<dtype> oldData(size_);
            stl_algorithms::copy(begin(), end(), oldData.begin());

            const Shape inShape(inNumRows, inNumCols);
            const Shape oldShape = shape_;

            newArray(inShape);

            for (uint32 row = 0; row < inShape.rows; ++row)
            {
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    if (row >= oldShape.rows || col >= oldShape.cols)
                    {
                        operator()(row, col) = dtype{ 0 }; // zero fill
                    }
                    else
                    {
                        operator()(row, col) = oldData[row * oldShape.cols + col];
                    }
                }
            }

            return *this;
        }

        // Method Description:
        /// Return a new array with the specified shape. If new shape
        /// is larger than old shape then array will be padded with zeros.
        /// If new shape is smaller than the old shape then the data will
        /// be discarded.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.resize.html
        ///
        /// @param inShape
        ///
        self_type& resizeSlow(const Shape& inShape)
        {
            return resizeSlow(inShape.rows, inShape.cols);
        }

        // Method Description:
        /// Return a with each element rounded to the given number
        /// of decimals.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.round.html
        ///
        /// @param inNumDecimals (default 0)
        /// @return NdArray
        ///
        [[nodiscard]] self_type round(uint8 inNumDecimals = 0) const
        {
            STATIC_ASSERT_FLOAT(dtype);

            self_type    returnArray(shape_);
            const double multFactor = utils::power(10., inNumDecimals);
            const auto   function   = [multFactor](dtype value) noexcept -> dtype
            { return static_cast<dtype>(std::nearbyint(static_cast<double>(value) * multFactor) / multFactor); };

            stl_algorithms::transform(cbegin(), cend(), returnArray.begin(), function);

            return returnArray;
        }

        // Method Description:
        /// Returns the full row of the array
        ///
        /// @param inRow: the row index
        /// @return self_type
        ///
        [[nodiscard]] self_type row(size_type inRow) const
        {
            return self_type(cbegin(inRow), cend(inRow));
        }

        // Method Description:
        /// Returns the full row of the array
        ///
        /// @param inRows: the row indices
        /// @return self_type
        ///
        [[nodiscard]] self_type rows(const NdArray<size_type>& inRows) const
        {
            auto       returnArray = self_type(inRows.size(), shape_.cols);
            const auto cSlice      = returnArray.cSlice();

            for (size_type i = 0; i < inRows.size(); ++i)
            {
                returnArray.put(i, cSlice, row(inRows[i]));
            }

            return returnArray;
        }

        // Method Description:
        /// Return the shape of the array
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.shape.html
        ///
        /// @return Shape
        ///
        [[nodiscard]] const Shape& shape() const noexcept
        {
            return shape_;
        }

        // Method Description:
        /// Return the size of the array
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.size.html
        ///
        /// @return size
        ///
        [[nodiscard]] size_type size() const noexcept
        {
            return size_;
        }

        // Method Description:
        /// Sort an array, in-place.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.sort.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return size
        ///
        self_type& sort(Axis inAxis = Axis::NONE)
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool
            { return lhs < rhs; }; // cppcheck-suppress returnTempReference

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    stl_algorithms::sort(begin(), end(), comparitor);
                    break;
                }
                case Axis::COL:
                {
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        stl_algorithms::sort(begin(row), end(row), comparitor);
                    }
                    break;
                }
                case Axis::ROW:
                {
                    self_type transposedArray = transpose();
                    for (uint32 row = 0; row < transposedArray.shape_.rows; ++row)
                    {
                        stl_algorithms::sort(transposedArray.begin(row), transposedArray.end(row), comparitor);
                    }

                    *this = transposedArray.transpose();
                    break;
                }
            }

            return *this;
        }

        // Method Description:
        /// returns the NdArray as a string representation
        ///
        /// @return string
        ///
        [[nodiscard]] std::string str() const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            std::string out;
            out += "[";
            for (uint32 row = 0; row < shape_.rows; ++row)
            {
                out += "[";
                for (uint32 col = 0; col < shape_.cols; ++col)
                {
                    out += utils::value2str(operator()(row, col)) + ", ";
                }

                if (row == shape_.rows - 1)
                {
                    out += "]";
                }
                else
                {
                    out += "]\n";
                }
            }
            out += "]\n";
            return out;
        }

        // Method Description:
        /// Return the sum of the array elements over the given axis.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.sum.html
        ///
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        [[nodiscard]] self_type sum(Axis inAxis = Axis::NONE) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            switch (inAxis)
            {
                case Axis::NONE:
                {
                    self_type returnArray = { std::accumulate(cbegin(), cend(), dtype{ 0 }) };
                    return returnArray;
                }
                case Axis::COL:
                {
                    self_type returnArray(1, shape_.rows);
                    for (uint32 row = 0; row < shape_.rows; ++row)
                    {
                        returnArray(0, row) = std::accumulate(cbegin(row), cend(row), dtype{ 0 });
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return transpose().sum(Axis::COL);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }

        // Method Description:
        /// Interchange two axes of an array. Equivalent to transpose...
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.swapaxes.html
        ///
        /// @return NdArray
        ///
        [[nodiscard]] self_type swapaxes() const
        {
            return transpose();
        }

        // Method Description:
        /// Swaps rows of the array
        ///
        /// @param colIdx1
        /// @param colIdx2
        /// @return reference to self
        ///
        self_type& swapCols(index_type colIdx1, index_type colIdx2) noexcept
        {
            for (index_type row = 0; row < static_cast<index_type>(shape_.rows); ++row)
            {
                std::swap(operator()(row, colIdx1), operator()(row, colIdx2));
            }

            return *this;
        }

        // Method Description:
        /// Swaps rows of the array
        ///
        /// @param rowIdx1
        /// @param rowIdx2
        ///
        /// @return reference to self
        self_type& swapRows(index_type rowIdx1, index_type rowIdx2) noexcept
        {
            for (index_type col = 0; col < static_cast<index_type>(shape_.cols); ++col)
            {
                std::swap(operator()(rowIdx1, col), operator()(rowIdx2, col));
            }

            return *this;
        }

        // Method Description:
        /// Write array to a file as binary.
        /// The data produced by this method can be recovered
        /// using the function fromfile().
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.tofile.html
        ///
        /// @param inFilename
        ///
        void tofile(const std::string& inFilename) const
        {
            dump(inFilename);
        }

        // Method Description:
        /// Write array to a file as text.
        /// The data produced by this method can be recovered
        /// using the function fromfile().
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.tofile.html
        ///
        /// @param inFilename
        /// @param inSep: Separator between array items for text output.
        ///
        void tofile(const std::string& inFilename, const char inSep) const
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            std::filesystem::path f(inFilename);
            if (!f.has_extension())
            {
                f.replace_extension("txt");
            }

            std::ofstream ofile(f.c_str());
            if (!ofile.good())
            {
                THROW_RUNTIME_ERROR("Input file could not be opened:\n\t" + inFilename);
            }

            size_type counter = 0;
            for (auto value : *this)
            {
                ofile << value;
                if (counter++ != size_ - 1)
                {
                    ofile << inSep;
                }
            }
            ofile.close();
        }

        // Method Description:
        /// Converts the slice object to an NdArray of indices for this array
        ///
        /// @param inSlice: the slice object
        /// @param inAxis: the array axis
        ///
        /// @return NdArray<index_type>
        ///
        [[nodiscard]] NdArray<size_type> toIndices(Slice inSlice, Axis inAxis = Axis::NONE) const
        {
            size_type numElements = 0;
            switch (inAxis)
            {
                case Axis::NONE:
                {
                    numElements = inSlice.numElements(size_);
                    break;
                }
                case Axis::ROW:
                {
                    numElements = inSlice.numElements(shape_.rows);
                    break;
                }
                case Axis::COL:
                {
                    numElements = inSlice.numElements(shape_.cols);
                    break;
                }
                default:
                {
                    // not actually possible, getting rid of compiler warning
                    THROW_INVALID_ARGUMENT_ERROR("Invalid 'inAxis' option");
                }
            }

            if (numElements == 0)
            {
                return {};
            }

            NdArray<size_type> indices(1, numElements);
            indices[0] = static_cast<size_type>(inSlice.start);
            for (size_type i = 1; i < indices.size(); ++i)
            {
                indices[static_cast<index_type>(i)] = static_cast<size_type>(
                    indices[static_cast<index_type>(i - size_type{ 1 })] + static_cast<size_type>(inSlice.step));
            }

            return indices;
        }

        // Method Description:
        /// Write flattened array to an STL vector
        ///
        /// @return std::vector
        ///
        [[nodiscard]] std::vector<dtype> toStlVector() const
        {
            return std::vector<dtype>(cbegin(), cend());
        }

        // Method Description:
        /// Return the sum along diagonals of the array.
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.trace.html
        ///
        /// @param inOffset: Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults
        /// to 0.
        /// @param inAxis: (Optional, default ROW) Axis to offset from
        ///
        /// @return value
        ///
        [[nodiscard]] value_type trace(size_type inOffset = 0, Axis inAxis = Axis::ROW) const noexcept
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            size_type rowStart = 0;
            size_type colStart = 0;
            switch (inAxis)
            {
                case Axis::ROW:
                {
                    rowStart += inOffset;
                    break;
                }
                case Axis::COL:
                {
                    colStart += inOffset;
                    break;
                }
                default:
                {
                    // if the user input NONE, override back to ROW
                    inAxis = Axis::ROW;
                    break;
                }
            }

            if (rowStart >= shape_.rows || colStart >= shape_.cols)
            {
                return dtype{ 0 };
            }

            size_type col = colStart;
            dtype     sum = 0;
            for (size_type row = rowStart; row < shape_.rows; ++row)
            {
                if (col >= shape_.cols)
                {
                    break;
                }
                sum += operator()(row, col++);
            }

            return sum;
        }

        // Method Description:
        /// Tranpose the rows and columns of an array
        ///
        /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.transpose.html
        ///
        /// @return NdArray
        ///
        [[nodiscard]] self_type transpose() const
        {
            self_type transArray(shape_.cols, shape_.rows);
            for (uint32 row = 0; row < shape_.rows; ++row)
            {
                for (uint32 col = 0; col < shape_.cols; ++col)
                {
                    transArray(col, row) = operator()(row, col);
                }
            }
            return transArray;
        }

        // Method Description:
        /// Fills the array with zeros
        ///
        ///
        self_type& zeros() noexcept
        {
            STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

            fill(dtype{ 0 });
            return *this;
        }

    private:
        //====================================Attributes==============================
        allocator_type allocator_{};
        Shape          shape_{ 0, 0 };
        size_type      size_{ 0 };
        Endian         endianess_{ Endian::NATIVE };
        pointer        array_{ nullptr };
        bool           ownsPtr_{ false };

        // Method Description:
        /// Deletes the internal array
        ///
        void deleteArray() noexcept
        {
            if (ownsPtr_ && array_ != nullptr)
            {
                allocator_.deallocate(array_, size_);
            }

            array_      = nullptr;
            shape_.rows = shape_.cols = 0;
            size_                     = 0;
            ownsPtr_                  = false;
            endianess_                = Endian::NATIVE;
        }

        // Method Description:
        /// Creates a new internal array
        ///
        void newArray()
        {
            if (size_ > 0)
            {
                array_   = allocator_.allocate(size_);
                ownsPtr_ = true;
            }
        }

        // Method Description:
        /// Creates a new internal array
        ///
        /// @param inShape
        ///
        void newArray(const Shape& inShape)
        {
            deleteArray();

            shape_ = inShape;
            size_  = inShape.size();
            newArray();
        }
    };

    // NOTE: this needs to be defined outside of the class to get rid of a compiler
    // error in Visual Studio
    template<typename dtype, class Alloc_>
    [[nodiscard]] std::pair<NdArray<uint32>, NdArray<uint32>> NdArray<dtype, Alloc_>::nonzero() const
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        std::vector<size_type> rowIndices;
        std::vector<size_type> colIndices;

        for (uint32 row = 0; row < shape_.rows; ++row)
        {
            for (uint32 col = 0; col < shape_.cols; ++col)
            {
                if (!utils::essentiallyEqual(operator()(row, col), dtype{ 0 }))
                {
                    rowIndices.push_back(row);
                    colIndices.push_back(col);
                }
            }
        }

        return std::make_pair(NdArray<size_type>(rowIndices), NdArray<size_type>(colIndices));
    }
} // namespace nc

/*** End of inlined file: NdArrayCore.hpp ***/


/*** Start of inlined file: NdArrayOperators.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Operators for the NdArray class
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>
#include <functional>


/*** Start of inlined file: complex.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns a std::complex from the input real and imag components
    ///
    /// @param inReal: the real component of the complex number
    /// @return value
    ///
    template<typename dtype>
    auto complex(dtype inReal)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::complex<dtype>(inReal);
    }

    // Method Description:
    /// Returns a std::complex from the input real and imag components
    ///
    /// @param inReal: the real component of the complex number
    /// @param inImag: the imaginary component of the complex number
    /// @return value
    ///
    template<typename dtype>
    auto complex(dtype inReal, dtype inImag)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::complex<dtype>(inReal, inImag);
    }

    // Method Description:
    /// Returns a std::complex from the input real and imag components
    ///
    /// @param inReal: the real component of the complex number
    /// @return NdArray
    ///
    template<typename dtype>
    auto complex(const NdArray<dtype>& inReal)
    {
        NdArray<decltype(nc::complex(dtype{ 0 }))> returnArray(inReal.shape());
        stl_algorithms::transform(inReal.cbegin(),
                                  inReal.cend(),
                                  returnArray.begin(),
                                  [](dtype real) -> auto { return nc::complex(real); });

        return returnArray;
    }

    // Method Description:
    /// Returns a std::complex from the input real and imag components
    ///
    /// @param inReal: the real component of the complex number
    /// @param inImag: the imaginary component of the complex number
    /// @return NdArray
    ///
    template<typename dtype>
    auto complex(const NdArray<dtype>& inReal, const NdArray<dtype>& inImag)
    {
        if (inReal.shape() != inImag.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("Input real array must be the same shape as input imag array");
        }

        NdArray<decltype(nc::complex(dtype{ 0 }, dtype{ 0 }))> returnArray(inReal.shape());
        stl_algorithms::transform(inReal.cbegin(),
                                  inReal.cend(),
                                  inImag.cbegin(),
                                  returnArray.begin(),
                                  [](dtype real, dtype imag) -> auto { return nc::complex(real, imag); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: complex.hpp ***/


/*** Start of inlined file: NdArrayBroadcast.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Broadcasting for NdArray functions
///
#pragma once

#include <cmath>
#include <utility>

namespace nc::broadcast
{

    // Method Description:
    /// Broadcasting template function for in-place operations
    ///
    /// @param function
    /// @param inArray1
    /// @param inArray2
    /// @param additionalFunctionArgs
    ///
    /// @return NdArray
    ///
    template<typename dtypeIn1, typename dtypeIn2, typename Function, typename... AdditionalFunctionArgs>
    NdArray<dtypeIn1>& broadcaster(NdArray<dtypeIn1>&       inArray1,
                                   const NdArray<dtypeIn2>& inArray2,
                                   const Function&          function,
                                   const AdditionalFunctionArgs&&... additionalFunctionArgs)
    {
        if (inArray1.shape() == inArray2.shape())
        {
            stl_algorithms::transform(
                inArray1.cbegin(),
                inArray1.cend(),
                inArray2.cbegin(),
                inArray1.begin(),
                [&function, &additionalFunctionArgs...](const auto& inValue1, const auto& inValue2) -> dtypeIn1 {
                    return function(inValue1,
                                    inValue2,
                                    std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                });
        }
        else if (inArray2.isscalar())
        {
            const auto value = inArray2.item();
            stl_algorithms::transform(
                inArray1.cbegin(),
                inArray1.cend(),
                inArray1.begin(),
                [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeIn1
                { return function(inValue, value, std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...); });
        }
        else if (inArray2.isflat())
        {
            if (inArray2.numRows() > 1 && inArray2.numRows() == inArray1.numRows())
            {
                for (uint32 row = 0; row < inArray1.numRows(); ++row)
                {
                    const auto value = inArray2[row];
                    stl_algorithms::transform(
                        inArray1.cbegin(row),
                        inArray1.cend(row),
                        inArray1.begin(row),
                        [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeIn1 {
                            return function(inValue,
                                            value,
                                            std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                        });
                }
            }
            else if (inArray2.numCols() > 1 && inArray2.numCols() == inArray1.numCols())
            {
                for (uint32 col = 0; col < inArray1.numCols(); ++col)
                {
                    const auto value = inArray2[col];
                    stl_algorithms::transform(
                        inArray1.ccolbegin(col),
                        inArray1.ccolend(col),
                        inArray1.colbegin(col),
                        [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeIn1 {
                            return function(inValue,
                                            value,
                                            std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                        });
                }
            }
            else
            {
                THROW_INVALID_ARGUMENT_ERROR("operands could not be broadcast together");
            }
        }
        else
        {
            THROW_INVALID_ARGUMENT_ERROR("operands could not be broadcast together");
        }

        return inArray1;
    }

    // Method Description:
    /// Broadcasting template function
    ///
    /// @param function
    /// @param inArray1
    /// @param inArray2
    /// @param additionalFunctionArgs
    ///
    /// @return NdArray
    ///
    template<typename dtypeOut,
             typename dtypeIn1,
             typename dtypeIn2,
             typename Function,
             typename... AdditionalFunctionArgs>
    NdArray<dtypeOut> broadcaster(const NdArray<dtypeIn1>& inArray1,
                                  const NdArray<dtypeIn2>& inArray2,
                                  const Function&          function,
                                  const AdditionalFunctionArgs&&... additionalFunctionArgs)
    {
        if (inArray1.shape() == inArray2.shape())
        {
            return [&inArray1, &inArray2, &function, &additionalFunctionArgs...]
            {
                NdArray<dtypeOut> returnArray(inArray1.shape());
                stl_algorithms::transform(
                    inArray1.cbegin(),
                    inArray1.cend(),
                    inArray2.cbegin(),
                    returnArray.begin(),
                    [&function, &additionalFunctionArgs...](const auto& inValue1, const auto& inValue2) -> dtypeOut {
                        return function(inValue1,
                                        inValue2,
                                        std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                    });

                return returnArray;
            }();
        }
        else if (inArray1.isscalar())
        {
            const auto value = inArray1.item();
            return [&inArray2, &value, &function, &additionalFunctionArgs...]
            {
                NdArray<dtypeOut> returnArray(inArray2.shape());
                stl_algorithms::transform(
                    inArray2.cbegin(),
                    inArray2.cend(),
                    returnArray.begin(),
                    [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeOut {
                        return function(inValue,
                                        value,
                                        std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                    });
                return returnArray;
            }();
        }
        else if (inArray2.isscalar())
        {
            const auto value = inArray2.item();
            return [&inArray1, &value, &function, &additionalFunctionArgs...]
            {
                NdArray<dtypeOut> returnArray(inArray1.shape());
                stl_algorithms::transform(
                    inArray1.cbegin(),
                    inArray1.cend(),
                    returnArray.begin(),
                    [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeOut {
                        return function(inValue,
                                        value,
                                        std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                    });
                return returnArray;
            }();
        }
        else if (inArray1.isflat() && inArray2.isflat())
        {
            return [&inArray1, &inArray2, &function, &additionalFunctionArgs...]
            {
                const auto        numRows = std::max(inArray1.numRows(), inArray2.numRows());
                const auto        numCols = std::max(inArray1.numCols(), inArray2.numCols());
                NdArray<dtypeOut> returnArray(numRows, numCols);
                if (inArray1.numRows() > 1)
                {
                    for (uint32 row = 0; row < inArray1.numRows(); ++row)
                    {
                        for (uint32 col = 0; col < inArray2.numCols(); ++col)
                        {
                            returnArray(row, col) =
                                function(inArray1[row],
                                         inArray2[col],
                                         std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                        }
                    }
                }
                else
                {
                    for (uint32 row = 0; row < inArray2.numRows(); ++row)
                    {
                        for (uint32 col = 0; col < inArray1.numCols(); ++col)
                        {
                            returnArray(row, col) =
                                function(inArray1[col],
                                         inArray2[row],
                                         std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                        }
                    }
                }
                return returnArray;
            }();
        }
        else if (inArray1.isflat())
        {
            return broadcaster<dtypeOut>(inArray2,
                                         inArray1,
                                         function,
                                         std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
        }
        else if (inArray2.isflat())
        {
            if (inArray2.numRows() > 1 && inArray2.numRows() == inArray1.numRows())
            {
                return [&inArray1, &inArray2, &function, &additionalFunctionArgs...]
                {
                    NdArray<dtypeOut> returnArray(inArray1.shape());
                    for (uint32 row = 0; row < inArray1.numRows(); ++row)
                    {
                        const auto value = inArray2[row];
                        stl_algorithms::transform(
                            inArray1.cbegin(row),
                            inArray1.cend(row),
                            returnArray.begin(row),
                            [&value, &function, &additionalFunctionArgs...](const auto& inValue) -> dtypeOut {
                                return function(inValue,
                                                value,
                                                std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...);
                            });
                    }
                    return returnArray;
                }();
            }
            else if (inArray2.numCols() > 1 && inArray2.numCols() == inArray1.numCols())
            {
                return broadcaster<dtypeOut>(inArray1.transpose(),
                                             inArray2.transpose(),
                                             function,
                                             std::forward<AdditionalFunctionArgs>(additionalFunctionArgs)...)
                    .transpose();
            }
            else
            {
                THROW_INVALID_ARGUMENT_ERROR("operands could not be broadcast together");
            }
        }
        else
        {
            THROW_INVALID_ARGUMENT_ERROR("operands could not be broadcast together");
        }

        return {}; // get rid of compiler warning
    }
} // namespace nc::broadcast

/*** End of inlined file: NdArrayBroadcast.hpp ***/

namespace nc
{

    // Method Description:
    /// Adds the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator+=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster(lhs, rhs, std::plus<dtype>());
    }

    // Method Description:
    /// Adds the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator+=(NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const std::complex<dtype>& val1, dtype val2) -> std::complex<dtype>
        { return val1 + val2; };
        return broadcast::broadcaster(lhs, rhs, function);
    }

    // Method Description:
    /// Adds the scalar to the array (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator+=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value += rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator+=(NdArray<std::complex<dtype>>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](std::complex<dtype>& value) -> std::complex<dtype> { return value += rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Adds the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator+(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::plus<dtype>());
    }

    // Method Description:
    /// Adds the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(const NdArray<dtype>& lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 + val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Adds the elements of two arrays (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(const NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        return rhs + lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator+(NdArray<dtype> lhs, dtype rhs)
    {
        lhs += rhs;
        return lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (5)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator+(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs + lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (6)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(const NdArray<dtype>& lhs, const std::complex<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](dtype value) -> std::complex<dtype> { return value + rhs; };

        NdArray<std::complex<dtype>> returnArray(lhs.shape());

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Adds the scalar to the array (7)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(const std::complex<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        return rhs + lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (8)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(NdArray<std::complex<dtype>> lhs, dtype rhs)
    {
        lhs += rhs;
        return lhs;
    }

    // Method Description:
    /// Adds the scalar to the array (9)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator+(dtype lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        return rhs + lhs;
    }

    // Method Description:
    /// Subtracts the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator-=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster(lhs, rhs, std::minus<dtype>());
    }

    // Method Description:
    /// Subtracts the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator-=(NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const std::complex<dtype>& val1, dtype val2) -> std::complex<dtype>
        { return val1 - val2; };
        return broadcast::broadcaster(lhs, rhs, function);
    }

    // Method Description:
    /// Subtracts the scalar from the array (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator-=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value -= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Subtracts the scalar from the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator-=(NdArray<std::complex<dtype>>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](std::complex<dtype>& value) -> std::complex<dtype> { return value -= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Subtracts the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator-(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::minus<dtype>());
    }

    // Method Description:
    /// Subtracts the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(const NdArray<dtype>& lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 - val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Subtracts the elements of two arrays (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(const NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 - val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Subtracts the scalar from the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator-(NdArray<dtype> lhs, dtype rhs)
    {
        lhs -= rhs;
        return lhs;
    }

    // Method Description:
    /// Subtracts the scalar from the array (5)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator-(dtype lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [lhs](dtype value) -> dtype { return lhs - value; };

        NdArray<dtype> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Subtracts the scalar from the array (6)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(const NdArray<dtype>& lhs, const std::complex<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](dtype value) -> std::complex<dtype> { return value - rhs; };

        NdArray<std::complex<dtype>> returnArray(lhs.shape());

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Subtracts the scalar from the array (7)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(const std::complex<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [lhs](dtype value) -> std::complex<dtype> { return lhs - value; };

        NdArray<std::complex<dtype>> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Subtracts the scalar from the array (8)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(NdArray<std::complex<dtype>> lhs, dtype rhs)
    {
        lhs -= rhs;
        return lhs;
    }

    // Method Description:
    /// Subtracts the scalar from the array (9)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator-(dtype lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [lhs](std::complex<dtype> value) -> std::complex<dtype> { return lhs - value; };

        NdArray<std::complex<dtype>> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Negative Operator
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator-(const NdArray<dtype>& inArray)
    {
        const auto function = [](dtype value) -> dtype { return -value; };

        auto returnArray = NdArray<dtype>(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);
        return returnArray;
    }

    // Method Description:
    /// Multiplies the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator*=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster(lhs, rhs, std::multiplies<dtype>());
    }

    // Method Description:
    /// Multiplies the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator*=(NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const std::complex<dtype>& val1, dtype val2) -> std::complex<dtype>
        { return val1 * val2; };
        return broadcast::broadcaster(lhs, rhs, function);
    }

    // Method Description:
    /// Multiplies the scalar to the array (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator*=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value *= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator*=(NdArray<std::complex<dtype>>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](std::complex<dtype>& value) -> std::complex<dtype> { return value *= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Multiplies the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator*(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::multiplies<dtype>());
    }

    // Method Description:
    /// Multiplies the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(const NdArray<dtype>& lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 * val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Multiplies the elements of two arrays (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(const NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        return rhs * lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator*(NdArray<dtype> lhs, dtype rhs)
    {
        lhs *= rhs;
        return lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (5)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator*(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs * lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (6)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(const NdArray<dtype>& lhs, const std::complex<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](dtype value) -> std::complex<dtype> { return value * rhs; };

        NdArray<std::complex<dtype>> returnArray(lhs.shape());

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Multiplies the scalar to the array (7)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(const std::complex<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        return rhs * lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (8)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(NdArray<std::complex<dtype>> lhs, dtype rhs)
    {
        lhs *= rhs;
        return lhs;
    }

    // Method Description:
    /// Multiplies the scalar to the array (9)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator*(dtype lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        return rhs * lhs;
    }

    // Method Description:
    /// Divides the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator/=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster(lhs, rhs, std::divides<dtype>());
    }

    // Method Description:
    /// Divides the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator/=(NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const std::complex<dtype>& val1, dtype val2) -> std::complex<dtype>
        { return val1 / val2; };
        return broadcast::broadcaster(lhs, rhs, function);
    }

    // Method Description:
    /// Divides the scalar from the array (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator/=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value /= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Divides the scalar from the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>>& operator/=(NdArray<std::complex<dtype>>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](std::complex<dtype>& value) -> std::complex<dtype> { return value /= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Divides the elements of two arrays (1)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator/(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::divides<dtype>());
    }

    // Method Description:
    /// Divides the elements of two arrays (2)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(const NdArray<dtype>& lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 / val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Divides the elements of two arrays (3)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(const NdArray<std::complex<dtype>>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](const auto& val1, const auto& val2) -> std::complex<dtype> { return val1 / val2; };
        return broadcast::broadcaster<std::complex<dtype>>(lhs, rhs, function);
    }

    // Method Description:
    /// Divides the scalar from the array (4)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator/(NdArray<dtype> lhs, dtype rhs)
    {
        lhs /= rhs;
        return lhs;
    }

    // Method Description:
    /// Divides the scalar from the array (5)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator/(dtype lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [lhs](dtype value) -> dtype { return lhs / value; };

        NdArray<dtype> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Divides the scalar from the array (6)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(const NdArray<dtype>& lhs, const std::complex<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [rhs](dtype value) -> std::complex<dtype> { return value / rhs; };

        NdArray<std::complex<dtype>> returnArray(lhs.shape());

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Divides the scalar from the array (7)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(const std::complex<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [lhs](dtype value) -> std::complex<dtype> { return lhs / value; };

        NdArray<std::complex<dtype>> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Divides the scalar from the array (8)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(NdArray<std::complex<dtype>> lhs, dtype rhs)
    {
        lhs /= rhs;
        return lhs;
    }

    // Method Description:
    /// Divides the scalar from the array (9)
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> operator/(dtype lhs, const NdArray<std::complex<dtype>>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [lhs](const std::complex<dtype>& value) -> std::complex<dtype> { return lhs / value; };

        NdArray<std::complex<dtype>> returnArray(rhs.shape());

        stl_algorithms::transform(rhs.cbegin(), rhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Modulus the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype> || std::is_floating_point_v<dtype>, int> = 0>
    NdArray<dtype>& operator%=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        if constexpr (std::is_integral_v<dtype>)
        {
            return broadcast::broadcaster(lhs, rhs, std::modulus<dtype>());
        }
        else
        {
            const auto function = [](const dtype value1, const dtype value2) -> dtype
            { return std::fmod(value1, value2); };
            return broadcast::broadcaster(lhs, rhs, function);
        }
    }

    // Method Description:
    /// Modulus the scalar to the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype> || std::is_floating_point_v<dtype>, int> = 0>
    NdArray<dtype>& operator%=(NdArray<dtype>& lhs, dtype rhs)
    {
        if constexpr (std::is_integral_v<dtype>)
        {
            const auto function = [rhs](dtype& value) -> dtype { return value %= rhs; };
            stl_algorithms::for_each(lhs.begin(), lhs.end(), function);
        }
        else
        {
            const auto function = [rhs](dtype& value) -> void { value = std::fmod(value, rhs); };
            stl_algorithms::for_each(lhs.begin(), lhs.end(), function);
        }

        return lhs;
    }

    // Method Description:
    /// Takes the modulus of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype> || std::is_floating_point_v<dtype>, int> = 0>
    NdArray<dtype> operator%(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        if constexpr (std::is_integral_v<dtype>)
        {
            return broadcast::broadcaster<dtype>(lhs, rhs, std::modulus<dtype>());
        }
        else
        {
            const auto function = [](dtype value1, dtype value2) -> dtype { return std::fmod(value1, value2); };
            return broadcast::broadcaster<dtype>(lhs, rhs, function);
        }
    }

    // Method Description:
    /// Modulus of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator%(NdArray<dtype> lhs, dtype rhs)
    {
        lhs %= rhs;
        return lhs;
    }

    // Method Description:
    /// Modulus of the scalar and the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype>, int> = 0>
    NdArray<dtype> operator%(dtype lhs, const NdArray<dtype>& rhs)
    {
        NdArray<dtype> returnArray(rhs.shape());
        stl_algorithms::transform(rhs.begin(),
                                  rhs.end(),
                                  returnArray.begin(),
                                  [lhs](dtype value) -> dtype { return lhs % value; });

        return returnArray;
    }

    // Method Description:
    /// Modulus of the scalar and the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point_v<dtype>, int> = 0>
    NdArray<dtype> operator%(dtype lhs, const NdArray<dtype>& rhs)
    {
        NdArray<dtype> returnArray(rhs.shape());
        stl_algorithms::transform(rhs.begin(),
                                  rhs.end(),
                                  returnArray.begin(),
                                  [lhs](dtype value) -> dtype { return std::fmod(lhs, value); });

        return returnArray;
    }

    // Method Description:
    /// Bitwise or the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator|=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster(lhs, rhs, std::bit_or<dtype>());
    }

    // Method Description:
    /// Bitwise or the scalar to the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator|=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value |= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Takes the bitwise or of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator|(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::bit_or<dtype>());
    }

    // Method Description:
    /// Takes the bitwise or of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator|(NdArray<dtype> lhs, dtype rhs)
    {
        lhs |= rhs;
        return lhs;
    }

    // Method Description:
    /// Takes the bitwise or of the sclar and the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator|(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs | lhs;
    }

    // Method Description:
    /// Bitwise and the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator&=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster(lhs, rhs, std::bit_and<dtype>());
    }

    // Method Description:
    /// Bitwise and the scalar to the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator&=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value &= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Takes the bitwise and of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator&(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::bit_and<dtype>());
    }

    // Method Description:
    /// Takes the bitwise and of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator&(NdArray<dtype> lhs, dtype rhs)
    {
        lhs &= rhs;
        return lhs;
    }

    // Method Description:
    /// Takes the bitwise and of the sclar and the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator&(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs & lhs;
    }

    // Method Description:
    /// Bitwise xor the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator^=(NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster(lhs, rhs, std::bit_xor<dtype>());
    }

    // Method Description:
    /// Bitwise xor the scalar to the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator^=(NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [rhs](dtype& value) -> dtype { return value ^= rhs; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Takes the bitwise xor of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator^(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return broadcast::broadcaster<dtype>(lhs, rhs, std::bit_xor<dtype>());
    }

    // Method Description:
    /// Takes the bitwise xor of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator^(NdArray<dtype> lhs, dtype rhs)
    {
        lhs ^= rhs;
        return lhs;
    }

    // Method Description:
    /// Takes the bitwise xor of the sclar and the array
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator^(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs ^ lhs;
    }

    // Method Description:
    /// Takes the bitwise not of the array
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator~(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [](dtype value) -> dtype { return ~value; };

        NdArray<dtype> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Takes the and of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator&&(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](dtype value1, dtype value2) -> bool
        { return !utils::essentiallyEqual(value1, dtype{ 0 }) && !utils::essentiallyEqual(value2, dtype{ 0 }); };

        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Takes the and of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator&&(const NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [rhs](dtype value) -> bool { return value && rhs; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Takes the and of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator&&(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs && lhs;
    }

    // Method Description:
    /// Takes the or of the elements of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator||(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](dtype value1, dtype value2) -> bool
        { return !utils::essentiallyEqual(value1, dtype{ 0 }) || !utils::essentiallyEqual(value2, dtype{ 0 }); };

        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Takes the or of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator||(const NdArray<dtype>& lhs, dtype rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [rhs](dtype value) -> bool { return value || rhs; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Takes the or of the array and the scalar
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator||(dtype lhs, const NdArray<dtype>& rhs)
    {
        return rhs || lhs;
    }

    // Method Description:
    /// Takes the not of the array
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator!(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<bool> returnArray(inArray.shape());

        const auto function = [](dtype value) -> dtype { return !value; };

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator==(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        const auto equalTo = [](dtype lhs_, dtype rhs_) noexcept -> bool
        { return utils::essentiallyEqual(lhs_, rhs_); };

        return broadcast::broadcaster<bool>(lhs, rhs, equalTo);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// an array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator==(const NdArray<dtype>& lhs, dtype inValue)
    {
        NdArray<bool> returnArray(lhs.shape());

        const auto equalTo = [inValue](dtype value) noexcept -> bool
        { return utils::essentiallyEqual(inValue, value); };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), equalTo);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// an array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator==(dtype inValue, const NdArray<dtype>& inArray)
    {
        return inArray == inValue;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator!=(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        const auto notEqualTo = [](dtype lhs_, dtype rhs_) noexcept -> bool
        { return !utils::essentiallyEqual(lhs_, rhs_); };

        return broadcast::broadcaster<bool>(lhs, rhs, notEqualTo);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// an array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator!=(const NdArray<dtype>& lhs, dtype inValue)
    {
        NdArray<bool> returnArray(lhs.shape());

        const auto notEqualTo = [inValue](dtype value) noexcept -> bool
        { return !utils::essentiallyEqual(inValue, value); };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), notEqualTo);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// an array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator!=(dtype inValue, const NdArray<dtype>& inArray)
    {
        return inArray != inValue;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [](dtype lhs_, dtype rhs_) noexcept -> bool { return lhs_ < rhs_; };
        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<(const NdArray<dtype>& lhs, dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return value < inValue; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<(dtype inValue, const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(inArray.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return inValue < value; };

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [](dtype lhs_, dtype rhs_) noexcept -> bool { return lhs_ > rhs_; };
        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>(const NdArray<dtype>& lhs, dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return value > inValue; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>(dtype inValue, const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(inArray.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return inValue > value; };

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<=(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [](dtype lhs_, dtype rhs_) noexcept -> bool { return lhs_ <= rhs_; };
        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<=(const NdArray<dtype>& lhs, dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return value <= inValue; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator<=(dtype inValue, const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(inArray.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return inValue <= value; };

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// of two arrays
    ///
    /// @param lhs
    /// @param rhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>=(const NdArray<dtype>& lhs, const NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto function = [](dtype lhs_, dtype rhs_) noexcept -> bool { return lhs_ >= rhs_; };
        return broadcast::broadcaster<bool>(lhs, rhs, function);
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param lhs
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>=(const NdArray<dtype>& lhs, dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(lhs.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return value >= inValue; };

        stl_algorithms::transform(lhs.cbegin(), lhs.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Returns an array of booleans of element wise comparison
    /// the array and a scalar
    ///
    /// @param inValue
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> operator>=(dtype inValue, const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(inArray.shape());

        const auto function = [inValue](dtype value) noexcept -> bool { return inValue >= value; };

        stl_algorithms::transform(inArray.cbegin(), inArray.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Bitshifts left the elements of the array
    ///
    /// @param lhs
    /// @param inNumBits
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator<<=(NdArray<dtype>& lhs, uint8 inNumBits)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [inNumBits](dtype& value) -> void { value <<= inNumBits; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Bitshifts left the elements of the array
    ///
    /// @param lhs
    /// @param inNumBits
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator<<(const NdArray<dtype>& lhs, uint8 inNumBits)
    {
        STATIC_ASSERT_INTEGER(dtype);

        NdArray<dtype> returnArray(lhs);
        returnArray <<= inNumBits;
        return returnArray;
    }

    // Method Description:
    /// Bitshifts right the elements of the array
    ///
    /// @param lhs
    /// @param inNumBits
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator>>=(NdArray<dtype>& lhs, uint8 inNumBits)
    {
        STATIC_ASSERT_INTEGER(dtype);

        const auto function = [inNumBits](dtype& value) -> void { value >>= inNumBits; };

        stl_algorithms::for_each(lhs.begin(), lhs.end(), function);

        return lhs;
    }

    // Method Description:
    /// Bitshifts right the elements of the array
    ///
    /// @param lhs
    /// @param inNumBits
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator>>(const NdArray<dtype>& lhs, uint8 inNumBits)
    {
        STATIC_ASSERT_INTEGER(dtype);

        NdArray<dtype> returnArray(lhs);
        returnArray >>= inNumBits;
        return returnArray;
    }

    // Method Description:
    /// prefix incraments the elements of an array
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator++(NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](dtype& value) -> void { ++value; };

        stl_algorithms::for_each(rhs.begin(), rhs.end(), function);

        return rhs;
    }

    // Method Description:
    /// postfix increments the elements of an array
    ///
    /// @param lhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator++(NdArray<dtype>& lhs, int)
    {
        auto copy = NdArray<dtype>(lhs);
        ++lhs;
        return copy;
    }

    // Method Description:
    /// prefix decrements the elements of an array
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& operator--(NdArray<dtype>& rhs)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto function = [](dtype& value) -> void { --value; };

        stl_algorithms::for_each(rhs.begin(), rhs.end(), function);

        return rhs;
    }

    // Method Description:
    /// postfix decrements the elements of an array
    ///
    /// @param lhs
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> operator--(NdArray<dtype>& lhs, int)
    {
        auto copy = NdArray<dtype>(lhs);
        --lhs;
        return copy;
    }

    // Method Description:
    /// io operator for the NdArray class
    ///
    /// @param inOStream
    /// @param inArray
    /// @return std::ostream
    ///
    template<typename dtype>
    std::ostream& operator<<(std::ostream& inOStream, const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        inOStream << inArray.str();
        return inOStream;
    }
} // namespace nc

/*** End of inlined file: NdArrayOperators.hpp ***/

/*** End of inlined file: NdArray.hpp ***/


/*** Start of inlined file: Vec2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Simple 2D Vector class
///
#pragma once

#include <cmath>
#include <initializer_list>
#include <iostream>
#include <sstream>
#include <string>


/*** Start of inlined file: interp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Returns the linear interpolation between two points
///
#pragma once

namespace nc::utils
{

    /// Returns the linear interpolation between two points
    ///
    /// @param inValue1
    /// @param inValue2
    /// @param inPercent
    ///
    /// @return linear interpolated point
    ///
    constexpr double interp(double inValue1, double inValue2, double inPercent) noexcept
    {
        return inValue1 * (1. - inPercent) + inValue2 * inPercent;
    }
} // namespace nc::utils

/*** End of inlined file: interp.hpp ***/

namespace nc
{

    // Class Description:
    /// Holds a 2D vector
    class Vec2
    {
    public:
        //====================================Attributes==============================
        double x{ 0. };
        double y{ 0. };

        // Method Description:
        /// Default Constructor
        ///
        constexpr Vec2() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param inX: the x component
        /// @param inY: the y component
        ///
        constexpr Vec2(double inX, double inY) noexcept :
            x(inX),
            y(inY)
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inList
        ///
        Vec2(const std::initializer_list<double>& inList)
        {
            if (inList.size() != 2)
            {
                THROW_INVALID_ARGUMENT_ERROR("input initializer list must have a size = 2");
            }

            x = *inList.begin();
            y = *(inList.begin() + 1);
        }

        // Method Description:
        /// Constructor
        ///
        /// @param ndArray
        ///
        Vec2(const NdArray<double>& ndArray)
        {
            if (ndArray.size() != 2)
            {
                THROW_INVALID_ARGUMENT_ERROR("input NdArray must have a size = 2");
            }

            x = ndArray[0];
            y = ndArray[1];
        }

        // Method Description:
        /// Returns the angle between the two vectors
        ///
        /// @param otherVec
        /// @return the angle in radians
        ///
        [[nodiscard]] double angle(const Vec2& otherVec) const noexcept
        {
            double dotProduct = dot(otherVec);
            dotProduct /= norm();
            dotProduct /= otherVec.norm();

            // clamp the value to the acos range just to be safe
            dotProduct = std::max(std::min(dotProduct, 1.), -1.);

            return std::acos(dotProduct);
        }

        // Method Description:
        /// Returns a copy of the vector with its magnitude clamped
        /// to maxLength
        ///
        /// @param maxLength
        /// @return Vec2
        ///
        [[nodiscard]] Vec2 clampMagnitude(double maxLength) const noexcept
        {
            const double magnitude = norm();
            if (magnitude <= maxLength)
            {
                return *this;
            }

            Vec2 returnVec = Vec2(*this).normalize();
            returnVec *= maxLength;
            return returnVec;
        }

        // Method Description:
        /// Returns the distance between the two vectors
        ///
        /// @param otherVec
        /// @return the distance (equivalent to (a - b).norm()
        ///
        [[nodiscard]] double distance(const Vec2& otherVec) const noexcept
        {
            return (Vec2(*this) -= otherVec).norm();
        }

        // Method Description:
        /// Returns the dot product of the two vectors
        ///
        /// @param otherVec
        /// @return the dot product
        ///
        [[nodiscard]] double dot(const Vec2& otherVec) const noexcept
        {
            return x * otherVec.x + y * otherVec.y;
        }

        // Method Description:
        /// Returns the unit vector [0, -1]
        ///
        /// @return Vec2
        ///
        static constexpr Vec2 down() noexcept
        {
            return Vec2(0., -1.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the unit vector [-1, 0]
        ///
        /// @return Vec2
        ///
        static constexpr Vec2 left() noexcept
        {
            return Vec2(-1., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Linearly interpolates between two vectors
        ///
        /// @param otherVec
        /// @param t the amount to interpolate by (clamped from [0, 1]);
        /// @return Vec2
        ///
        [[nodiscard]] Vec2 lerp(const Vec2& otherVec, double t) const noexcept
        {
            t = std::max(std::min(t, 1.), 0.);

            Vec2 trajectory = otherVec;
            trajectory -= *this;
            const double xInterp = utils::interp(0., trajectory.x, t);
            const double yInterp = utils::interp(0., trajectory.y, t);

            return Vec2(*this) += Vec2(xInterp, yInterp);
        }

        // Method Description:
        /// Returns the magnitude of the vector
        ///
        /// @return magnitude of the vector
        ///
        [[nodiscard]] double norm() const noexcept
        {
            return std::hypot(x, y);
        }

        // Method Description:
        /// Returns a new normalized Vec2
        ///
        /// @return Vec2
        ///
        [[nodiscard]] Vec2 normalize() const noexcept
        {
            return Vec2(*this) /= norm();
        }

        // Method Description:
        /// Projects the vector onto the input vector
        ///
        /// @param otherVec
        /// @return Vec2
        ///
        [[nodiscard]] Vec2 project(const Vec2& otherVec) const noexcept
        {
            const double projectedMagnitude = norm() * std::cos(angle(otherVec));
            return otherVec.normalize() *= projectedMagnitude;
        }

        // Method Description:
        /// Returns the unit vector [1, 0]
        ///
        /// @return Vec2
        ///
        static constexpr Vec2 right() noexcept
        {
            return Vec2(1., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the Vec2 as a string
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string toString() const
        {
            std::stringstream stream;
            stream << "Vec2[" << x << ", " << y << "]";
            return stream.str();
        }

        // Method Description:
        /// Returns the Vec2 as an NdArray
        ///
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<double> toNdArray() const
        {
            NdArray<double> returnArray = { x, y };
            return returnArray.transpose();
        }

        // Method Description:
        /// Returns the unit vector [0, 1]
        ///
        /// @return Vec2
        ///
        static constexpr Vec2 up() noexcept
        {
            return Vec2(0., 1.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator==(const Vec2& rhs) const noexcept
        {
            return utils::essentiallyEqual(x, rhs.x) && utils::essentiallyEqual(y, rhs.y);
        }

        // Method Description:
        /// Not Equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator!=(const Vec2& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Method Description:
        /// Adds the scalar to the vector
        ///
        /// @param scalar
        /// @return Vec2
        ///
        Vec2& operator+=(double scalar) noexcept
        {
            x += scalar;
            y += scalar;
            return *this;
        }

        // Method Description:
        /// Adds the two vectors
        ///
        /// @param rhs
        /// @return Vec2
        ///
        Vec2& operator+=(const Vec2& rhs) noexcept
        {
            x += rhs.x;
            y += rhs.y;
            return *this;
        }

        // Method Description:
        /// Subtracts the scalar from the vector
        ///
        /// @param scalar
        /// @return Vec2
        ///
        Vec2& operator-=(double scalar) noexcept
        {
            x -= scalar;
            y -= scalar;
            return *this;
        }

        // Method Description:
        /// Subtracts the two vectors
        ///
        /// @param rhs
        /// @return Vec2
        ///
        Vec2& operator-=(const Vec2& rhs) noexcept
        {
            x -= rhs.x;
            y -= rhs.y;
            return *this;
        }

        // Method Description:
        /// Scalar mulitplication
        ///
        /// @param scalar
        /// @return Vec2
        ///
        Vec2& operator*=(double scalar) noexcept
        {
            x *= scalar;
            y *= scalar;
            return *this;
        }

        // Method Description:
        /// Scalar division
        ///
        /// @param scalar
        /// @return Vec2
        ///
        Vec2& operator/=(double scalar) noexcept
        {
            x /= scalar;
            y /= scalar;
            return *this;
        }
    };

    // Method Description:
    /// Adds the scalar to the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator+(const Vec2& lhs, double rhs) noexcept
    {
        return Vec2(lhs) += rhs;
    }

    // Method Description:
    /// Adds the scalar to the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator+(double lhs, const Vec2& rhs) noexcept
    {
        return Vec2(rhs) += lhs;
    }

    // Method Description:
    /// Adds the two vectors
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator+(const Vec2& lhs, const Vec2& rhs) noexcept
    {
        return Vec2(lhs) += rhs;
    }

    // Method Description:
    /// Returns the negative vector
    ///
    /// @return Vec2
    ///
    inline Vec2 operator-(const Vec2& vec) noexcept
    {
        return Vec2(-vec.x, -vec.y); // NOLINT(modernize-return-braced-init-list)
    }

    // Method Description:
    /// Subtracts the scalar from the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator-(const Vec2& lhs, double rhs) noexcept
    {
        return Vec2(lhs) -= rhs;
    }

    // Method Description:
    /// Subtracts the scalar from the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator-(double lhs, const Vec2& rhs) noexcept
    {
        return -Vec2(rhs) += lhs;
    }

    // Method Description:
    /// Subtracts the two vectors
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator-(const Vec2& lhs, const Vec2& rhs) noexcept
    {
        return Vec2(lhs) -= rhs;
    }

    // Method Description:
    /// Scalar mulitplication
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator*(const Vec2& lhs, double rhs) noexcept
    {
        return Vec2(lhs) *= rhs;
    }

    // Method Description:
    /// Scalar mulitplication
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator*(double lhs, const Vec2& rhs) noexcept
    {
        return Vec2(rhs) *= lhs;
    }

    // Method Description:
    /// Vector mulitplication (dot product)
    ///
    /// @param lhs
    /// @param rhs
    /// @return dot product
    ///
    ///
    inline double operator*(const Vec2& lhs, const Vec2& rhs) noexcept
    {
        return lhs.dot(rhs);
    }

    // Method Description:
    /// Scalar division
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec2
    ///
    inline Vec2 operator/(const Vec2& lhs, double rhs) noexcept
    {
        return Vec2(lhs) /= rhs;
    }

    // Method Description:
    /// stream output operator
    ///
    /// @param stream
    /// @param vec
    /// @return std::ostream
    ///
    inline std::ostream& operator<<(std::ostream& stream, const Vec2& vec)
    {
        stream << vec.toString() << std::endl;
        return stream;
    }
} // namespace nc

/*** End of inlined file: Vec2.hpp ***/


/*** Start of inlined file: Vec3.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Simple 3D Vector class
///
#pragma once

#include <cmath>
#include <initializer_list>
#include <iostream>
#include <sstream>
#include <string>


/*** Start of inlined file: hypot.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Given the "legs" of a right triangle, return its hypotenuse.
    ///
    /// Equivalent to sqrt(x1**2 + x2**2), element - wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hypot.html
    ///
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return value
    ///
    template<typename dtype>
    double hypot(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::hypot(static_cast<double>(inValue1), static_cast<double>(inValue2));
    }

    // Method Description:
    /// Given the "legs" of a right triangle, return its hypotenuse.
    ///
    /// Equivalent to sqrt(x1**2 + x2**2 + x3**2), element - wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hypot.html
    ///
    ///
    /// @param inValue1
    /// @param inValue2
    /// @param inValue3
    ///
    /// @return value
    ///
    template<typename dtype>
    double hypot(dtype inValue1, dtype inValue2, dtype inValue3) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_hypot
        return std::hypot(static_cast<double>(inValue1), static_cast<double>(inValue2), static_cast<double>(inValue3));
#else
        return std::sqrt(utils::sqr(static_cast<double>(inValue1)) + utils::sqr(static_cast<double>(inValue2)) +
                         utils::sqr(static_cast<double>(inValue3)));
#endif
    }

    // Method Description:
    /// Given the "legs" of a right triangle, return its hypotenuse.
    ///
    /// Equivalent to sqrt(x1**2 + x2**2), element - wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hypot.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> hypot(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return broadcast::broadcaster<double>(inArray1,
                                              inArray2,
                                              [](dtype inValue1, dtype inValue2) noexcept -> double
                                              { return hypot(inValue1, inValue2); });
    }

    // Method Description:
    /// Given the "legs" of a right triangle, return its hypotenuse.
    ///
    /// Equivalent to sqrt(x1**2 + x2**2), element - wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hypot.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    /// @param inArray3
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double>
        hypot(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2, const NdArray<dtype>& inArray3)
    {
        if (inArray1.size() != inArray2.size() || inArray1.size() != inArray3.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array sizes are not consistant.");
        }

        NdArray<double> returnArray(inArray1.shape());
        for (typename NdArray<dtype>::size_type i = 0; i < inArray1.size(); ++i)
        {
            returnArray[i] = hypot(inArray1[i], inArray2[i], inArray3[i]);
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: hypot.hpp ***/

namespace nc
{

    // Class Description:
    /// Holds a 3D vector
    class Vec3
    {
    public:
        //====================================Attributes==============================
        double x{ 0. };
        double y{ 0. };
        double z{ 0. };

        // Method Description:
        /// Default Constructor
        ///
        constexpr Vec3() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param inX: the x component
        /// @param inY: the y component
        /// @param inZ: the y component
        ///
        constexpr Vec3(double inX, double inY, double inZ) noexcept :
            x(inX),
            y(inY),
            z(inZ)
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inList
        ///
        Vec3(const std::initializer_list<double>& inList)
        {
            if (inList.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("input initializer list must have a size = 3");
            }

            x = *inList.begin();
            y = *(inList.begin() + 1);
            z = *(inList.begin() + 2);
        }

        // Method Description:
        /// Constructor
        ///
        /// @param vec2: 2d vector
        ///
        constexpr Vec3(const Vec2& vec2) noexcept :
            x(vec2.x),
            y(vec2.y)
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param ndArray
        ///
        Vec3(const NdArray<double>& ndArray)
        {
            if (ndArray.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("input NdArray must have a size = 3");
            }

            x = ndArray[0];
            y = ndArray[1];
            z = ndArray[2];
        }

        // Method Description:
        /// Returns the angle between the two vectors
        ///
        /// @param otherVec
        /// @return the angle in radians
        ///
        [[nodiscard]] double angle(const Vec3& otherVec) const noexcept
        {
            double dotProduct = dot(otherVec);
            dotProduct /= norm();
            dotProduct /= otherVec.norm();

            // clamp the value to the acos range just to be safe
            dotProduct = std::max(std::min(dotProduct, 1.), -1.);

            return std::acos(dotProduct);
        }

        // Method Description:
        /// Returns the unit vector [0, 0, -1]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 back() noexcept
        {
            return Vec3(0., 0., -1.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns a copy of the vector with its magnitude clamped
        /// to maxLength
        ///
        /// @param maxLength
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 clampMagnitude(double maxLength) const noexcept
        {
            const double magnitude = norm();
            if (magnitude <= maxLength)
            {
                return *this;
            }

            Vec3 returnVec = Vec3(*this).normalize();
            returnVec *= maxLength;
            return returnVec;
        }

        // Method Description:
        /// Returns the cross product of the two vectors
        ///
        /// @param otherVec
        /// @return the dot product
        ///
        [[nodiscard]] Vec3 cross(const Vec3& otherVec) const noexcept
        {
            const double crossX = y * otherVec.z - z * otherVec.y;
            const double crossY = -(x * otherVec.z - z * otherVec.x);
            const double crossZ = x * otherVec.y - y * otherVec.x;

            return Vec3(crossX, crossY, crossZ); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the distance between the two vectors
        ///
        /// @param otherVec
        /// @return the distance (equivalent to (a - b).norm()
        ///
        [[nodiscard]] double distance(const Vec3& otherVec) const noexcept
        {
            return (Vec3(*this) -= otherVec).norm();
        }

        // Method Description:
        /// Returns the dot product of the two vectors
        ///
        /// @param otherVec
        /// @return the dot product
        ///
        [[nodiscard]] double dot(const Vec3& otherVec) const noexcept
        {
            return x * otherVec.x + y * otherVec.y + z * otherVec.z;
        }

        // Method Description:
        /// Returns the unit vector [0, -1, 0]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 down() noexcept
        {
            return Vec3(0., -1., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the unit vector [0, 0, 1]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 forward() noexcept
        {
            return Vec3(0., 0., 1.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the unit vector [-1, 0, 0]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 left() noexcept
        {
            return Vec3(-1., 0., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Linearly interpolates between two vectors
        ///
        /// @param otherVec
        /// @param t the amount to interpolate by (clamped from [0, 1]);
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 lerp(const Vec3& otherVec, double t) const noexcept
        {
            t = std::max(std::min(t, 1.), 0.);

            Vec3 trajectory = otherVec;
            trajectory -= *this;
            const double xInterp = utils::interp(0., trajectory.x, t);
            const double yInterp = utils::interp(0., trajectory.y, t);
            const double zInterp = utils::interp(0., trajectory.z, t);

            return Vec3(*this) += Vec3(xInterp, yInterp, zInterp);
        }

        // Method Description:
        /// Returns the magnitude of the vector
        ///
        /// @return magnitude of the vector
        ///
        [[nodiscard]] double norm() const noexcept
        {
            return hypot(x, y, z);
        }

        // Method Description:
        /// Returns a new normalized Vec3
        ///
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 normalize() const noexcept
        {
            return Vec3(*this) /= norm();
        }

        // Method Description:
        /// Projects the vector onto the input vector
        ///
        /// @param otherVec
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 project(const Vec3& otherVec) const noexcept
        {
            const double projectedMagnitude = norm() * std::cos(angle(otherVec));
            return otherVec.normalize() *= projectedMagnitude;
        }

        // Method Description:
        /// Returns the unit vector [1, 0, 0]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 right() noexcept
        {
            return Vec3(1., 0., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the Vec3 as a string
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string toString() const
        {
            std::stringstream stream;
            stream << "Vec3[" << x << ", " << y << ", " << z << "]";
            return stream.str();
        }

        // Method Description:
        /// Returns the Vec2 as an NdArray
        ///
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<double> toNdArray() const
        {
            NdArray<double> returnArray = { x, y, z };
            return returnArray.transpose();
        }

        // Method Description:
        /// Returns the unit vector [0, 1, 0]
        ///
        /// @return Vec3
        ///
        static constexpr Vec3 up() noexcept
        {
            return Vec3(0., 1., 0.); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator==(const Vec3& rhs) const noexcept
        {
            return utils::essentiallyEqual(x, rhs.x) && utils::essentiallyEqual(y, rhs.y) &&
                   utils::essentiallyEqual(z, rhs.z);
        }

        // Method Description:
        /// Not Equality operator
        ///
        /// @param rhs
        /// @return bool
        ///
        bool operator!=(const Vec3& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Method Description:
        /// Adds the scalar to the vector
        ///
        /// @param scalar
        /// @return Vec3
        ///
        Vec3& operator+=(double scalar) noexcept
        {
            x += scalar;
            y += scalar;
            z += scalar;
            return *this;
        }

        // Method Description:
        /// Adds the two vectors
        ///
        /// @param rhs
        /// @return Vec3
        ///
        Vec3& operator+=(const Vec3& rhs) noexcept
        {
            x += rhs.x;
            y += rhs.y;
            z += rhs.z;
            return *this;
        }

        // Method Description:
        /// Subtracts the scalar from the vector
        ///
        /// @param scalar
        /// @return Vec3
        ///
        Vec3& operator-=(double scalar) noexcept
        {
            x -= scalar;
            y -= scalar;
            z -= scalar;
            return *this;
        }

        // Method Description:
        /// Subtracts the two vectors
        ///
        /// @param rhs
        /// @return Vec3
        ///
        Vec3& operator-=(const Vec3& rhs) noexcept
        {
            x -= rhs.x;
            y -= rhs.y;
            z -= rhs.z;
            return *this;
        }

        // Method Description:
        /// Scalar mulitplication
        ///
        /// @param scalar
        /// @return Vec3
        ///
        Vec3& operator*=(double scalar) noexcept
        {
            x *= scalar;
            y *= scalar;
            z *= scalar;
            return *this;
        }

        // Method Description:
        /// Scalar division
        ///
        /// @param scalar
        /// @return Vec3
        ///
        Vec3& operator/=(double scalar) noexcept
        {
            x /= scalar;
            y /= scalar;
            z /= scalar;
            return *this;
        }
    };

    // Method Description:
    /// Adds the scalar to the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator+(const Vec3& lhs, double rhs) noexcept
    {
        return Vec3(lhs) += rhs;
    }

    // Method Description:
    /// Adds the scalar to the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator+(double lhs, const Vec3& rhs) noexcept
    {
        return Vec3(rhs) += lhs;
    }

    // Method Description:
    /// Adds the two vectors
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator+(const Vec3& lhs, const Vec3& rhs) noexcept
    {
        return Vec3(lhs) += rhs;
    }

    // Method Description:
    /// Returns the negative vector
    ///
    /// @return Vec3
    ///
    inline Vec3 operator-(const Vec3& vec) noexcept
    {
        return Vec3(-vec.x, -vec.y, -vec.z); // NOLINT(modernize-return-braced-init-list)
    }

    // Method Description:
    /// Subtracts the scalar from the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator-(const Vec3& lhs, double rhs) noexcept
    {
        return Vec3(lhs) -= rhs;
    }

    // Method Description:
    /// Subtracts the scalar from the vector
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator-(double lhs, const Vec3& rhs) noexcept
    {
        return -Vec3(rhs) += lhs;
    }

    // Method Description:
    /// Subtracts the two vectors
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator-(const Vec3& lhs, const Vec3& rhs) noexcept
    {
        return Vec3(lhs) -= rhs;
    }

    // Method Description:
    /// Scalar mulitplication
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator*(const Vec3& lhs, double rhs) noexcept
    {
        return Vec3(lhs) *= rhs;
    }

    // Method Description:
    /// Scalar mulitplication
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator*(double lhs, const Vec3& rhs) noexcept
    {
        return Vec3(rhs) *= lhs;
    }

    // Method Description:
    /// Vector mulitplication (dot product)
    ///
    /// @param lhs
    /// @param rhs
    /// @return dot product
    ///
    ///
    inline double operator*(const Vec3& lhs, const Vec3& rhs) noexcept
    {
        return lhs.dot(rhs);
    }

    // Method Description:
    /// Scalar division
    ///
    /// @param lhs
    /// @param rhs
    /// @return Vec3
    ///
    inline Vec3 operator/(const Vec3& lhs, double rhs) noexcept
    {
        return Vec3(lhs) /= rhs;
    }

    // Method Description:
    /// stream output operator
    ///
    /// @param stream
    /// @param vec
    /// @return std::ostream
    ///
    inline std::ostream& operator<<(std::ostream& stream, const Vec3& vec)
    {
        stream << vec.toString() << std::endl;
        return stream;
    }
} // namespace nc

/*** End of inlined file: Vec3.hpp ***/

namespace nc::coordinates
{
    /**
     * @brief Cartensian coordinates
     */
    class Cartesian
    {
    public:
        double x{ 0. };
        double y{ 0. };
        double z{ 0. };

        /**
         * @brief Default Constructor
         */
        Cartesian() noexcept = default;

        /**
         * @brief Constructor
         *
         * @param inX: the x component
         * @param inY: the y component
         * @param inZ: the z component
         */
        constexpr Cartesian(double inX, double inY, double inZ = 0.) noexcept :
            x(inX),
            y(inY),
            z(inZ)
        {
        }

        /**
         * @brief Default Constructor
         *
         * @param inCartesianVector
         */
        Cartesian(const Vec2& inCartesianVector) :
            x(inCartesianVector.x),
            y(inCartesianVector.y)
        {
        }

        /**
         * @brief Default Constructor
         *
         * @param inCartesianVector
         */
        Cartesian(const Vec3& inCartesianVector) :
            x(inCartesianVector.x),
            y(inCartesianVector.y),
            z(inCartesianVector.z)
        {
        }

        /// Constructor
        ///
        /// @param inCartesianVector
        ///
        Cartesian(const NdArray<double>& inCartesianVector)
        {
            if (inCartesianVector.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("NdArray input must be of length 3.");
            }

            x = inCartesianVector[0];
            y = inCartesianVector[1];
            z = inCartesianVector[2];
        }

        /**
         * @brief Copy Constructor
         *
         * @param other: the other Cartesian instance
         */
        Cartesian(const Cartesian& other) noexcept = default;

        /**
         * @brief Move Constructor
         *
         * @param other: the other Cartesian instance
         */
        Cartesian(Cartesian&& other) noexcept = default;

        /**
         * @brief Destructor
         */
        virtual ~Cartesian() = default;

        /**
         * @brief Copy Assignement Operator
         *
         * @param other: the other Cartesian instance
         */
        Cartesian& operator=(const Cartesian& other) noexcept = default;

        /**
         * @brief Move Assignement Operator
         *
         * @param other: the other Cartesian instance
         */
        Cartesian& operator=(Cartesian&& other) noexcept = default;

        /**
         * @brief x Unit Vector
         *
         * @return unit vector in x direction
         */
        [[nodiscard]] static Cartesian xHat() noexcept
        {
            return { 1., 0., 0. };
        }

        /**
         * @brief y Unit Vector
         *
         * @return unit vector in y direction
         */
        [[nodiscard]] static Cartesian yHat() noexcept
        {
            return { 0., 1., 0. };
        }

        /**
         * @brief z Unit Vector
         *
         * @return unit vector in z direction
         */
        [[nodiscard]] static Cartesian zHat() noexcept
        {
            return { 0., 0., 1. };
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const Cartesian& other) const noexcept
        {
            return utils::essentiallyEqual(x, other.x) && utils::essentiallyEqual(y, other.y) &&
                   utils::essentiallyEqual(z, other.z);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const Cartesian& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Addition of two cartesian points
     *
     * @param lhs: the left hand side object
     * @param rhs: the right hand side object
     */
    [[nodiscard]] inline Cartesian operator+(const Cartesian& lhs, const Cartesian& rhs) noexcept
    {
        return { lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z };
    }

    /**
     * @brief Subtraction of two cartesian points
     *
     * @param lhs: the left hand side object
     * @param rhs: the right hand side object
     */
    [[nodiscard]] inline Cartesian operator-(const Cartesian& lhs, const Cartesian& rhs) noexcept
    {
        return { lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z };
    }

    /**
     * @brief Dot product of two cartesian points
     *
     * @param lhs: the left hand side object
     * @param rhs: the right hand side object
     */
    [[nodiscard]] inline double operator*(const Cartesian& lhs, const Cartesian& rhs) noexcept
    {
        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
    }

    /**
     * @brief Vector scalar multiplication
     *
     * @param scalar: the the scalar value
     * @param vec: the cartesian vector
     */
    [[nodiscard]] inline Cartesian operator*(double scalar, const Cartesian& vec) noexcept
    {
        return { vec.x * scalar, vec.y * scalar, vec.z * scalar };
    }

    /**
     * @brief Vector scalar multiplication
     *
     * @param vec: the cartesian vector
     * @param scalar: the the scalar value
     */
    [[nodiscard]] inline Cartesian operator*(const Cartesian& vec, double scalar) noexcept
    {
        return scalar * vec;
    }

    /**
     * @brief Scalar Division a cartesian point
     *
     * @param vec: the cartesian vector
     * @param denominator: the the scalar value
     */
    [[nodiscard]] inline Cartesian operator/(const Cartesian& vec, double denominator) noexcept
    {
        return vec * (1.0 / denominator);
    }

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param vec: the cartesian vector
     */
    inline std::ostream& operator<<(std::ostream& os, const Cartesian& vec)
    {
        os << "Cartesian(x=" << vec.x << ", y=" << vec.y << ", z=" << vec.z << ")\n";
        return os;
    }

    /**
     * @brief Vector cross product
     *
     * @param vec1: cartesian vector
     * @param vec2: cartesian vector
     * @return: the vector cross product
     */
    [[nodiscard]] inline Cartesian cross(const Cartesian& vec1, const Cartesian& vec2) noexcept
    {
        return { vec1.y * vec2.z - vec1.z * vec2.y,
                 -(vec1.x * vec2.z - vec1.z * vec2.x),
                 vec1.x * vec2.y - vec1.y * vec2.x };
    }

    /**
     * @brief Vector norm
     *
     * @param vec: the cartesian vector
     * @return: the vector norm
     */
    [[nodiscard]] inline double norm(const Cartesian& vec) noexcept
    {
        return std::hypot(vec.x, vec.y, vec.z);
    }

    /**
     * @brief normalize the input vector
     *
     * @param vec: the cartesian vector
     * @return: normalized vector
     */
    [[nodiscard]] inline Cartesian normalize(const Cartesian& vec) noexcept
    {
        return vec / norm(vec);
    }

    /**
     * @brief angle between the two vectors
     *
     * @param vec1: cartesian vector
     * @param vec2: cartesian vector
     * @return unit vector in x direction
     */
    [[nodiscard]] inline double angle(const Cartesian& vec1, const Cartesian& vec2) noexcept
    {
        return std::acos(normalize(vec1) * normalize(vec2));
    }
} // namespace nc::coordinates

/*** End of inlined file: Cartesian.hpp ***/


/*** Start of inlined file: Euler.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Euler
///
#pragma once

#include <iostream>

namespace nc::coordinates
{
    /**
     * @brief Euler
     */
    class Euler
    {
    public:
        double psi{ 0. };
        double theta{ 0. };
        double phi{ 0. };

        /**
         * @brief Default Constructor
         */
        Euler() noexcept = default;

        /**
         * @brief Constructor
         *
         * @param inPsi: the psi component
         * @param inTheta: the theta component
         * @param inPhi: the phi component
         */
        constexpr Euler(double inPsi, double inTheta, double inPhi) noexcept :
            psi(inPsi),
            theta(inTheta),
            phi(inPhi)
        {
        }

        /**
         * @brief Copy Constructor
         *
         * @param other: the other Euler instance
         */
        Euler(const Euler& other) noexcept = default;

        /**
         * @brief Move Euler
         *
         * @param other: the other Euler instance
         */
        Euler(Euler&& other) noexcept = default;

        /**
         * @brief Destructor
         */
        virtual ~Euler() = default;

        /**
         * @brief Copy Assignement Operator
         *
         * @param other: the other Euler instance
         */
        Euler& operator=(const Euler& other) noexcept = default;

        /**
         * @brief Move Assignement Operator
         *
         * @param other: the other Euler instance
         */
        Euler& operator=(Euler&& other) noexcept = default;

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const Euler& other) const noexcept
        {
            return utils::essentiallyEqual(psi, other.psi) && utils::essentiallyEqual(theta, other.theta) &&
                   utils::essentiallyEqual(phi, other.phi);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const Euler& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param Euler: the euler angles
     */
    inline std::ostream& operator<<(std::ostream& os, const Euler& Euler)
    {
        os << "Euler(psi=" << Euler.psi << ", theta=" << Euler.theta << ", phi=" << Euler.phi << ")\n";
        return os;
    }
} // namespace nc::coordinates

/*** End of inlined file: Euler.hpp ***/


/*** Start of inlined file: Orientation.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Orientation
///
#pragma once

#include <iostream>

namespace nc::coordinates
{
    /**
     * @brief Orientation
     */
    class Orientation
    {
    public:
        double roll{ 0. };
        double pitch{ 0. };
        double yaw{ 0. };

        /**
         * @brief Default Constructor
         */
        Orientation() noexcept = default;

        /**
         * @brief Constructor
         *
         * @param inRoll: the roll component
         * @param inPitch: the pitch component
         * @param inYaw: the yaw component
         */
        constexpr Orientation(double inRoll, double inPitch, double inYaw) noexcept :
            roll(inRoll),
            pitch(inPitch),
            yaw(inYaw)
        {
        }

        /**
         * @brief Copy Constructor
         *
         * @param other: the other Orientation instance
         */
        Orientation(const Orientation& other) noexcept = default;

        /**
         * @brief Move Orientation
         *
         * @param other: the other Orientation instance
         */
        Orientation(Orientation&& other) noexcept = default;

        /**
         * @brief Destructor
         */
        virtual ~Orientation() = default;

        /**
         * @brief Copy Assignement Operator
         *
         * @param other: the other Orientation instance
         */
        Orientation& operator=(const Orientation& other) noexcept = default;

        /**
         * @brief Move Assignement Operator
         *
         * @param other: the other Orientation instance
         */
        Orientation& operator=(Orientation&& other) noexcept = default;

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const Orientation& other) const noexcept
        {
            return utils::essentiallyEqual(roll, other.roll) && utils::essentiallyEqual(pitch, other.pitch) &&
                   utils::essentiallyEqual(yaw, other.yaw);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const Orientation& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param orientation: the roll/pitch/yaw angles
     */
    inline std::ostream& operator<<(std::ostream& os, const Orientation& orientation)
    {
        os << "Orientation(roll=" << orientation.roll << ", pitch=" << orientation.pitch << ", yaw=" << orientation.yaw
           << ")\n";
        return os;
    }
} // namespace nc::coordinates

/*** End of inlined file: Orientation.hpp ***/


/*** Start of inlined file: ReferenceFrames.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate reference frame functions
///
#pragma once


/*** Start of inlined file: AER.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// AER Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief Az, El, Range coordinates
     */

    class AER
    {
    public:
        double az{ 0. };    // radians
        double el{ 0. };    // radians
        double range{ 0. }; // meters

        /**
         * @brief Default Constructor
         */
        AER() = default;

        /**
         * @brief Constructor
         * @param inAz: az value in radians
         * @param inEl: el value in radians
         * @param inRange: the range in meters
         */
        // NOTLINTNEXTLINE(bugprone-easily-swappable-parameters)
        constexpr AER(double inAz, double inEl, double inRange = 1.) noexcept :
            az(inAz),
            el(inEl),
            range(inRange)
        {
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const AER& other) const noexcept
        {
            return utils::essentiallyEqual(az, other.az) && utils::essentiallyEqual(el, other.el) &&
                   utils::essentiallyEqual(range, other.range);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const AER& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param point: the AER point
     */
    inline std::ostream& operator<<(std::ostream& os, const AER& point)
    {
        os << "AER(az=" << point.az << ", el=" << point.el << ", range=" << point.range << ")\n";
        return os;
    }

} // namespace nc::coordinates::reference_frames

/*** End of inlined file: AER.hpp ***/


/*** Start of inlined file: Celestial.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Celestial Object
///
#pragma once

#include <cmath>
#include <iostream>
#include <string>


/*** Start of inlined file: deg2rad.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.deg2rad.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    constexpr auto deg2rad(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return inValue * constants::pi / 180.;
    }

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.deg2rad.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto deg2rad(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(deg2rad(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return deg2rad(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: deg2rad.hpp ***/


/*** Start of inlined file: dot.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Dot product of two arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.dot.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> dot(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1.dot(inArray2);
    }

    // Method Description:
    /// Dot product of two arrays.
    ///
    /// For 2-D arrays it is equivalent to matrix multiplication,
    /// and for 1-D arrays to inner product of vectors.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.dot.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> dot(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto shape1 = inArray1.shape();
        const auto shape2 = inArray2.shape();

        if (shape1 == shape2 && (shape1.rows == 1 || shape1.cols == 1))
        {
            const std::complex<dtype> dotProduct =
                std::inner_product(inArray1.cbegin(), inArray1.cend(), inArray2.cbegin(), std::complex<dtype>{ 0 });
            NdArray<std::complex<dtype>> returnArray = { dotProduct };
            return returnArray;
        }
        if (shape1.cols == shape2.rows)
        {
            // 2D array, use matrix multiplication
            NdArray<std::complex<dtype>> returnArray(shape1.rows, shape2.cols);
            auto                         array2T = inArray2.transpose();

            for (uint32 i = 0; i < shape1.rows; ++i)
            {
                for (uint32 j = 0; j < shape2.cols; ++j)
                {
                    returnArray(i, j) = std::inner_product(array2T.cbegin(j),
                                                           array2T.cend(j),
                                                           inArray1.cbegin(i),
                                                           std::complex<dtype>{ 0 });
                }
            }

            return returnArray;
        }

        std::string errStr = "shapes of [" + utils::num2str(shape1.rows) + ", " + utils::num2str(shape1.cols) + "]";
        errStr += " and [" + utils::num2str(shape2.rows) + ", " + utils::num2str(shape2.cols) + "]";
        errStr += " are not consistent.";
        THROW_INVALID_ARGUMENT_ERROR(errStr);

        return NdArray<std::complex<dtype>>(); // get rid of compiler warning
    }

    // Method Description:
    /// Dot product of two arrays.
    ///
    /// For 2-D arrays it is equivalent to matrix multiplication,
    /// and for 1-D arrays to inner product of vectors.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.dot.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> dot(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto shape1 = inArray1.shape();
        const auto shape2 = inArray2.shape();

        if (shape1 == shape2 && (shape1.rows == 1 || shape1.cols == 1))
        {
            const std::complex<dtype> dotProduct =
                std::inner_product(inArray1.cbegin(), inArray1.cend(), inArray2.cbegin(), std::complex<dtype>{ 0 });
            NdArray<std::complex<dtype>> returnArray = { dotProduct };
            return returnArray;
        }
        if (shape1.cols == shape2.rows)
        {
            // 2D array, use matrix multiplication
            NdArray<std::complex<dtype>> returnArray(shape1.rows, shape2.cols);
            auto                         array2T = inArray2.transpose();

            for (uint32 i = 0; i < shape1.rows; ++i)
            {
                for (uint32 j = 0; j < shape2.cols; ++j)
                {
                    returnArray(i, j) = std::inner_product(array2T.cbegin(j),
                                                           array2T.cend(j),
                                                           inArray1.cbegin(i),
                                                           std::complex<dtype>{ 0 });
                }
            }

            return returnArray;
        }

        std::string errStr = "shapes of [" + utils::num2str(shape1.rows) + ", " + utils::num2str(shape1.cols) + "]";
        errStr += " and [" + utils::num2str(shape2.rows) + ", " + utils::num2str(shape2.cols) + "]";
        errStr += " are not consistent.";
        THROW_INVALID_ARGUMENT_ERROR(errStr);

        return NdArray<std::complex<dtype>>(); // get rid of compiler warning
    }
} // namespace nc

/*** End of inlined file: dot.hpp ***/


/*** Start of inlined file: rad2deg.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Convert angles from radians to degrees.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.rad2deg.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    constexpr auto rad2deg(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return inValue * 180. / constants::pi;
    }

    // Method Description:
    /// Convert angles from radians to degrees.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.rad2deg.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto rad2deg(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(rad2deg(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return rad2deg(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: rad2deg.hpp ***/

namespace nc::coordinates::reference_frames
{

    /// Holds a right ascension object
    class RA
    {
    public:

        /// Default Constructor
        ///
        RA() = default;

        /// Constructor
        ///
        /// @param inDegrees
        ///
        explicit RA(double inDegrees) :
            degrees_(inDegrees),
            radians_(deg2rad(inDegrees))
        {
            if (inDegrees < 0 || inDegrees >= 360)
            {
                THROW_INVALID_ARGUMENT_ERROR("input degrees must be of the range [0, 360)");
            }

            hours_                  = static_cast<uint8>(std::floor(degrees_ / 15.));
            const double decMinutes = (degrees_ - static_cast<double>(hours_) * 15.) * 4.;
            minutes_                = static_cast<uint8>(std::floor(decMinutes));
            seconds_                = static_cast<double>((decMinutes - static_cast<double>(minutes_)) * 60.);
        }

        /// Constructor
        ///
        /// @param inHours
        /// @param inMinutes
        /// @param inSeconds
        ///
        RA(uint8 inHours, uint8 inMinutes, double inSeconds) noexcept :
            hours_(inHours),
            minutes_(inMinutes),
            seconds_(inSeconds)
        {
            degrees_ = static_cast<double>(hours_) * 15. + static_cast<double>(minutes_) / 4. + seconds_ / 240.;
            radians_ = deg2rad(degrees_);
        }

        /// Get the radians value
        ///
        /// @return radians
        ///
        [[nodiscard]] double radians() const noexcept
        {
            return radians_;
        }

        /// Get the degrees value
        ///
        /// @return degrees
        ///
        [[nodiscard]] double degrees() const noexcept
        {
            return degrees_;
        }

        /// Get the hour value
        ///
        /// @return hours
        ///
        [[nodiscard]] uint8 hours() const noexcept
        {
            return hours_;
        }

        /// Get the minute value
        ///
        /// @return minutes
        ///
        [[nodiscard]] uint8 minutes() const noexcept
        {
            return minutes_;
        }

        /// Get the seconds value
        ///
        /// @return seconds
        ///
        [[nodiscard]] double seconds() const noexcept
        {
            return seconds_;
        }

        /// Return the RA object as a string representation
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out =
                "RA hms: " + utils::num2str(hours_) + " hours, " + utils::num2str(minutes_) + " minutes, ";
            out += utils::num2str(seconds_) + " seconds\nRA degrees: " + utils::num2str(degrees_) + '\n';
            return out;
        }

        /// Prints the RA object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        /// Equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator==(const RA& inRhs) const noexcept
        {
            return utils::essentiallyEqual(degrees_, inRhs.degrees_);
        }

        /// Not equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator!=(const RA& inRhs) const noexcept
        {
            return !(*this == inRhs);
        }

        /// Ostream operator
        ///
        /// @param inStream
        /// @param inRa
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const RA& inRa)
        {
            inStream << inRa.str();
            return inStream;
        }

    private:
        //====================================Attributes==============================
        uint8  hours_{ 0 };
        uint8  minutes_{ 0 };
        double seconds_{ 0. };
        double degrees_{ 0. };
        double radians_{ 0. };
    };

    /// Holds a Declination object
    class Dec
    {
    public:

        /// Struct Enum for positive or negative Dec angle
        enum class Sign
        {
            NEGATIVE = 0,
            POSITIVE
        };

        /// Default Constructor
        ///
        Dec() = default;

        /// Constructor
        ///
        /// @param inDegrees
        ///
        explicit Dec(double inDegrees) :
            degrees_(inDegrees),
            radians_(deg2rad(inDegrees))
        {
            if (inDegrees < -90 || inDegrees > 90)
            {
                THROW_INVALID_ARGUMENT_ERROR("input degrees must be of the range [-90, 90]");
            }

            sign_                   = degrees_ < 0 ? Sign::NEGATIVE : Sign::POSITIVE;
            const double absDegrees = std::abs(degrees_);
            degreesWhole_           = static_cast<uint8>(std::floor(absDegrees));

            const double decMinutes = (absDegrees - static_cast<double>(degreesWhole_)) * 60.;
            minutes_                = static_cast<uint8>(std::floor(decMinutes));
            seconds_                = (decMinutes - static_cast<double>(minutes_)) * 60.;
        }

        /// Constructor
        ///
        /// @param inSign
        /// @param inDegrees
        /// @param inMinutes
        /// @param inSeconds
        ///
        Dec(Sign inSign, uint8 inDegrees, uint8 inMinutes, double inSeconds) noexcept :
            sign_(inSign),
            degreesWhole_(inDegrees),
            minutes_(inMinutes),
            seconds_(inSeconds)
        {
            degrees_ = static_cast<double>(degreesWhole_) + static_cast<double>(minutes_) / 60. + seconds_ / 3600.;
            degrees_ *= sign_ == Sign::NEGATIVE ? -1 : 1;

            radians_ = deg2rad(degrees_);
        }

        /// Get the sign of the degrees (positive or negative)
        ///
        /// @return Sign
        ///
        [[nodiscard]] Sign sign() const noexcept
        {
            return sign_;
        }

        /// Get the degrees value
        ///
        /// @return degrees
        ///
        [[nodiscard]] double degrees() const noexcept
        {
            return degrees_;
        }

        /// Get the radians value
        ///
        /// @return minutes
        ///
        [[nodiscard]] double radians() const noexcept
        {
            return radians_;
        }

        /// Get the whole degrees value
        ///
        /// @return whole degrees
        ///
        [[nodiscard]] uint8 degreesWhole() const noexcept
        {
            return degreesWhole_;
        }

        /// Get the minute value
        ///
        /// @return minutes
        ///
        [[nodiscard]] uint8 minutes() const noexcept
        {
            return minutes_;
        }

        /// Get the seconds value
        ///
        /// @return seconds
        ///
        [[nodiscard]] double seconds() const noexcept
        {
            return seconds_;
        }

        /// Return the dec object as a string representation
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string strSign = sign_ == Sign::NEGATIVE ? "-" : "+";
            std::string out     = "Dec dms: " + strSign + utils::num2str(degreesWhole_) + " degrees, " +
                              utils::num2str(minutes_) + " minutes, ";
            out += utils::num2str(seconds_) + " seconds\nDec degrees = " + utils::num2str(degrees_) + '\n';
            return out;
        }

        /// Prints the Dec object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        /// Equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator==(const Dec& inRhs) const noexcept
        {
            return utils::essentiallyEqual(degrees_, inRhs.degrees_);
        }

        /// Not equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator!=(const Dec& inRhs) const noexcept
        {
            return !(*this == inRhs);
        }

        /// Ostream operator
        ///
        /// @param inStream
        /// @param inDec
        ///
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const Dec& inDec)
        {
            inStream << inDec.str();
            return inStream;
        }

    private:
        //====================================Attributes==============================
        Sign   sign_{ Sign::POSITIVE };
        uint8  degreesWhole_{ 0 };
        uint8  minutes_{ 0 };
        double seconds_{ 0. };
        double degrees_{ 0. };
        double radians_{ 0. };
    };

    /// Holds a full celestial Celestial object
    class Celestial
    {
    public:

        /// Default Constructor
        ///
        Celestial() = default;

        /// Constructor
        ///
        /// @param inRaDegrees
        /// @param inDecDegrees
        ///
        Celestial(double inRaDegrees, double inDecDegrees) :
            ra_(inRaDegrees),
            dec_(inDecDegrees)
        {
            polarToCartesian();
        }

        /// Constructor
        ///
        /// @param inRaHours
        /// @param inRaMinutes
        /// @param inRaSeconds
        /// @param inSign
        /// @param inDecDegreesWhole
        /// @param inDecMinutes
        /// @param inDecSeconds
        ///
        Celestial(uint8     inRaHours,
                  uint8     inRaMinutes,
                  double    inRaSeconds,
                  Dec::Sign inSign,
                  uint8     inDecDegreesWhole,
                  uint8     inDecMinutes,
                  double    inDecSeconds) :
            ra_(inRaHours, inRaMinutes, inRaSeconds),
            dec_(inSign, inDecDegreesWhole, inDecMinutes, inDecSeconds)
        {
            polarToCartesian();
        }

        /// Constructor
        ///
        /// @param inRA
        /// @param inDec
        ///
        Celestial(const RA& inRA, const Dec& inDec) noexcept :
            ra_(inRA),
            dec_(inDec)
        {
            polarToCartesian();
        }

        /// Constructor
        ///
        /// @param inX
        /// @param inY
        /// @param inZ
        ///
        Celestial(double inX, double inY, double inZ) :
            x_(inX),
            y_(inY),
            z_(inZ)
        {
            cartesianToPolar();
        }

        /// Constructor
        ///
        /// @param inCartesianVector
        ///
        Celestial(const Cartesian& inCartesianVector) :
            x_(inCartesianVector.x),
            y_(inCartesianVector.y),
            z_(inCartesianVector.z)
        {
            cartesianToPolar();
        }

        /// Constructor
        ///
        /// @param inCartesianVector
        ///
        Celestial(const Vec3& inCartesianVector) :
            x_(inCartesianVector.x),
            y_(inCartesianVector.y),
            z_(inCartesianVector.z)
        {
            cartesianToPolar();
        }

        /// Constructor
        ///
        /// @param inCartesianVector
        ///
        Celestial(const NdArray<double>& inCartesianVector)
        {
            if (inCartesianVector.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("NdArray input must be of length 3.");
            }

            x_ = inCartesianVector[0];
            y_ = inCartesianVector[1];
            z_ = inCartesianVector[2];

            cartesianToPolar();
        }

        /// Returns the Dec object
        ///
        /// @return Dec
        ///
        [[nodiscard]] const Dec& dec() const noexcept
        {
            return dec_;
        }

        /// Returns the RA object
        ///
        /// @return RA
        ///
        [[nodiscard]] const RA& ra() const noexcept
        {
            return ra_;
        }

        /// Returns the cartesian x value
        ///
        /// @return x
        ///
        [[nodiscard]] double x() const noexcept
        {
            return x_;
        }

        /// Returns the cartesian y value
        ///
        /// @return y
        ///
        [[nodiscard]] double y() const noexcept
        {
            return y_;
        }

        /// Returns the cartesian z value
        ///
        /// @return z
        ///
        [[nodiscard]] double z() const noexcept
        {
            return z_;
        }

        /// Returns the cartesian xyz triplet as an NdArray
        ///
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<double> xyz() const
        {
            NdArray<double> out = { x_, y_, z_ };
            return out;
        }

        /// Returns the degree seperation between the two Celestials
        ///
        /// @param inOtherCelestial
        ///
        /// @return degrees
        ///
        [[nodiscard]] double degreeSeperation(const Celestial& inOtherCelestial) const
        {
            return rad2deg(radianSeperation(inOtherCelestial));
        }

        /// Returns the degree seperation between the Celestial
        /// and the input vector
        ///
        /// @param inVector
        ///
        /// @return degrees
        ///
        [[nodiscard]] double degreeSeperation(const NdArray<double>& inVector) const
        {
            return rad2deg(radianSeperation(inVector));
        }

        /// Returns the radian seperation between the two Celestials
        ///
        /// @param inOtherCelestial
        ///
        /// @return radians
        ///
        [[nodiscard]] double radianSeperation(const Celestial& inOtherCelestial) const
        {
            return std::acos(dot(xyz(), inOtherCelestial.xyz()).item());
        }

        /// Returns the radian seperation between the Celestial
        /// and the input vector
        ///
        /// @param inVector
        ///
        /// @return radians
        ///
        [[nodiscard]] double radianSeperation(const NdArray<double>& inVector) const
        {
            if (inVector.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("input vector must be of length 3.");
            }

            return std::acos(dot(xyz(), inVector.flatten()).item());
        }

        /// Returns Celestial as a string representation
        ///
        /// @return string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string returnStr;
            returnStr = ra_.str();
            returnStr += dec_.str();
            returnStr += "Cartesian = " + xyz().str();
            return returnStr;
        }

        /// Prints the Celestial object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        /// Equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator==(const Celestial& inRhs) const noexcept
        {
            return ra_ == inRhs.ra_ && dec_ == inRhs.dec_;
        }

        /// Not equality operator
        ///
        /// @param inRhs
        ///
        /// @return bool
        ///
        bool operator!=(const Celestial& inRhs) const noexcept
        {
            return !(*this == inRhs);
        }

        /// Ostream operator
        ///
        /// @param inStream
        /// @param inCoord
        ///
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const Celestial& inCoord)
        {
            inStream << inCoord.str();
            return inStream;
        }

    private:
        //====================================Attributes==============================
        RA     ra_{};
        Dec    dec_{};
        double x_{ 1. };
        double y_{ 0. };
        double z_{ 0. };

        /// Converts polar Celestials to cartesian Celestials
        ///
        void cartesianToPolar()
        {
            double degreesRa = rad2deg(std::atan2(y_, x_));
            if (degreesRa < 0)
            {
                degreesRa += 360;
            }
            ra_ = RA(degreesRa);

            const double r          = std::sqrt(utils::sqr(x_) + utils::sqr(y_) + utils::sqr(z_));
            const double degreesDec = rad2deg(std::asin(z_ / r));
            dec_                    = Dec(degreesDec);
        }

        /// Converts polar Celestials to cartesian Celestials
        ///
        void polarToCartesian() noexcept
        {
            const double raRadians  = deg2rad(ra_.degrees());
            const double decRadians = deg2rad(dec_.degrees());

            x_ = std::cos(raRadians) * std::cos(decRadians);
            y_ = std::sin(raRadians) * std::cos(decRadians);
            z_ = std::sin(decRadians);
        }
    };
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: Celestial.hpp ***/


/*** Start of inlined file: Constants.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Constants
///
#pragma once

namespace nc::coordinates::reference_frames::constants
{
    // WSG-84
    constexpr double EARTH_POLAR_RADIUS      = 6'356'752.3142;
    constexpr double EARTH_EQUATORIAL_RADIUS = 6'378'137.0;
} // namespace nc::coordinates::reference_frames::constants
/*** End of inlined file: Constants.hpp ***/


/*** Start of inlined file: ECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// ECEF Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief ECEF coordinates
     */
    class ECEF final : public Cartesian
    {
    public:
        using Cartesian::Cartesian;

        /**
         * @brief Constructor
         * @param cartesian: cartesian vector
         */
        constexpr ECEF(const Cartesian& cartesian) noexcept :
            Cartesian(cartesian)
        {
        }
    };
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: ECEF.hpp ***/


/*** Start of inlined file: ENU.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// ENU Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief East North Up coordinates
     */
    class ENU final : public Cartesian
    {
    public:
        using Cartesian::Cartesian;

        /**
         * @brief Constructor
         * @param cartesian: cartesian vector
         */
        constexpr ENU(const Cartesian& cartesian) noexcept :
            Cartesian(cartesian)
        {
        }

        /**
         * @brief Constructor
         * @param east: east value
         * @param north: north value
         * @param up: up value
         */
        // NOTLINTNEXTLINE(bugprone-easily-swappable-parameters)
        constexpr ENU(double east, double north, double up) noexcept :
            Cartesian(east, north, up)
        {
        }

        /**
         * @brief east getter
         *
         * @return east
         */
        [[nodiscard]] double east() const noexcept
        {
            return x;
        }

        /**
         * @brief east setter
         *
         * @param east: east value
         */
        void setEast(double east) noexcept
        {
            x = east;
        }

        /**
         * @brief north getter
         *
         * @return double
         */
        [[nodiscard]] double north() const noexcept
        {
            return y;
        }

        /**
         * @brief north setter
         *
         * @param north: north value
         */
        void setNorth(double north) noexcept
        {
            y = north;
        }

        /**
         * @brief up getter
         *
         * @return up
         */
        [[nodiscard]] double up() const noexcept
        {
            return z;
        }

        /**
         * @brief up setter
         *
         * @param up: up value
         */
        void setUp(double up) noexcept
        {
            z = up;
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param point: the ENU point
     */
    inline std::ostream& operator<<(std::ostream& os, const ENU& point)
    {
        os << "ENU(east=" << point.east() << ", north=" << point.north() << ", up=" << point.up() << ")\n";
        return os;
    }
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: ENU.hpp ***/


/*** Start of inlined file: Geocentric.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Geocentric Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief Geocentric coordinates
     */
    class Geocentric
    {
    public:
        double latitude{ 0. };  // radians
        double longitude{ 0. }; // radians
        double radius{ 0. };    // meters

        /**
         * @brief Default Constructor
         */
        Geocentric() = default;

        /**
         * @brief Constructor
         * @param inLatitude: latitude value in radians
         * @param inLongitude: longitude value in radians
         * @param inRadius: radius value in meters
         */
        // NOTLINTNEXTLINE(bugprone-easily-swappable-parameters)
        constexpr Geocentric(double inLatitude, double inLongitude, double inRadius = 0.) noexcept :
            latitude(inLatitude),
            longitude(inLongitude),
            radius(inRadius)
        {
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const Geocentric& other) const noexcept
        {
            return utils::essentiallyEqual(latitude, other.latitude) &&
                   utils::essentiallyEqual(longitude, other.longitude) && utils::essentiallyEqual(radius, other.radius);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const Geocentric& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param point: the Geocentric point
     */
    inline std::ostream& operator<<(std::ostream& os, const Geocentric& point)
    {
        os << "Geocentric(latitude=" << point.latitude << ", longitude=" << point.longitude
           << ", radius=" << point.radius << ")\n";
        return os;
    }
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: Geocentric.hpp ***/


/*** Start of inlined file: LLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// LLA Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief Geodetic coordinates
     */
    class LLA
    {
    public:
        double latitude{ 0. };  // radians
        double longitude{ 0. }; // radians
        double altitude{ 0. };  // meters

        /**
         * @brief Default Constructor
         */
        LLA() = default;

        /**
         * @brief Constructor
         * @param inLatitude: latitude value in radians
         * @param inLongitude: longitude value in radians
         * @param inAltitude: altitude value in meters
         */
        // NOTLINTNEXTLINE(bugprone-easily-swappable-parameters)
        constexpr LLA(double inLatitude, double inLongitude, double inAltitude = 0.) noexcept :
            latitude(inLatitude),
            longitude(inLongitude),
            altitude(inAltitude)
        {
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator==(const LLA& other) const noexcept
        {
            return utils::essentiallyEqual(latitude, other.latitude) &&
                   utils::essentiallyEqual(longitude, other.longitude) &&
                   utils::essentiallyEqual(altitude, other.altitude);
        }

        /**
         * @brief Non-Equality Operator
         *
         * @param other: other object
         * @return bool true if not equal equal
         */
        bool operator!=(const LLA& other) const noexcept
        {
            return !(*this == other);
        }
    };

    /**
     * @brief Stream operator
     *
     * @param os: the output stream
     * @param point: the LLA point
     */
    inline std::ostream& operator<<(std::ostream& os, const LLA& point)
    {
        os << "LLA(latitude=" << point.latitude << ", longitude=" << point.longitude << ", altitude=" << point.altitude
           << ")\n";
        return os;
    }
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: LLA.hpp ***/


/*** Start of inlined file: NED.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// NED Object
///
#pragma once

#include <iostream>

namespace nc::coordinates::reference_frames
{
    /**
     * @brief North east down coordinates
     */
    class NED final : public Cartesian
    {
    public:
        using Cartesian::Cartesian;

        /**
         * @brief Constructor
         * @param cartesian: cartesian vector
         */
        constexpr NED(const Cartesian& cartesian) noexcept :
            Cartesian(cartesian)
        {
        }

        /**
         * @brief Constructor
         * @param north: north value
         * @param east: east value
         * @param down: down value
         */
        // NOTLINTNEXTLINE(bugprone-easily-swappable-parameters)
        constexpr NED(double north, double east, double down) noexcept :
            Cartesian(north, east, down)
        {
        }

        /**
         * @brief north getter
         *
         * @return north
         */
        [[nodiscard]] double north() const noexcept
        {
            return x;
        }

        /**
         * @brief north setter
         *
         * @param north: north value
         */
        void setNorth(double north) noexcept
        {
            x = north;
        }

        /**
         * @brief east getter
         *
         * @return double
         */
        [[nodiscard]] double east() const noexcept
        {
            return y;
        }

        /**
         * @brief east setter
         *
         * @param east: east value
         */
        void setEast(double east) noexcept
        {
            y = east;
        }

        /**
         * @brief down getter
         *
         * @return down
         */
        [[nodiscard]] double down() const noexcept
        {
            return z;
        }

        /**
         * @brief down setter
         *
         * @param down: down value
         */
        void setDown(double down) noexcept
        {
            z = down;
        }
    };
} // namespace nc::coordinates::reference_frames

/*** End of inlined file: NED.hpp ***/

/*** End of inlined file: ReferenceFrames.hpp ***/


/*** Start of inlined file: Transforms.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinates transformation functions
///
#pragma once


/*** Start of inlined file: AERtoECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: AERtoNED.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (NED).
     *        NOTE: positive elevation is defined as the negative z (up) direction
     *
     * @param aer: 2D Inertial azimuth and elevation
     * @return NED
     */
    [[nodiscard]] inline reference_frames::NED AERtoNED(const reference_frames::AER aer) noexcept
    {
        const auto north = aer.range * std::cos(aer.el) * std::cos(aer.az);
        const auto east  = aer.range * std::cos(aer.el) * std::sin(aer.az);
        const auto down  = aer.range * std::sin(-aer.el);
        return { north, east, down };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: AERtoNED.hpp ***/


/*** Start of inlined file: LLAtoECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the LLA coordinates to ECEF
     *        https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates
     *
     * @param point: the point of interest
     * @returns Cartesian
     */
    [[nodiscard]] inline reference_frames::ECEF LLAtoECEF(const reference_frames::LLA& point) noexcept
    {
        constexpr auto B2_DIV_A2 = utils::sqr(reference_frames::constants::EARTH_POLAR_RADIUS /
                                              reference_frames::constants::EARTH_EQUATORIAL_RADIUS);
        constexpr auto E_SQR     = 1. - B2_DIV_A2;

        const auto sinLat = std::sin(point.latitude);
        const auto cosLat = std::cos(point.latitude);
        const auto sinLon = std::sin(point.longitude);
        const auto cosLon = std::cos(point.longitude);

        const auto primeVerticalMeridian =
            reference_frames::constants::EARTH_EQUATORIAL_RADIUS / std::sqrt(1. - E_SQR * utils::sqr(sinLat));

        return reference_frames::ECEF{ (primeVerticalMeridian + point.altitude) * cosLat * cosLon,
                                       (primeVerticalMeridian + point.altitude) * cosLat * sinLon,
                                       (B2_DIV_A2 * primeVerticalMeridian + point.altitude) * sinLat };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: LLAtoECEF.hpp ***/


/*** Start of inlined file: NEDtoECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>


/*** Start of inlined file: ECEFtoLLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>


/*** Start of inlined file: sign.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns an element-wise indication of the sign of a number.
    ///
    /// The sign function returns - 1 if x < 0, 0 if x == 0, 1 if x > 0.
    /// nan is returned for nan inputs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sign.html
    ///
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    int8 sign(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (inValue < dtype{ 0 })
        {
            return -1;
        }

        if (inValue > dtype{ 0 })
        {
            return 1;
        }

        return 0;
    }

    // Method Description:
    /// Returns an element-wise indication of the sign of a number.
    ///
    /// The sign function returns - 1 if x < 0, 0 if x == 0, 1 if x > 0.
    /// nan is returned for nan inputs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sign.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<int8> sign(const NdArray<dtype>& inArray)
    {
        NdArray<int8> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> int8 { return sign(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sign.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts ECEF coordinates to LLA
     * 		  https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_ECEF_to_geodetic_coordinates
     *
     * @param ecef the point of interest
     * @param tol Tolerance for the convergence of altitude (overriden if 10 iterations are processed)
     * @return LLA
     */
    [[nodiscard]] inline reference_frames::LLA ECEFtoLLA(const reference_frames::ECEF& ecef, double tol = 1e-8) noexcept
    {
        constexpr int  MAX_ITER = 10;
        constexpr auto E_SQR    = 1. - utils::sqr(reference_frames::constants::EARTH_POLAR_RADIUS /
                                               reference_frames::constants::EARTH_EQUATORIAL_RADIUS);

        const auto p   = std::hypot(ecef.x, ecef.y);
        const auto lon = std::atan2(ecef.y, ecef.x);

        double alt = 0.0;
        double lat = 0.0;

        if (p < tol)
        {
            lat = sign(ecef.z) * constants::pi / 2.;
            alt = std::abs(ecef.z) - reference_frames::constants::EARTH_POLAR_RADIUS;
        }
        else
        {
            // Iteratively update latitude and altitude.
            // This is expected to converge in ~4 iterations, but apply a maximum number of iterations incase tol is
            // too small
            double err  = 1.0;
            int    iter = 0;
            while (err > tol && iter < MAX_ITER)
            {
                double N = reference_frames::constants::EARTH_EQUATORIAL_RADIUS /
                           std::sqrt(1 - E_SQR * utils::sqr(std::sin(lat)));
                lat           = std::atan((ecef.z / p) / (1 - (N * E_SQR / (N + alt))));
                double newAlt = (p / std::cos(lat)) - N;
                err           = std::abs(alt - newAlt);
                alt           = newAlt;
                iter++;
            }
        }
        return { lat, lon, alt };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFtoLLA.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the NED coordinates to ECEF
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::ECEF NEDtoECEF(const reference_frames::NED&  target,
                                                          const reference_frames::ECEF& referencePoint) noexcept
    {
        const auto referencePointLLA = ECEFtoLLA(referencePoint);

        const auto sinLat = std::sin(referencePointLLA.latitude);
        const auto cosLat = std::cos(referencePointLLA.latitude);
        const auto sinLon = std::sin(referencePointLLA.longitude);
        const auto cosLon = std::cos(referencePointLLA.longitude);

        auto rotationMatrix  = NdArray<double>(3, 3);
        rotationMatrix(0, 0) = -sinLat * cosLon;
        rotationMatrix(1, 0) = -sinLat * sinLon;
        rotationMatrix(2, 0) = cosLat;
        rotationMatrix(0, 1) = -sinLon;
        rotationMatrix(1, 1) = cosLon;
        rotationMatrix(2, 1) = 0.;
        rotationMatrix(0, 2) = -cosLat * cosLon;
        rotationMatrix(1, 2) = -cosLat * sinLon;
        rotationMatrix(2, 2) = -sinLat;

        auto targetVec = NdArray<double>(3, 1);
        targetVec[0]   = target.north();
        targetVec[1]   = target.east();
        targetVec[2]   = target.down();

        auto referencePointVec = NdArray<double>(3, 1);
        referencePointVec[0]   = referencePoint.x;
        referencePointVec[1]   = referencePoint.y;
        referencePointVec[2]   = referencePoint.z;

        const auto targetECEFVec = dot(rotationMatrix, targetVec) + referencePointVec;
        return { targetECEFVec[0], targetECEFVec[1], targetECEFVec[2] };
    }

    /**
     * @brief Converts the NED coordinates to ECEF
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::ECEF NEDtoECEF(const reference_frames::NED& target,
                                                          const reference_frames::LLA& referencePoint) noexcept
    {
        return NEDtoECEF(target, LLAtoECEF(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDtoECEF.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (ENU).
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param target: the target position
     * @param referencePoint: the reference position
     * @return ECEF
     */
    [[nodiscard]] inline reference_frames::ECEF AERtoECEF(const reference_frames::AER   target,
                                                          const reference_frames::ECEF& referencePoint) noexcept
    {
        return NEDtoECEF(AERtoNED(target), referencePoint);
    }

    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (ENU).
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param target: the target position
     * @param referencePoint: the reference position
     * @return ECEF
     */
    [[nodiscard]] inline reference_frames::ECEF AERtoECEF(const reference_frames::AER  target,
                                                          const reference_frames::LLA& referencePoint) noexcept
    {
        return AERtoECEF(target, LLAtoECEF(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: AERtoECEF.hpp ***/


/*** Start of inlined file: AERtoENU.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: NEDtoENU.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts NED to ENU
     *
     * @param point: the NED coordinates
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ENU NEDtoENU(const reference_frames::NED& point) noexcept
    {
        return { point.east(), point.north(), -point.down() };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDtoENU.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (ENU).
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param aer 2D Inertial azimuth and elevation
     * @return ENU
     */
    [[nodiscard]] inline reference_frames::ENU AERtoENU(const reference_frames::AER aer) noexcept
    {
        return NEDtoENU(AERtoNED(aer));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: AERtoENU.hpp ***/


/*** Start of inlined file: AERtoLLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (ENU).
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param target: the target position
     * @param referencePoint: the reference position
     * @return LLA
     */
    [[nodiscard]] inline reference_frames::LLA AERtoLLA(const reference_frames::AER   target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return ECEFtoLLA(AERtoECEF(target, referencePoint));
    }

    /**
     * @brief Converts the spherical inertial coordinates (NED) to Cartesian XYZ (ENU).
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param target: the target position
     * @param referencePoint: the reference position
     * @return LLA
     */
    [[nodiscard]] inline reference_frames::LLA AERtoLLA(const reference_frames::AER  target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return ECEFtoLLA(AERtoECEF(target, referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: AERtoLLA.hpp ***/


/*** Start of inlined file: ECEFEulerToENURollPitchYaw.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: ECEFEulerToNEDRollPitchYaw.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>


/*** Start of inlined file: NEDUnitVecsInECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief get the local NED unit vectors wrt the ECEF coordinate system
     *        https://gssc.esa.int/navipedia/index.php/Transformations_between_ECEF_and_ENU_coordinates
     *
     * @param location: the ECEF location
     * @return std::array<Vec3, 3>
     */
    [[nodiscard]] inline std::array<Vec3, 3> NEDUnitVecsInECEF(const reference_frames::ECEF& location) noexcept
    {
        const auto lla = ECEFtoLLA(location);

        const auto sinLat = std::sin(lla.latitude);
        const auto cosLat = std::cos(lla.latitude);
        const auto sinLon = std::sin(lla.longitude);
        const auto cosLon = std::cos(lla.longitude);

        const auto xHat = Vec3{ -cosLon * sinLat, -sinLon * sinLat, cosLat };
        const auto yHat = Vec3{ -sinLon, cosLon, 0. };
        const auto zHat = Vec3{ -cosLon * cosLat, -sinLon * cosLat, -sinLat };

        return { xHat, yHat, zHat };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDUnitVecsInECEF.hpp ***/


/*** Start of inlined file: wrap.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// NdArray Functions
///
#pragma once

#include <cmath>

namespace nc
{
    /**
     * @brief Wrap the input angle to [-pi, pi]
     *
     * @param inAngle: in radians
     * @return Wrapped angle
     */
    template<typename dtype>
    double wrap(dtype inAngle) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        auto angle = std::fmod(static_cast<double>(inAngle) + constants::pi, constants::twoPi);
        if (angle < 0.)
        {
            angle += constants::twoPi;
        }

        return angle - constants::pi;
    }

    /**
     * @brief Wrap the input angle to [-pi, pi]
     *
     * @param inAngles: in radians
     * @return Wrapped angles
     */
    template<typename dtype>
    NdArray<double> wrap(const NdArray<dtype>& inAngles) noexcept
    {
        NdArray<double> returnArray(inAngles.size());
        stl_algorithms::transform(inAngles.begin(),
                                  inAngles.end(),
                                  returnArray.begin(),
                                  [](const auto angle) noexcept -> double { return wrap(angle); });
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: wrap.hpp ***/


/*** Start of inlined file: Quaternion.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds a unit quaternion
///
#pragma once

#include <array>
#include <cmath>
#include <iostream>
#include <string>


/*** Start of inlined file: argmax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns the indices of the maximum values along an axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.argmax.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> argmax(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.argmax(inAxis);
    }
} // namespace nc

/*** End of inlined file: argmax.hpp ***/


/*** Start of inlined file: clip.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>

namespace nc
{

    // Method Description:
    /// Clip (limit) the value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.clip.html
    ///
    /// @param inValue
    /// @param inMinValue
    /// @param inMaxValue
    /// @return NdArray
    ///
    template<typename dtype>
    dtype clip(dtype inValue, dtype inMinValue, dtype inMaxValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

#ifdef __cpp_lib_clamp
        const auto comparitor = [](dtype lhs, dtype rhs) noexcept -> bool { return lhs < rhs; };

        return std::clamp(inValue, inMinValue, inMaxValue, comparitor);
#else
        if (inValue < inMinValue)
        {
            return inMinValue;
        }
        else if (inValue > inMaxValue)
        {
            return inMaxValue;
        }

        return inValue;
#endif
    }

    // Method Description:
    /// Clip (limit) the values in an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.clip.html
    ///
    /// @param inArray
    /// @param inMinValue
    /// @param inMaxValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> clip(const NdArray<dtype>& inArray, dtype inMinValue, dtype inMaxValue)
    {
        return inArray.clip(inMinValue, inMaxValue);
    }
} // namespace nc

/*** End of inlined file: clip.hpp ***/


/*** Start of inlined file: norm.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Matrix or vector norm.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> norm(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        double     sumOfSquares = 0.;
        const auto function     = [&sumOfSquares](dtype value) -> void
        { sumOfSquares += utils::sqr(static_cast<double>(value)); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::for_each(inArray.cbegin(), inArray.cend(), function);

                NdArray<double> returnArray = { std::sqrt(sumOfSquares) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    sumOfSquares = 0.;
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);
                    returnArray(0, row) = std::sqrt(sumOfSquares);
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return norm(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Matrix or vector norm.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> norm(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::complex<double> sumOfSquares(0., 0.);
        const auto           function = [&sumOfSquares](const std::complex<dtype>& value) -> void
        { sumOfSquares += utils::sqr(complex_cast<double>(value)); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::for_each(inArray.cbegin(), inArray.cend(), function);

                NdArray<std::complex<double>> returnArray = { std::sqrt(sumOfSquares) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<std::complex<double>> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    sumOfSquares = std::complex<double>(0., 0.);
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);
                    returnArray(0, row) = std::sqrt(sumOfSquares);
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return norm(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: norm.hpp ***/


/*** Start of inlined file: square.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the square of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.square.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    constexpr dtype square(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return utils::sqr(inValue);
    }

    // Method Description:
    /// Return the square of an array, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.square.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> square(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return square(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: square.hpp ***/


/*** Start of inlined file: hat.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// vector hat operator
///
#pragma once

#include <string>

namespace nc::linalg
{

    // Method Description:
    /// vector hat operator
    ///
    /// @param inX
    /// @param inY
    /// @param inZ
    /// @return 3x3 NdArray
    ///
    template<typename dtype>
    NdArray<dtype> hat(dtype inX, dtype inY, dtype inZ)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<dtype> returnArray(3);
        returnArray(0, 0) = 0.;
        returnArray(0, 1) = -inZ;
        returnArray(0, 2) = inY;
        returnArray(1, 0) = inZ;
        returnArray(1, 1) = 0.;
        returnArray(1, 2) = -inX;
        returnArray(2, 0) = -inY;
        returnArray(2, 1) = inX;
        returnArray(2, 2) = 0.;

        return returnArray;
    }

    // Method Description:
    /// vector hat operator
    ///
    /// @param inVec (3x1, or 1x3 cartesian vector)
    /// @return 3x3 NdArray
    ///
    template<typename dtype>
    NdArray<dtype> hat(const NdArray<dtype>& inVec)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inVec.size() != 3)
        {
            THROW_INVALID_ARGUMENT_ERROR("input vector must be a length 3 cartesian vector.");
        }

        return hat(inVec[0], inVec[1], inVec[2]);
    }

    // Method Description:
    /// vector hat operator
    ///
    /// @param inVec
    /// @return 3x3 NdArray
    ///
    inline NdArray<double> hat(const Vec3& inVec)
    {
        return hat(inVec.x, inVec.y, inVec.z);
    }
} // namespace nc::linalg

/*** End of inlined file: hat.hpp ***/

namespace nc::rotations
{

    // Class Description:
    /// Holds a unit quaternion
    class Quaternion
    {
    public:

        // Method Description:
        /// Default Constructor
        ///
        Quaternion() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param roll: euler roll angle in radians
        /// @param pitch: euler pitch angle in radians
        /// @param yaw: euler yaw angle in radians
        ///
        Quaternion(double roll, double pitch, double yaw) noexcept
        {
            eulerToQuat(roll, pitch, yaw);
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inI
        /// @param inJ
        /// @param inK
        /// @param inS
        ///
        Quaternion(double inI, double inJ, double inK, double inS) noexcept :
            components_{ inI, inJ, inK, inS }
        {
            normalize();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param components
        ///
        Quaternion(const std::array<double, 4>& components) noexcept :
            components_{ components }
        {
            normalize();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inArray: if size = 3 the roll, pitch, yaw euler angles
        /// if size = 4 the i, j, k, s components
        /// if shape = [3, 3] then direction cosine matrix
        ///
        Quaternion(const NdArray<double>& inArray) :
            components_{ 0., 0., 0., 0. }
        {
            if (inArray.size() == 3)
            {
                // euler angles
                eulerToQuat(inArray[0], inArray[1], inArray[2]);
            }
            else if (inArray.size() == 4)
            {
                // quaternion i, j, k, s components
                stl_algorithms::copy(inArray.cbegin(), inArray.cend(), components_.begin());
                normalize();
            }
            else if (inArray.size() == 9)
            {
                // direction cosine matrix
                dcmToQuat(inArray);
            }
            else
            {
                THROW_INVALID_ARGUMENT_ERROR("input array is not a valid size.");
            }
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inAxis: Euler axis
        /// @param inAngle: Euler angle in radians
        ///
        Quaternion(const Vec3& inAxis, double inAngle) noexcept
        {
            // normalize the input vector
            Vec3 normAxis = inAxis.normalize();

            const double halfAngle    = inAngle / 2.;
            const double sinHalfAngle = std::sin(halfAngle);

            components_[0] = normAxis.x * sinHalfAngle;
            components_[1] = normAxis.y * sinHalfAngle;
            components_[2] = normAxis.z * sinHalfAngle;
            components_[3] = std::cos(halfAngle);
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inAxis: Euler axis x,y,z vector components
        /// @param inAngle: Euler angle in radians
        ///
        Quaternion(const NdArray<double>& inAxis, double inAngle) :
            Quaternion(Vec3(inAxis), inAngle)
        {
        }

        // Method Description:
        /// the angle of rotation around the rotation axis that is described by the quaternion
        ///
        /// @return radians
        ///
        [[nodiscard]] double angleOfRotation() const noexcept
        {
            return 2. * std::acos(s());
        }

        // Method Description:
        /// angular velocity vector between the two quaternions. The norm
        /// of the array is the magnitude
        ///
        /// @param inQuat1
        /// @param inQuat2
        /// @param inTime (seperation time)
        /// @return NdArray<double>
        ///
        static NdArray<double> angularVelocity(const Quaternion& inQuat1, const Quaternion& inQuat2, double inTime)
        {
            NdArray<double> q0 = inQuat1.toNdArray();
            NdArray<double> q1 = inQuat2.toNdArray();

            NdArray<double> qDot = q1 - q0;
            qDot /= inTime;

            NdArray<double> eyeTimesScalar(3);
            eyeTimesScalar.zeros();
            eyeTimesScalar(0, 0) = inQuat2.s();
            eyeTimesScalar(1, 1) = inQuat2.s();
            eyeTimesScalar(2, 2) = inQuat2.s();

            NdArray<double> epsilonHat = linalg::hat<double>(inQuat2.i(), inQuat2.j(), inQuat2.k());
            NdArray<double> q(4, 3);
            q.put(Slice(0, 3), Slice(0, 3), eyeTimesScalar + epsilonHat);
            q(3, 0) = -inQuat2.i();
            q(3, 1) = -inQuat2.j();
            q(3, 2) = -inQuat2.k();

            NdArray<double> omega = q.transpose().dot(qDot.transpose());
            return omega *= 2.;
        }

        // Method Description:
        /// angular velocity vector between the two quaternions. The norm
        /// of the array is the magnitude
        ///
        /// @param inQuat2
        /// @param inTime (seperation time)
        /// @return NdArray<double>
        ///
        [[nodiscard]] NdArray<double> angularVelocity(const Quaternion& inQuat2, double inTime) const
        {
            return angularVelocity(*this, inQuat2, inTime);
        }

        // Method Description:
        /// the axis of rotation described by the quaternion
        ///
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 axisOfRotation() const noexcept
        {
            const auto halfAngle    = angleOfRotation() / 2.;
            const auto sinHalfAngle = std::sin(halfAngle);
            auto       axis         = Vec3(i() / sinHalfAngle, j() / sinHalfAngle, k() / sinHalfAngle);

            // shouldn't be necessary, but let's be pedantic
            return axis.normalize();
        }

        // Method Description:
        /// quaternion conjugate
        ///
        /// @return Quaternion
        ///
        [[nodiscard]] Quaternion conjugate() const noexcept
        {
            return { -i(), -j(), -k(), s() };
        }

        // Method Description:
        /// returns the i component
        ///
        /// @return double
        ///
        [[nodiscard]] double i() const noexcept
        {
            return components_[0];
        }

        // Method Description:
        /// quaternion identity (0,0,0,1)
        ///
        /// @return Quaternion
        ///
        static Quaternion identity() noexcept
        {
            return {};
        }

        // Method Description:
        /// quaternion inverse
        ///
        /// @return Quaterion
        ///
        [[nodiscard]] Quaternion inverse() const noexcept
        {
            /// for unit quaternions the inverse is equal to the conjugate
            return conjugate();
        }

        // Method Description:
        /// returns the j component
        ///
        /// @return double
        ///
        [[nodiscard]] double j() const noexcept
        {
            return components_[1];
        }

        // Method Description:
        /// returns the k component
        ///
        /// @return double
        ///
        [[nodiscard]] double k() const noexcept
        {
            return components_[2];
        }

        // Method Description:
        /// linearly interpolates between the two quaternions
        ///
        /// @param inQuat1
        /// @param inQuat2
        /// @param inPercent [0, 1]
        /// @return Quaternion
        ///
        static Quaternion nlerp(const Quaternion& inQuat1, const Quaternion& inQuat2, double inPercent)
        {
            if (inPercent < 0. || inPercent > 1.)
            {
                THROW_INVALID_ARGUMENT_ERROR("input percent must be of the range [0,1].");
            }

            if (utils::essentiallyEqual(inPercent, 0.))
            {
                return inQuat1;
            }
            if (utils::essentiallyEqual(inPercent, 1.))
            {
                return inQuat2;
            }

            const double          oneMinus = 1. - inPercent;
            std::array<double, 4> newComponents{};

            stl_algorithms::transform(inQuat1.components_.begin(),
                                      inQuat1.components_.end(),
                                      inQuat2.components_.begin(),
                                      newComponents.begin(),
                                      [inPercent, oneMinus](double component1, double component2) -> double
                                      { return oneMinus * component1 + inPercent * component2; });

            return { newComponents };
        }

        // Method Description:
        /// linearly interpolates between the two quaternions
        ///
        /// @param inQuat2
        /// @param inPercent (0, 1)
        /// @return Quaternion
        ///
        [[nodiscard]] Quaternion nlerp(const Quaternion& inQuat2, double inPercent) const
        {
            return nlerp(*this, inQuat2, inPercent);
        }

        // Method Description:
        /// The euler pitch angle in radians
        ///
        /// @return euler pitch angle in radians
        ///
        [[nodiscard]] double pitch() const noexcept
        {
            return std::asin(2 * (s() * j() - k() * i()));
        }

        // Method Description:
        /// returns a quaternion to rotate about the pitch axis
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion pitchRotation(double inAngle) noexcept
        {
            return { 0., inAngle, 0. };
        }

        // Method Description:
        /// prints the Quaternion to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        // Method Description:
        /// The euler roll angle in radians
        ///
        /// @return euler roll angle in radians
        ///
        [[nodiscard]] double roll() const noexcept
        {
            return std::atan2(2. * (s() * i() + j() * k()), 1. - 2. * (utils::sqr(i()) + utils::sqr(j())));
        }

        // Method Description:
        /// returns a quaternion to rotate about the roll axis
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion rollRotation(double inAngle) noexcept
        {
            return { inAngle, 0., 0. };
        }

        // Method Description:
        /// rotate a vector using the quaternion
        ///
        /// @param inVector (cartesian vector with x,y,z components)
        /// @return NdArray<double> (cartesian vector with x,y,z components)
        ///
        [[nodiscard]] NdArray<double> rotate(const NdArray<double>& inVector) const
        {
            if (inVector.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("input inVector must be a cartesion vector of length = 3.");
            }

            return *this * inVector;
        }

        // Method Description:
        /// rotate a vector using the quaternion
        ///
        /// @param inVec3
        /// @return Vec3
        ///
        [[nodiscard]] Vec3 rotate(const Vec3& inVec3) const
        {
            return *this * inVec3;
        }

        // Method Description:
        /// returns the s component
        ///
        /// @return double
        ///
        [[nodiscard]] double s() const noexcept
        {
            return components_[3];
        }

        // Method Description:
        /// spherical linear interpolates between the two quaternions
        ///
        /// @param inQuat1
        /// @param inQuat2
        /// @param inPercent (0, 1)
        /// @return Quaternion
        ///
        static Quaternion slerp(const Quaternion& inQuat1, const Quaternion& inQuat2, double inPercent)
        {
            if (inPercent < 0 || inPercent > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input percent must be of the range [0, 1]");
            }

            if (utils::essentiallyEqual(inPercent, 0.))
            {
                return inQuat1;
            }
            if (utils::essentiallyEqual(inPercent, 1.))
            {
                return inQuat2;
            }

            double dotProduct = dot<double>(inQuat1.toNdArray(), inQuat2.toNdArray()).item();

            // If the dot product is negative, the quaternions
            // have opposite handed-ness and slerp won't take
            // the shorter path. Fix by reversing one quaternion.
            Quaternion quat1Copy(inQuat1);
            if (dotProduct < 0.)
            {
                quat1Copy *= -1.;
                dotProduct *= -1.;
            }

            constexpr double DOT_THRESHOLD = 0.9995;
            if (dotProduct > DOT_THRESHOLD)
            {
                // If the inputs are too close for comfort, linearly interpolate
                // and normalize the result.
                return nlerp(inQuat1, inQuat2, inPercent);
            }

            dotProduct          = clip(dotProduct, -1., 1.); // Robustness: Stay within domain of acos()
            const double theta0 = std::acos(dotProduct);     // angle between input vectors
            const double theta  = theta0 * inPercent;        // angle between v0 and result

            const double s0 = std::cos(theta) -
                              dotProduct * std::sin(theta) / std::sin(theta0); // == sin(theta_0 - theta) / sin(theta_0)
            const double s1 = std::sin(theta) / std::sin(theta0);

            NdArray<double> interpQuat = (quat1Copy.toNdArray() * s0) + (inQuat2.toNdArray() * s1);
            return Quaternion(interpQuat); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// spherical linear interpolates between the two quaternions
        ///
        /// @param inQuat2
        /// @param inPercent (0, 1)
        /// @return Quaternion
        ///
        [[nodiscard]] Quaternion slerp(const Quaternion& inQuat2, double inPercent) const
        {
            return slerp(*this, inQuat2, inPercent);
        }

        // Method Description:
        /// returns the quaternion as a string representation
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string output = "[" + utils::num2str(i()) + ", " + utils::num2str(j()) + ", " + utils::num2str(k()) +
                                 ", " + utils::num2str(s()) + "]\n";

            return output;
        }

        // Method Description:
        /// returns the direction cosine matrix
        ///
        /// @return NdArray<double>
        ///
        [[nodiscard]] NdArray<double> toDCM() const
        {
            NdArray<double> dcm(3);

            const double q0 = i();
            const double q1 = j();
            const double q2 = k();
            const double q3 = s();

            const double q0sqr = utils::sqr(q0);
            const double q1sqr = utils::sqr(q1);
            const double q2sqr = utils::sqr(q2);
            const double q3sqr = utils::sqr(q3);

            dcm(0, 0) = q3sqr + q0sqr - q1sqr - q2sqr;
            dcm(0, 1) = 2. * (q0 * q1 - q3 * q2);
            dcm(0, 2) = 2. * (q0 * q2 + q3 * q1);
            dcm(1, 0) = 2. * (q0 * q1 + q3 * q2);
            dcm(1, 1) = q3sqr + q1sqr - q0sqr - q2sqr;
            dcm(1, 2) = 2. * (q1 * q2 - q3 * q0);
            dcm(2, 0) = 2. * (q0 * q2 - q3 * q1);
            dcm(2, 1) = 2. * (q1 * q2 + q3 * q0);
            dcm(2, 2) = q3sqr + q2sqr - q0sqr - q1sqr;

            return dcm;
        }

        // Method Description:
        /// returns the quaternion as an NdArray
        ///
        /// @return NdArray<double>
        ///
        [[nodiscard]] NdArray<double> toNdArray() const
        {
            auto componentsCopy = components_;
            return NdArray<double>(componentsCopy); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// returns a quaternion to rotate about the x-axis by the input angle
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion xRotation(double inAngle) noexcept
        {
            const Vec3 eulerAxis = { 1., 0., 0. };
            return Quaternion(eulerAxis, inAngle); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// The euler yaw angle in radians
        ///
        /// @return euler yaw angle in radians
        ///
        [[nodiscard]] double yaw() const noexcept
        {
            return std::atan2(2. * (s() * k() + i() * j()), 1. - 2. * (utils::sqr(j()) + utils::sqr(k())));
        }

        // Method Description:
        /// returns a quaternion to rotate about the yaw axis
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion yawRotation(double inAngle) noexcept
        {
            return { 0., 0., inAngle };
        }

        // Method Description:
        /// returns a quaternion to rotate about the y-axis by the input angle
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion yRotation(double inAngle) noexcept
        {
            const Vec3 eulerAxis = { 0., 1., 0. };
            return Quaternion(eulerAxis, inAngle); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// returns a quaternion to rotate about the y-axis by the input angle
        ///
        /// @param inAngle (radians)
        /// @return Quaternion
        ///
        static Quaternion zRotation(double inAngle) noexcept
        {
            const Vec3 eulerAxis = { 0., 0., 1. };
            return Quaternion(eulerAxis, inAngle); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// equality operator
        ///
        /// @param inRhs
        /// @return bool
        ///
        bool operator==(const Quaternion& inRhs) const noexcept
        {
            const auto comparitor = [](double value1, double value2) noexcept -> bool
            { return utils::essentiallyEqual(value1, value2); };

            return stl_algorithms::equal(components_.begin(), components_.end(), inRhs.components_.begin(), comparitor);
        }

        // Method Description:
        /// equality operator
        ///
        /// @param inRhs
        /// @return bool
        ///
        bool operator!=(const Quaternion& inRhs) const noexcept
        {
            return !(*this == inRhs);
        }

        // Method Description:
        /// addition assignment operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion& operator+=(const Quaternion& inRhs) noexcept
        {
            stl_algorithms::transform(components_.begin(),
                                      components_.end(),
                                      inRhs.components_.begin(),
                                      components_.begin(),
                                      std::plus<double>()); // NOLINT(modernize-use-transparent-functors)

            normalize();

            return *this;
        }

        // Method Description:
        /// addition operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion operator+(const Quaternion& inRhs) const noexcept
        {
            return Quaternion(*this) += inRhs;
        }

        // Method Description:
        /// subtraction assignment operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion& operator-=(const Quaternion& inRhs) noexcept
        {
            stl_algorithms::transform(components_.begin(),
                                      components_.end(),
                                      inRhs.components_.begin(),
                                      components_.begin(),
                                      std::minus<double>()); // NOLINT(modernize-use-transparent-functors)

            normalize();

            return *this;
        }

        // Method Description:
        /// subtraction operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion operator-(const Quaternion& inRhs) const noexcept
        {
            return Quaternion(*this) -= inRhs;
        }

        // Method Description:
        /// negative operator
        ///
        /// @return Quaternion
        ///
        Quaternion operator-() const noexcept
        {
            return Quaternion(*this) *= -1.;
        }

        // Method Description:
        /// multiplication assignment operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion& operator*=(const Quaternion& inRhs) noexcept
        {
            double q0 = inRhs.s() * i();
            q0 += inRhs.i() * s();
            q0 -= inRhs.j() * k();
            q0 += inRhs.k() * j();

            double q1 = inRhs.s() * j();
            q1 += inRhs.i() * k();
            q1 += inRhs.j() * s();
            q1 -= inRhs.k() * i();

            double q2 = inRhs.s() * k();
            q2 -= inRhs.i() * j();
            q2 += inRhs.j() * i();
            q2 += inRhs.k() * s();

            double q3 = inRhs.s() * s();
            q3 -= inRhs.i() * i();
            q3 -= inRhs.j() * j();
            q3 -= inRhs.k() * k();

            components_[0] = q0;
            components_[1] = q1;
            components_[2] = q2;
            components_[3] = q3;

            normalize();

            return *this;
        }

        // Method Description:
        /// multiplication operator, only useful for multiplying
        /// by negative 1, all others will be renormalized back out
        ///
        /// @param inScalar
        /// @return Quaternion
        ///
        Quaternion& operator*=(double inScalar) noexcept
        {
            stl_algorithms::for_each(components_.begin(),
                                     components_.end(),
                                     [inScalar](double& component) { component *= inScalar; });

            normalize();

            return *this;
        }

        // Method Description:
        /// multiplication operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion operator*(const Quaternion& inRhs) const noexcept
        {
            return Quaternion(*this) *= inRhs;
        }

        // Method Description:
        /// multiplication operator, only useful for multiplying
        /// by negative 1, all others will be renormalized back out
        ///
        /// @param inScalar
        /// @return Quaternion
        ///
        Quaternion operator*(double inScalar) const noexcept
        {
            return Quaternion(*this) *= inScalar;
        }

        // Method Description:
        /// multiplication operator
        ///
        /// @param inVec
        /// @return NdArray<double>
        ///
        NdArray<double> operator*(const NdArray<double>& inVec) const
        {
            if (inVec.size() != 3)
            {
                THROW_INVALID_ARGUMENT_ERROR("input vector must be a cartesion vector of length = 3.");
            }

            const auto vecNorm = norm(inVec).item();
            if (utils::essentiallyEqual(vecNorm, 0.))
            {
                return inVec;
            }

            const auto p      = Quaternion(inVec[0], inVec[1], inVec[2], 0.);
            const auto pPrime = *this * p * this->inverse();

            NdArray<double> rotatedVec = { pPrime.i(), pPrime.j(), pPrime.k() };
            rotatedVec *= vecNorm;
            return rotatedVec;
        }

        // Method Description:
        /// multiplication operator
        ///
        /// @param inVec3
        /// @return Vec3
        ///
        Vec3 operator*(const Vec3& inVec3) const
        {
            return *this * inVec3.toNdArray();
        }

        // Method Description:
        /// division assignment operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion& operator/=(const Quaternion& inRhs) noexcept
        {
            return *this *= inRhs.conjugate();
        }

        // Method Description:
        /// division operator
        ///
        /// @param inRhs
        /// @return Quaternion
        ///
        Quaternion operator/(const Quaternion& inRhs) const noexcept
        {
            return Quaternion(*this) /= inRhs;
        }

        // Method Description:
        /// IO operator for the Quaternion class
        ///
        /// @param inOStream
        /// @param inQuat
        /// @return std::ostream&
        ///
        friend std::ostream& operator<<(std::ostream& inOStream, const Quaternion& inQuat)
        {
            inOStream << inQuat.str();
            return inOStream;
        }

    private:
        //====================================Attributes==============================
        std::array<double, 4> components_{ { 0., 0., 0., 1. } };

        // Method Description:
        /// renormalizes the quaternion
        ///
        void normalize() noexcept
        {
            double sumOfSquares = 0.;
            std::for_each(components_.begin(),
                          components_.end(),
                          [&sumOfSquares](double component) noexcept -> void
                          { sumOfSquares += utils::sqr(component); });

            const double norm = std::sqrt(sumOfSquares);
            stl_algorithms::for_each(components_.begin(),
                                     components_.end(),
                                     [norm](double& component) noexcept -> void { component /= norm; });
        }

        // Method Description:
        /// Converts the euler roll, pitch, yaw angles to quaternion components
        ///
        /// @ param roll: the euler roll angle in radians
        /// @ param pitch: the euler pitch angle in radians
        /// @ param yaw: the euler yaw angle in radians
        ///
        void eulerToQuat(double roll, double pitch, double yaw) noexcept
        {
            const auto halfPhi   = roll / 2.;
            const auto halfTheta = pitch / 2.;
            const auto halfPsi   = yaw / 2.;

            const auto sinHalfPhi = std::sin(halfPhi);
            const auto cosHalfPhi = std::cos(halfPhi);

            const auto sinHalfTheta = std::sin(halfTheta);
            const auto cosHalfTheta = std::cos(halfTheta);

            const auto sinHalfPsi = std::sin(halfPsi);
            const auto cosHalfPsi = std::cos(halfPsi);

            components_[0] = sinHalfPhi * cosHalfTheta * cosHalfPsi;
            components_[0] -= cosHalfPhi * sinHalfTheta * sinHalfPsi;

            components_[1] = cosHalfPhi * sinHalfTheta * cosHalfPsi;
            components_[1] += sinHalfPhi * cosHalfTheta * sinHalfPsi;

            components_[2] = cosHalfPhi * cosHalfTheta * sinHalfPsi;
            components_[2] -= sinHalfPhi * sinHalfTheta * cosHalfPsi;

            components_[3] = cosHalfPhi * cosHalfTheta * cosHalfPsi;
            components_[3] += sinHalfPhi * sinHalfTheta * sinHalfPsi;
        }

        // Method Description:
        /// Converts the direction cosine matrix to quaternion components
        ///
        /// @ param dcm: the direction cosine matrix
        ///
        void dcmToQuat(const NdArray<double>& dcm)
        {
            const Shape inShape = dcm.shape();
            if (!(inShape.rows == 3 && inShape.cols == 3))
            {
                THROW_INVALID_ARGUMENT_ERROR("input direction cosine matrix must have shape = (3,3).");
            }

            NdArray<double> checks(1, 4);
            checks[0] = 1 + dcm(0, 0) + dcm(1, 1) + dcm(2, 2);
            checks[1] = 1 + dcm(0, 0) - dcm(1, 1) - dcm(2, 2);
            checks[2] = 1 - dcm(0, 0) + dcm(1, 1) - dcm(2, 2);
            checks[3] = 1 - dcm(0, 0) - dcm(1, 1) + dcm(2, 2);

            const uint32 maxIdx = argmax(checks).item();

            switch (maxIdx)
            {
                case 0:
                {
                    components_[3] = 0.5 * std::sqrt(1 + dcm(0, 0) + dcm(1, 1) + dcm(2, 2));
                    components_[0] = (dcm(2, 1) - dcm(1, 2)) / (4 * components_[3]);
                    components_[1] = (dcm(0, 2) - dcm(2, 0)) / (4 * components_[3]);
                    components_[2] = (dcm(1, 0) - dcm(0, 1)) / (4 * components_[3]);

                    break;
                }
                case 1:
                {
                    components_[0] = 0.5 * std::sqrt(1 + dcm(0, 0) - dcm(1, 1) - dcm(2, 2));
                    components_[1] = (dcm(1, 0) + dcm(0, 1)) / (4 * components_[0]);
                    components_[2] = (dcm(2, 0) + dcm(0, 2)) / (4 * components_[0]);
                    components_[3] = (dcm(2, 1) - dcm(1, 2)) / (4 * components_[0]);

                    break;
                }
                case 2:
                {
                    components_[1] = 0.5 * std::sqrt(1 - dcm(0, 0) + dcm(1, 1) - dcm(2, 2));
                    components_[0] = (dcm(1, 0) + dcm(0, 1)) / (4 * components_[1]);
                    components_[2] = (dcm(2, 1) + dcm(1, 2)) / (4 * components_[1]);
                    components_[3] = (dcm(0, 2) - dcm(2, 0)) / (4 * components_[1]);

                    break;
                }
                case 3:
                {
                    components_[2] = 0.5 * std::sqrt(1 - dcm(0, 0) - dcm(1, 1) + dcm(2, 2));
                    components_[0] = (dcm(2, 0) + dcm(0, 2)) / (4 * components_[2]);
                    components_[1] = (dcm(2, 1) + dcm(1, 2)) / (4 * components_[2]);
                    components_[3] = (dcm(1, 0) - dcm(0, 1)) / (4 * components_[2]);

                    break;
                }
            }
        }
    };
} // namespace nc::rotations

/*** End of inlined file: Quaternion.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts ECEF euler angles to body roll/pitch/yaw
     *
     * @param location: the ecef location
     * @param orientation: ecef euler angles
     * @return NED Orientation
     */
    [[nodiscard]] inline Orientation ECEFEulerToNEDRollPitchYaw(const reference_frames::ECEF& location,
                                                                const Euler&                  orientation) noexcept
    {
        const auto x0 = Vec3::right();
        const auto y0 = Vec3::up();
        const auto z0 = Vec3::forward();

        // first rotation array, z0 by psi
        const auto quatPsi = rotations::Quaternion{ z0, orientation.psi };

        // rotate
        const auto x1 = quatPsi * x0;
        const auto y1 = quatPsi * y0;

        // second rotation array, y1 by theta
        const auto quatTheta = rotations::Quaternion{ y1, orientation.theta };

        // rotate
        const auto x2 = quatTheta * x1;
        const auto y2 = quatTheta * y1;

        // third rotation array, x2 by phi
        const auto quatPhi = rotations::Quaternion{ x2, orientation.phi };

        // rotate
        const auto x3 = quatPhi * x2;
        const auto y3 = quatPhi * y2;

        // get the local NED unit vectors wrt the ECEF coordinate system
        const auto& [xHat0, yHat0, zHat0] = NEDUnitVecsInECEF(location);

        // calculate yaw and pitch
        const auto yaw   = std::atan2(x3.dot(yHat0), x3.dot(xHat0));
        const auto pitch = std::atan(-x3.dot(zHat0) / std::hypot(x3.dot(xHat0), x3.dot(yHat0)));

        // calculate roll
        const auto yHat2 = (rotations::Quaternion{ zHat0, yaw } * yHat0);
        const auto zHat2 = (rotations::Quaternion{ yHat2, pitch } * zHat0);
        const auto roll  = std::atan2(y3.dot(zHat2), y3.dot(yHat2));

        return { wrap(roll), pitch, wrap(yaw) };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFEulerToNEDRollPitchYaw.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts ECEF euler angles to body roll/pitch/yaw
     *
     * @param location: the ecef location
     * @param orientation: ecef euler angles
     * @return ENU Orientation
     */
    [[nodiscard]] inline Orientation ECEFEulerToENURollPitchYaw(const reference_frames::ECEF& location,
                                                                const Euler&                  orientation) noexcept
    {
        const auto nedOrientation = ECEFEulerToNEDRollPitchYaw(location, orientation);
        return { nedOrientation.pitch, nedOrientation.roll, -nedOrientation.yaw };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFEulerToENURollPitchYaw.hpp ***/


/*** Start of inlined file: ECEFtoAER.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>


/*** Start of inlined file: ECEFtoENU.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ECEF coordinates to ENU
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the reference point
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ENU ECEFtoENU(const reference_frames::ECEF& target,
                                                         const reference_frames::LLA&  referencePoint) noexcept
    {
        const auto sinLat = std::sin(referencePoint.latitude);
        const auto cosLat = std::cos(referencePoint.latitude);
        const auto sinLon = std::sin(referencePoint.longitude);
        const auto cosLon = std::cos(referencePoint.longitude);

        const auto referencePointECEF = LLAtoECEF(referencePoint);

        const auto x = target.x - referencePointECEF.x;
        const auto y = target.y - referencePointECEF.y;
        const auto z = target.z - referencePointECEF.z;

        return { -sinLon * x + cosLon * y,
                 -sinLat * cosLon * x - sinLat * sinLon * y + cosLat * z,
                 cosLat * cosLon * x + cosLat * sinLon * y + sinLat * z };
    }

    /**
     * @brief Converts the ECEF coordinates to ENU
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the reference point
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ENU ECEFtoENU(const reference_frames::ECEF& target,
                                                         const reference_frames::ECEF& referencePoint) noexcept
    {
        return ECEFtoENU(target, ECEFtoLLA(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFtoENU.hpp ***/


/*** Start of inlined file: wrap2Pi.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// NdArray Functions
///
#pragma once

#include <cmath>

namespace nc
{
    /**
     * @brief Wrap the input angle to [0, 2*pi]
     *
     * @param inAngle: in radians
     * @returns Wrapped angle
     */
    template<typename dtype>
    double wrap2Pi(dtype inAngle) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        auto angle = std::fmod(static_cast<double>(inAngle), constants::twoPi);
        if (angle < 0.)
        {
            angle += constants::twoPi;
        }

        return angle;
    }

    /**
     * @brief Wrap the input angle to [0, 2*pi]
     *
     * @param inAngles: in radians
     * @returns Wrapped angles
     */
    template<typename dtype>
    NdArray<double> wrap2Pi(const NdArray<dtype>& inAngles) noexcept
    {
        NdArray<double> returnArray(inAngles.size());
        stl_algorithms::transform(inAngles.begin(),
                                  inAngles.end(),
                                  returnArray.begin(),
                                  [](const auto angle) noexcept -> double { return wrap2Pi(angle); });
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: wrap2Pi.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the LLA coordinates to Az El with geodedic up
     *        https://geospace-code.github.io/matmap3d/enu2aer.html
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER ECEFtoAER(const reference_frames::ECEF& target,
                                                         const reference_frames::LLA&  referencePoint) noexcept
    {
        const auto targetENU = ECEFtoENU(target, referencePoint);
        const auto targetENUnormalizedCart =
            normalize(Cartesian{ targetENU.east(), targetENU.north(), targetENU.up() });
        const auto& east  = targetENUnormalizedCart.x;
        const auto& north = targetENUnormalizedCart.y;
        const auto& up    = targetENUnormalizedCart.z;

        const auto referencePointECEF = LLAtoECEF(referencePoint);
        const auto range              = norm(target - referencePointECEF);

        return { wrap2Pi(std::atan2(east, north)), std::asin(up), range };
    }

    /**
     * @brief Converts the LLA coordinates to Az El with geodedic up
     *        https://geospace-code.github.io/matmap3d/enu2aer.html
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER ECEFtoAER(const reference_frames::ECEF& target,
                                                         const reference_frames::ECEF& referencePoint) noexcept
    {
        return ECEFtoAER(target, ECEFtoLLA(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFtoAER.hpp ***/


/*** Start of inlined file: ECEFtoNED.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: ENUtoNED.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts ENU to NED
     *
     * @param point: the ENU coordinates
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::NED ENUtoNED(const reference_frames::ENU& point) noexcept
    {
        return { point.north(), point.east(), -point.up() };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENUtoNED.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ECEF coordinates to NED
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::NED ECEFtoNED(const reference_frames::ECEF& target,
                                                         const reference_frames::LLA&  referencePoint) noexcept
    {
        return ENUtoNED(ECEFtoENU(target, referencePoint));
    }

    /**
     * @brief Converts the ECEF coordinates to NED
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::NED ECEFtoNED(const reference_frames::ECEF& target,
                                                         const reference_frames::ECEF& referencePoint) noexcept
    {
        return ENUtoNED(ECEFtoENU(target, referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ECEFtoNED.hpp ***/


/*** Start of inlined file: ENURollPitchYawToECEFEuler.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: NEDRollPitchYawToECEFEuler.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts NED body roll/pitch/yaw to ECEF euler angles
     *
     * @param location: the ecef location
     * @param orientation: ned euler angles
     * @return Orientation
     */
    [[nodiscard]] inline Euler NEDRollPitchYawToECEFEuler(const reference_frames::ECEF& location,
                                                          const Orientation&            orientation) noexcept
    {
        // get the local NED unit vectors wrt the ECEF coordinate system
        const auto& [x0, y0, z0] = NEDUnitVecsInECEF(location);

        // first rotation array, z0 by yaw
        const auto quatYaw = rotations::Quaternion{ z0, orientation.yaw };

        // rotate
        const auto x1 = quatYaw * x0;
        const auto y1 = quatYaw * y0;

        // second rotation array, y1 by pitch
        const auto quatPitch = rotations::Quaternion{ y1, orientation.pitch };

        // rotate
        const auto x2 = quatPitch * x1;
        const auto y2 = quatPitch * y1;

        // third rotation array, x2 by roll
        const auto quatRoll = rotations::Quaternion{ x2, orientation.roll };

        // rotate
        const auto x3 = quatRoll * x2;
        const auto y3 = quatRoll * y2;

        // calculate phi and theta
        const auto xHat0 = Vec3::right();
        const auto yHat0 = Vec3::up();
        const auto zHat0 = Vec3::forward();

        const auto psi   = std::atan2(x3.dot(yHat0), x3.dot(xHat0));
        const auto theta = std::atan(-x3.dot(zHat0) / std::hypot(x3.dot(xHat0), x3.dot(yHat0)));

        // calculate phi
        const auto yHat2 = (rotations::Quaternion{ zHat0, psi } * yHat0);
        const auto zHat2 = (rotations::Quaternion{ yHat2, theta } * zHat0);
        const auto phi   = std::atan2(y3.dot(zHat2), y3.dot(yHat2));

        return { wrap(psi), theta, wrap(phi) };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDRollPitchYawToECEFEuler.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts ENU body roll/pitch/yaw to ECEF euler angles
     *
     * @param location: the ecef location
     * @param orientation: ned euler angles
     * @return Orientation
     */
    [[nodiscard]] inline Euler ENURollPitchYawToECEFEuler(const reference_frames::ECEF& location,
                                                          const Orientation&            orientation) noexcept
    {
        const auto nedOrientation = Orientation{ orientation.pitch, orientation.roll, -orientation.yaw };
        const auto nedEuler       = NEDRollPitchYawToECEFEuler(location, nedOrientation);
        return { nedEuler.theta, nedEuler.psi, -nedEuler.phi };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENURollPitchYawToECEFEuler.hpp ***/


/*** Start of inlined file: ENUUnitVecsInECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief get the local ENU unit vectors wrt the ECEF coordinate system
     *        // https://gssc.esa.int/navipedia/index.php/Transformations_between_ECEF_and_ENU_coordinates
     *
     * @param location: the ECEF location
     * @return std::array<Vec3, 3>
     */
    [[nodiscard]] inline std::array<Vec3, 3> ENUUnitVecsInECEF(const reference_frames::ECEF& location) noexcept
    {
        const auto& [xHat, yHat, zHat] = NEDUnitVecsInECEF(location);
        return { yHat, xHat, -zHat };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENUUnitVecsInECEF.hpp ***/


/*** Start of inlined file: ENUtoAER.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: NEDtoAER.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the Cartesian XYZ (NED) coordinates to 2d speherical inertial coordinates.
     *        Range is not used.
     *        NOTE: positive elevation is defined as the negative z (up) direction
     *
     * @param target: coordinates to convert
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER NEDtoAER(const reference_frames::NED& target) noexcept
    {
        const auto hypotXy = std::hypot(target.x, target.y);
        const auto el      = -std::atan2(target.z, hypotXy);
        const auto az      = wrap2Pi(std::atan2(target.y, target.x));
        const auto r       = std::hypot(target.x, target.y);
        const auto range   = std::hypot(r, target.z);
        return { az, el, range };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDtoAER.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ENU coordinates to 2d speherical inertial coordinates.
     *        Range is not used.
     *        NOTE: positive elevation is defined as the positive z (up) direction
     *
     * @param target: coordinates to convert
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER ENUtoAER(const reference_frames::ENU& target) noexcept
    {
        return NEDtoAER(ENUtoNED(target));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENUtoAER.hpp ***/


/*** Start of inlined file: ENUtoECEF.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ENU coordinates to ECEF
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ECEF ENUtoECEF(const reference_frames::ENU&  target,
                                                          const reference_frames::ECEF& referencePoint) noexcept
    {
        return NEDtoECEF(ENUtoNED(target), referencePoint);
    }

    /**
     * @brief Converts the ENU coordinates to ECEF
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ECEF ENUtoECEF(const reference_frames::ENU& target,
                                                          const reference_frames::LLA& referencePoint) noexcept
    {
        return ENUtoECEF(target, LLAtoECEF(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENUtoECEF.hpp ***/


/*** Start of inlined file: ENUtoLLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: NEDtoLLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the NED coordinates to LLA
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::LLA NEDtoLLA(const reference_frames::NED&  target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return ECEFtoLLA(NEDtoECEF(target, referencePoint));
    }

    /**
     * @brief Converts the NED coordinates to LLA
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::LLA NEDtoLLA(const reference_frames::NED& target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return ECEFtoLLA(NEDtoECEF(target, referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: NEDtoLLA.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ENU coordinates to LLA
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::LLA ENUtoLLA(const reference_frames::ENU&  target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return NEDtoLLA(ENUtoNED(target), referencePoint);
    }

    /**
     * @brief Converts the ENU coordinates to LLA
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *        https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::LLA ENUtoLLA(const reference_frames::ENU& target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return ENUtoLLA(target, LLAtoECEF(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: ENUtoLLA.hpp ***/


/*** Start of inlined file: LLAtoAER.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the LLA coordinates to Az El with geodedic up
     *        https://geospace-code.github.io/matmap3d/enu2aer.html
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER LLAtoAER(const reference_frames::LLA& target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return ECEFtoAER(LLAtoECEF(target), referencePoint);
    }

    /**
     * @brief Converts the LLA coordinates to Az El with geodedic up
     *        https://geospace-code.github.io/matmap3d/enu2aer.html
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint
     * @returns AER
     */
    [[nodiscard]] inline reference_frames::AER LLAtoAER(const reference_frames::LLA&  target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return LLAtoAER(target, ECEFtoLLA(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: LLAtoAER.hpp ***/


/*** Start of inlined file: LLAtoENU.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once


/*** Start of inlined file: LLAtoNED.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the LLA coordinates to NED
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::NED LLAtoNED(const reference_frames::LLA& target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return ECEFtoNED(LLAtoECEF(target), referencePoint);
    }

    /**
     * @brief Converts the LLA coordinates to NED
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the referencePoint location
     * @returns NED
     */
    [[nodiscard]] inline reference_frames::NED LLAtoNED(const reference_frames::LLA&  target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return LLAtoNED(target, ECEFtoLLA(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: LLAtoNED.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts the ECEF coordinates to ENU
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the reference point
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ENU LLAtoENU(const reference_frames::LLA& target,
                                                        const reference_frames::LLA& referencePoint) noexcept
    {
        return NEDtoENU(LLAtoNED(target, referencePoint));
    }

    /**
     * @brief Converts the ECEF coordinates to ENU
     *        https://apps.dtic.mil/sti/pdfs/AD1170763.pdf
     *        Figure 11 https://apps.dtic.mil/sti/pdfs/AD1170763.pdf for a helpful diagram
     *
     * @param target: the target of interest
     * @param referencePoint: the reference point
     * @returns ENU
     */
    [[nodiscard]] inline reference_frames::ENU LLAtoENU(const reference_frames::LLA&  target,
                                                        const reference_frames::ECEF& referencePoint) noexcept
    {
        return LLAtoENU(target, ECEFtoLLA(referencePoint));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: LLAtoENU.hpp ***/


/*** Start of inlined file: LLAtoGeocentric.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>


/*** Start of inlined file: geocentricRadius.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Returns the geocentric radius
     *
     * @param point: the point of interest
     * @returns radius
     */
    [[nodiscard]] inline double geocentricRadius(const reference_frames::LLA& point) noexcept
    {
        const auto cosLat = std::cos(point.latitude);
        const auto sinLat = std::sin(point.latitude);
        return std::sqrt((utils::sqr(utils::sqr(reference_frames::constants::EARTH_EQUATORIAL_RADIUS) * cosLat) +
                          utils::sqr(utils::sqr(reference_frames::constants::EARTH_POLAR_RADIUS) * sinLat)) /
                         (utils::sqr(reference_frames::constants::EARTH_EQUATORIAL_RADIUS * cosLat) +
                          utils::sqr(reference_frames::constants::EARTH_POLAR_RADIUS * sinLat)));
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: geocentricRadius.hpp ***/

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts from geodetic to geocentric
     *
     * @param point: the point of interest
     * @returns geocentric
     */
    [[nodiscard]] inline reference_frames::Geocentric LLAtoGeocentric(const reference_frames::LLA& point) noexcept
    {
        constexpr auto flatteningFactor =
            (reference_frames::constants::EARTH_EQUATORIAL_RADIUS - reference_frames::constants::EARTH_POLAR_RADIUS) /
            reference_frames::constants::EARTH_EQUATORIAL_RADIUS;
        const auto geocentricLatitude = atan(utils::sqr(1. - flatteningFactor) * std::tan(point.latitude));
        return reference_frames::Geocentric{ geocentricLatitude, point.longitude, geocentricRadius(point) };
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: LLAtoGeocentric.hpp ***/


/*** Start of inlined file: geocentricToLLA.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Coordinate Transforms
///
#pragma once

#include <cmath>

namespace nc::coordinates::transforms
{
    /**
     * @brief Converts from geocentric to geodetic
     *
     * @param point: the point of interest
     * @returns geodetic
     */
    [[nodiscard]] inline reference_frames::LLA geocentricToLLA(const reference_frames::Geocentric& point) noexcept
    {
        constexpr auto flatteningFactor =
            (reference_frames::constants::EARTH_EQUATORIAL_RADIUS - reference_frames::constants::EARTH_POLAR_RADIUS) /
            reference_frames::constants::EARTH_EQUATORIAL_RADIUS;

        const auto geodeticLatitude = std::atan((1. / utils::sqr(1. - flatteningFactor)) * std::tan(point.latitude));
        auto       geodetic         = reference_frames::LLA{ geodeticLatitude, point.longitude, 0. };
        geodetic.altitude           = point.radius - geocentricRadius(geodetic);
        return geodetic;
    }
} // namespace nc::coordinates::transforms

/*** End of inlined file: geocentricToLLA.hpp ***/

/*** End of inlined file: Transforms.hpp ***/

/*** End of inlined file: Coordinates.hpp ***/


/*** Start of inlined file: Core.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// NumCpp Core classes, functions, and typedefs
///
#pragma once


/*** Start of inlined file: DataCube.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Convience container for holding a uniform array of NdArrays
///
#pragma once

#include <filesystem>
#include <limits>
#include <string>
#include <vector>

namespace nc
{

    /// Convenience container for holding a uniform array of NdArrays
    template<typename dtype>
    class DataCube
    {
    public:
        //================================Typedefs==================================
        using iterator       = typename std::deque<NdArray<dtype>>::iterator;
        using const_iterator = typename std::deque<NdArray<dtype>>::const_iterator;

        /// Default Constructor
        ///
        DataCube() = default;

        /// Constructor, preallocates to the input size
        ///
        /// @param inSize
        ///
        explicit DataCube(uint32 inSize)
        {
            cube_.reserve(inSize);
        }

        /// Access method, with bounds checking. Returns the 2d z "slice" element of the cube.
        ///
        /// @param inIndex
        ///
        /// @return NdArray
        ///
        NdArray<dtype>& at(uint32 inIndex)
        {
            return cube_.at(inIndex);
        }

        /// Const access method, with bounds checking. Returns the 2d z "slice" element of the cube.
        ///
        /// @param inIndex
        ///
        /// @return NdArray
        ///
        [[nodiscard]] const NdArray<dtype>& at(uint32 inIndex) const
        {
            return cube_.at(inIndex);
        }

        /// Returns a reference to the last 2d "slice" of the cube in the z-axis
        ///
        /// @return NdArray&
        ///
        NdArray<dtype>& back() noexcept
        {
            return cube_.back();
        }

        /// Returns an iterator to the first 2d z "slice" of the cube.
        ///
        /// @return iterator
        ///
        [[nodiscard]] iterator begin() noexcept
        {
            return cube_.begin();
        }

        /// Returns an const_iterator to the first 2d z "slice" of the cube.
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator begin() const noexcept
        {
            return cube_.cbegin();
        }

        /// Returns an const_iterator to the first 2d z "slice" of the cube.
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cbegin() const noexcept
        {
            return cube_.cbegin();
        }

        /// Outputs the DataCube as a .bin file
        ///
        /// @param inFilename
        ///
        void dump(const std::string& inFilename) const
        {
            std::filesystem::path f(inFilename);
            if (!f.has_extension())
            {
                f.replace_extension("bin");
            }

            std::ofstream ofile(f.c_str(), std::ios::binary);
            if (!ofile.good())
            {
                THROW_RUNTIME_ERROR("Could not open the input file:\n\t" + inFilename);
            }

            for (auto& ndarray : cube_)
            {
                ofile.write(reinterpret_cast<const char*>(ndarray.data()), ndarray.size() * sizeof(dtype));
            }

            ofile.close();
        }

        /// Tests whether or not the container is empty
        ///
        /// @return bool
        ///
        bool isempty() noexcept
        {
            return cube_.empty();
        }

        /// Returns an iterator to 1 past the last 2d z "slice" of the cube.
        ///
        /// @return iterator
        ///
        [[nodiscard]] iterator end() noexcept
        {
            return cube_.end();
        }

        /// Returns an const_iterator to 1 past the last 2d z "slice" of the cube.
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator end() const noexcept
        {
            return cube_.cend();
        }

        /// Returns an const_iterator to 1 past the last 2d z "slice" of the cube.
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator cend() const noexcept
        {
            return cube_.cend();
        }

        /// Returns a reference to the front 2d "slice" of the cube in the z-axis
        ///
        /// @return NdArray&
        ///
        NdArray<dtype>& front() noexcept
        {
            return cube_.front();
        }

        /// Returns the x/y shape of the cube
        ///
        /// @return Shape
        ///
        [[nodiscard]] const Shape& shape() const noexcept
        {
            return elementShape_;
        }

        /// Returns the size of the z-axis of the cube
        ///
        /// @return size
        ///
        [[nodiscard]] uint32 sizeZ() const noexcept
        {
            return static_cast<uint32>(cube_.size());
        }

        /// Removes the last z "slice" of the cube
        ///
        void pop_back() noexcept
        {
            cube_.pop_back();
        }

        /// Adds a new z "slice" to the end of the cube
        ///
        /// @param inArray
        ///
        void push_back(const NdArray<dtype>& inArray)
        {
            const Shape inputShape = inArray.shape();

            if (elementShape_.rows == 0 && elementShape_.cols == 0)
            {
                // initialize to the first input array size
                elementShape_.rows = inputShape.rows;
                elementShape_.cols = inputShape.cols;
            }

            if (inputShape != elementShape_)
            {
                THROW_INVALID_ARGUMENT_ERROR("element arrays must all be the same shape");
            }

            cube_.push_back(inArray);
        }

        /// Slices the z dimension of the cube
        ///
        /// @param inIndex: the flattend 2d index (row, col) to slice
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAll(int32 inIndex) const
        {
            if (inIndex < 0)
            {
                inIndex += elementShape_.size();
            }

            NdArray<dtype> returnArray(1, sizeZ());

            for (uint32 i = 0; i < sizeZ(); ++i)
            {
                returnArray[i] = cube_[i][inIndex];
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube
        ///
        /// @param inIndex: the flattend 2d index (row, col) to slice
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZ(int32 inIndex, Slice inSliceZ) const
        {
            if (inIndex < 0)
            {
                inIndex += elementShape_.size();
            }

            NdArray<dtype> returnArray(1, inSliceZ.numElements(sizeZ()));

            uint32 idx = 0;
            for (int32 i = inSliceZ.start; i < inSliceZ.stop; i += inSliceZ.step)
            {
                returnArray[idx++] = cube_[i][inIndex];
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAll(int32 inRow, int32 inCol) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            NdArray<dtype> returnArray(1, sizeZ());

            for (uint32 i = 0; i < sizeZ(); ++i)
            {
                returnArray[i] = cube_[i](inRow, inCol);
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZ(int32 inRow, int32 inCol, Slice inSliceZ) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            NdArray<dtype> returnArray(1, inSliceZ.numElements(sizeZ()));

            uint32 idx = 0;
            for (int32 i = inSliceZ.start; i < inSliceZ.stop; i += inSliceZ.step)
            {
                returnArray[idx++] = cube_[i](inRow, inCol);
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAll(Slice inRow, int32 inCol) const
        {
            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            NdArray<dtype> returnArray(inRow.numElements(elementShape_.rows), sizeZ());
            for (uint32 i = 0; i < sizeZ(); ++i)
            {
                returnArray.put(returnArray.rSlice(), i, cube_[i](inRow, inCol));
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZ(Slice inRow, int32 inCol, Slice inSliceZ) const
        {
            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            NdArray<dtype> returnArray(inRow.numElements(elementShape_.rows), inSliceZ.numElements(sizeZ()));
            uint32         idx = 0;
            for (int32 i = inSliceZ.start; i < inSliceZ.stop; i += inSliceZ.step)
            {
                returnArray.put(returnArray.rSlice(), idx++, cube_[i](inRow, inCol));
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAll(int32 inRow, Slice inCol) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            NdArray<dtype> returnArray(inCol.numElements(elementShape_.cols), sizeZ());
            for (uint32 i = 0; i < sizeZ(); ++i)
            {
                returnArray.put(returnArray.rSlice(), i, cube_[i](inRow, inCol));
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZ(int32 inRow, Slice inCol, Slice inSliceZ) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            NdArray<dtype> returnArray(inCol.numElements(elementShape_.cols), inSliceZ.numElements(sizeZ()));
            uint32         idx = 0;
            for (int32 i = inSliceZ.start; i < inSliceZ.stop; i += inSliceZ.step)
            {
                returnArray.put(returnArray.rSlice(), idx++, cube_[i](inRow, inCol));
            }

            return returnArray;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return DataCube
        ///
        DataCube<dtype> sliceZAll(Slice inRow, Slice inCol) const
        {
            DataCube<dtype> returnCube(sizeZ());
            for (uint32 i = 0; i < sizeZ(); ++i)
            {
                returnCube.push_back(cube_[i](inRow, inCol));
            }

            return returnCube;
        }

        /// Slices the z dimension of the cube with NO bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return DataCube
        ///
        DataCube<dtype> sliceZ(Slice inRow, Slice inCol, Slice inSliceZ) const
        {
            DataCube<dtype> returnCube(inSliceZ.numElements(sizeZ()));
            for (int32 i = inSliceZ.start; i < inSliceZ.stop; i += inSliceZ.step)
            {
                returnCube.push_back(cube_[i](inRow, inCol));
            }

            return returnCube;
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inIndex: the flattend 2d index (row, col) to slice
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAllat(int32 inIndex) const
        {
            if (inIndex < 0)
            {
                inIndex += elementShape_.size();
            }

            if (static_cast<uint32>(inIndex) >= elementShape_.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("inIndex exceeds matrix dimensions.");
            }

            return sliceZAll(inIndex);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inIndex: the flattend 2d index (row, col) to slice
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZat(int32 inIndex, Slice inSliceZ) const
        {
            if (inIndex < 0)
            {
                inIndex += elementShape_.size();
            }

            if (static_cast<uint32>(inIndex) >= elementShape_.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("inIndex exceeds matrix dimensions.");
            }

            auto numElements = inSliceZ.numElements(sizeZ());
            if (numElements > sizeZ())
            {
                THROW_INVALID_ARGUMENT_ERROR("inIndex exceeds matrix dimensions.");
            }

            return sliceZ(inIndex, inSliceZ);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAllat(int32 inRow, int32 inCol) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            if (static_cast<uint32>(inRow) >= elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            if (static_cast<uint32>(inCol) >= elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            return sliceZAll(inRow, inCol);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZat(int32 inRow, int32 inCol, Slice inSliceZ) const
        {
            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            if (static_cast<uint32>(inRow) >= elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }
            if (static_cast<uint32>(inCol) >= elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            auto numElements = inSliceZ.numElements(sizeZ());
            if (numElements > sizeZ())
            {
                THROW_INVALID_ARGUMENT_ERROR("Index exceeds matrix dimensions.");
            }

            return sliceZ(inRow, inCol, inSliceZ);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAllat(Slice inRow, int32 inCol) const
        {
            auto numRows = inRow.numElements(elementShape_.rows);
            if (numRows > elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            if (static_cast<uint32>(inCol) >= elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            return sliceZAll(inRow, inCol);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZat(Slice inRow, int32 inCol, Slice inSliceZ) const
        {
            auto numRows = inRow.numElements(elementShape_.rows);
            if (numRows > elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            if (inCol < 0)
            {
                inCol += elementShape_.cols;
            }

            if (static_cast<uint32>(inCol) >= elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            auto numElements = inSliceZ.numElements(sizeZ());
            if (numElements > sizeZ())
            {
                THROW_INVALID_ARGUMENT_ERROR("Index exceeds matrix dimensions.");
            }

            return sliceZ(inRow, inCol, inSliceZ);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZAllat(int32 inRow, Slice inCol) const
        {
            auto numCols = inCol.numElements(elementShape_.cols);
            if (numCols > elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (static_cast<uint32>(inRow) >= elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            return sliceZAll(inRow, inCol);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> sliceZat(int32 inRow, Slice inCol, Slice inSliceZ) const
        {
            auto numCols = inCol.numElements(elementShape_.cols);
            if (numCols > elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            if (inRow < 0)
            {
                inRow += elementShape_.rows;
            }

            if (static_cast<uint32>(inRow) >= elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            auto numElements = inSliceZ.numElements(sizeZ());
            if (numElements > sizeZ())
            {
                THROW_INVALID_ARGUMENT_ERROR("Index exceeds matrix dimensions.");
            }

            return sliceZ(inRow, inCol, inSliceZ);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @return DataCube
        ///
        DataCube<dtype> sliceZAllat(Slice inRow, Slice inCol) const
        {
            if (inRow.numElements(elementShape_.rows) > elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            if (inCol.numElements(elementShape_.cols) > elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            return sliceZAll(inRow, inCol);
        }

        /// Slices the z dimension of the cube with bounds checking
        ///
        /// @param inRow
        /// @param inCol
        /// @param inSliceZ: the slice dimensions of the z-axis
        /// @return DataCube
        ///
        DataCube<dtype> sliceZat(Slice inRow, Slice inCol, Slice inSliceZ) const
        {
            if (inRow.numElements(elementShape_.rows) > elementShape_.rows)
            {
                THROW_INVALID_ARGUMENT_ERROR("inRow exceeds matrix dimensions.");
            }

            if (inCol.numElements(elementShape_.cols) > elementShape_.cols)
            {
                THROW_INVALID_ARGUMENT_ERROR("inCol exceeds matrix dimensions.");
            }

            auto numElements = inSliceZ.numElements(sizeZ());
            if (numElements > sizeZ())
            {
                THROW_INVALID_ARGUMENT_ERROR("Index exceeds matrix dimensions.");
            }

            return sliceZ(inRow, inCol, inSliceZ);
        }

        /// Access operator, no bounds checking.  Returns the 2d z "slice" element of the cube.
        ///
        /// @param inIndex
        ///
        /// @return NdArray
        ///
        NdArray<dtype>& operator[](uint32 inIndex) noexcept
        {
            return cube_[inIndex];
        }

        /// Const access operator, no bounds checking. Returns the 2d z "slice" element of the cube.
        ///
        /// @param inIndex
        ///
        /// @return NdArray
        ///
        const NdArray<dtype>& operator[](uint32 inIndex) const noexcept
        {
            return cube_[inIndex];
        }

    private:
        //================================Attributes==================================
        std::vector<NdArray<dtype>> cube_{};
        Shape                       elementShape_{ 0, 0 };
    };
} // namespace nc

/*** End of inlined file: DataCube.hpp ***/


/*** Start of inlined file: Version.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Library version
///
#pragma once

namespace nc
{
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    constexpr char VERSION[] = "2.12.1"; ///< Current NumCpp version number
} // namespace nc

/*** End of inlined file: Version.hpp ***/


/*** Start of inlined file: Timer.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A timer class for timing code execution
///
#pragma once

#include <chrono>
#include <iostream>
#include <string>
#include <thread>
#include <type_traits>

namespace nc
{

    /// A timer class for timing code execution
    template<typename TimeUnit = std::chrono::milliseconds>
    class Timer
    {
    public:
        //==============================Typedefs======================================
        using ChronoClock = std::chrono::steady_clock;
        using TimePoint   = std::chrono::time_point<ChronoClock>;

        // Method Description:
        /// Constructor
        ///
        Timer() :
            start_(ChronoClock::now())
        {
            setUnits();
        }

        // Method Description:
        /// Constructor
        ///
        /// @param inName
        ///
        explicit Timer(const std::string& inName) :
            name_(inName + " "),
            start_(ChronoClock::now())
        {
            setUnits();
        }

        // Method Description:
        /// Sets/changes the timer name
        ///
        /// @param inName
        ///
        void setName(const std::string& inName)
        {
            name_ = inName + " ";
        }

        // Method Description:
        /// Sleeps the current thread
        ///
        /// @param length: the length of time to sleep
        ///
        void sleep(uint32 length)
        {
            std::this_thread::sleep_for(TimeUnit(length));
        }

        // Method Description:
        /// Starts the timer
        ///
        void tic() noexcept
        {
            start_ = ChronoClock::now();
        }

        // Method Description:
        /// Stops the timer
        ///
        /// @param printElapsedTime: whether or not to print the elapsed time to
        /// the console
        /// @return ellapsed time in specified time units
        ///
        TimeUnit toc(PrintElapsedTime printElapsedTime = PrintElapsedTime::YES)
        {
            const auto duration = std::chrono::duration_cast<TimeUnit>(ChronoClock::now() - start_);

            if (printElapsedTime == PrintElapsedTime::YES)
            {
                std::cout << name_ << "Elapsed Time = " << duration.count() << unit_ << std::endl;
            }

            return duration;
        }

    private:
        //==============================Attributes====================================
        std::string name_{ "" };
        std::string unit_{ "" };
        TimePoint   start_{};

        void setUnits()
        {
            if constexpr (std::is_same_v<TimeUnit, std::chrono::hours>)
            {
                unit_ = " hours";
            }
            else if constexpr (std::is_same_v<TimeUnit, std::chrono::minutes>)
            {
                unit_ = " minutes";
            }
            else if constexpr (std::is_same_v<TimeUnit, std::chrono::seconds>)
            {
                unit_ = " seconds";
            }
            else if constexpr (std::is_same_v<TimeUnit, std::chrono::milliseconds>)
            {
                unit_ = " milliseconds";
            }
            else if constexpr (std::is_same_v<TimeUnit, std::chrono::microseconds>)
            {
                unit_ = " microseconds";
            }
            else if constexpr (std::is_same_v<TimeUnit, std::chrono::nanoseconds>)
            {
                unit_ = " nanoseconds";
            }
            else
            {
                unit_ = " time units of some sort";
            }
        }
    };
} // namespace nc

/*** End of inlined file: Timer.hpp ***/

/*** End of inlined file: Core.hpp ***/


/*** Start of inlined file: DateTime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// NumCpp DateTime module
///
#pragma once


/*** Start of inlined file: Clock.hpp ***/
#pragma once

#include <chrono>
#include <iostream>

namespace nc
{
    /**
     * @brief Clock Type
     */
    using Clock = std::chrono::system_clock;

    /**
     * @brief Duration Type
     */
    using Duration = std::chrono::nanoseconds;

    /**
     * @brief TimePoint Type
     */
    using TimePoint = std::chrono::time_point<Clock, Duration>;

    /**
     * @brief Output stream operator for the Duration type
     *
     * @param os: the output stream
     * @param duration: the Duration
     * @returns std::ostream
     */
    inline std::ostream& operator<<(std::ostream& os, Duration duration)
    {
        os << duration.count() << " nanoseconds";
        return os;
    }

    /**
     * @brief Output stream operator for the TimePoint type
     *
     * @param os: the output stream
     * @param timepoint: the TimePoint
     * @returns std::ostream
     */
    inline std::ostream& operator<<(std::ostream& os, const TimePoint& timepoint)
    {
        os << timepoint.time_since_epoch() << " nanoseconds since epoch";
        return os;
    }

} // namespace nc

/*** End of inlined file: Clock.hpp ***/


/*** Start of inlined file: DateTime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// DateTime module
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <chrono>
#include <ctime>
#include <iostream>
#include <regex>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>

#include "boost/date_time/posix_time/posix_time.hpp"

namespace nc
{

    // Class Description:
    /// Date Time class for working with iso formatted date times
    class DateTime
    {
    public:
        static constexpr int MAX_MONTH  = 12;
        static constexpr int MAX_DAY    = 31;
        static constexpr int MAX_HOUR   = 23;
        static constexpr int MAX_MINUTE = 59;
        static constexpr int MAX_SECOND = 59;

        // Method Description:
        /// Constructor
        ///
        DateTime() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param tp: a timepoint object
        ///
        explicit DateTime(const TimePoint& tp)
        {
            auto tpSubSeconds     = std::chrono::duration_cast<Duration>(tp.time_since_epoch());
            auto fractionalSecond = static_cast<double>(tpSubSeconds.count() % Duration::period::den) /
                                    static_cast<double>(Duration::period::den);
            auto    time = Clock::to_time_t(std::chrono::time_point_cast<Clock::duration>(tp));
            std::tm tm{};
#ifdef _MSC_VER
            gmtime_s(&tm, &time);
#else
            gmtime_r(&time, &tm);
#endif

            setYear(tm.tm_year + TM_EPOCH_YEAR);
            setMonth(tm.tm_mon + 1);
            setDay(tm.tm_mday);
            setHour(tm.tm_hour);
            setMinute(tm.tm_min);
            setSecond(tm.tm_sec);
            setFractionalSecond(fractionalSecond);
        }

        // Method Description:
        /// Constructor
        ///
        /// @param timestamp: an iso formatted datetime string (0001-01-01T00:00:00.00000Z)
        ///
        explicit DateTime(const std::string& timestamp) :
            DateTime(strToTimepoint(timestamp))
        {
        }

        // Method Description:
        /// Constructor
        ///
        ///@param year: year value
        ///@param month: month value
        ///@param day: day value
        ///@param hour: hour value
        ///@param minute: minute value
        ///@param second: second value
        ///@param fractionalSecond: fractionalSecond value
        ///
        DateTime(int year, int month, int day, int hour, int minute, int second, double fractionalSecond = 0.0) noexcept
            :
            year_(year),
            month_(month),
            day_(day),
            hour_(hour),
            minute_(minute),
            second_(second),
            fractionalSecond_(fractionalSecond)
        {
        }

        // Method Description:
        ///@brief year getter
        ///
        ///@return int
        ///
        [[nodiscard]] int year() const noexcept
        {
            return year_;
        }

        // Method Description:
        ///@brief year setter
        ///
        ///@param year: year value
        ///
        void setYear(int year)
        {
            if (year < 0)
            {
                throw std::invalid_argument("input year must be greater than zero");
            }
            year_ = year;
        }

        // Method Description:
        ///@brief month getter
        ///
        ///@return int
        ///
        [[nodiscard]] int month() const noexcept
        {
            return month_;
        }

        // Method Description:
        ///@brief month setter
        ///
        ///@param month: month value
        ///
        void setMonth(int month)
        {
            if (month < 1)
            {
                throw std::invalid_argument("input month must be greater than one");
            }
            if (month > MAX_MONTH)
            {
                throw std::invalid_argument("input month must be less than DateTime::MAX_MONTH");
            }
            month_ = month;
        }

        // Method Description:
        ///@brief day getter
        ///
        ///@return int
        ///
        [[nodiscard]] int day() const noexcept
        {
            return day_;
        }

        // Method Description:
        ///@brief day setter
        ///
        ///@param day: day value
        ///
        void setDay(int day)
        {
            if (day < 1)
            {
                throw std::invalid_argument("input day must be greater than one");
            }
            if (day > MAX_DAY)
            {
                throw std::invalid_argument("input day must be less than DateTime::MAX_DAY");
            }
            day_ = day;
        }

        // Method Description:
        ///@brief hour getter
        ///
        ///@return int
        ///
        [[nodiscard]] int hour() const noexcept
        {
            return hour_;
        }

        // Method Description:
        ///@brief hour setter
        ///
        ///@param hour: hour value
        ///
        void setHour(int hour)
        {
            if (hour < 0)
            {
                throw std::invalid_argument("input hour must be greater than zero");
            }
            if (hour > MAX_HOUR)
            {
                throw std::invalid_argument("input hour must be less than DateTime::MAX_HOUR");
            }
            hour_ = hour;
        }

        // Method Description:
        ///@brief minute getter
        ///
        ///@return int
        ///
        [[nodiscard]] int minute() const noexcept
        {
            return minute_;
        }

        // Method Description:
        ///@brief minute setter
        ///
        ///@param minute: minute value
        ///
        void setMinute(int minute)
        {
            if (minute < 0)
            {
                throw std::invalid_argument("input minute must be greater than zero");
            }
            if (minute > MAX_MINUTE)
            {
                throw std::invalid_argument("input minute must be less than DateTime::MAX_MINUTE");
            }
            minute_ = minute;
        }

        // Method Description:
        ///@brief second getter
        ///
        ///@return int
        ///
        [[nodiscard]] int second() const noexcept
        {
            return second_;
        }

        // Method Description:
        ///@brief second setter
        ///
        ///@param second: second value
        ///
        void setSecond(int second)
        {
            if (second < 0)
            {
                throw std::invalid_argument("input second must be greater than zero");
            }
            if (second > MAX_SECOND)
            {
                throw std::invalid_argument("input second must be less than DateTime::MAX_SECOND");
            }
            second_ = second;
        }

        // Method Description:
        ///@brief fractionalSecond getter
        ///
        ///@return double
        ///
        [[nodiscard]] double fractionalSecond() const noexcept
        {
            return fractionalSecond_;
        }

        // Method Description:
        ///@brief fractionalSecond setter
        ///
        ///@param fractionalSecond: fractionalSecond value
        ///
        void setFractionalSecond(double fractionalSecond)
        {
            if (fractionalSecond < 0. || fractionalSecond >= 1.)
            {
                throw std::invalid_argument("input fractionalSecond must be in the range [0, 1)");
            }
            fractionalSecond_ = fractionalSecond;
        }

        // Method Description:
        ///@brief Converts the struct to a TimePoint
        ///
        ///@returns TimePoint
        ///
        [[nodiscard]] TimePoint toTimePoint() const
        {
            std::tm t{};
            t.tm_year      = year_ - TM_EPOCH_YEAR;
            t.tm_mon       = month_ - 1; // tm is 0 based months
            t.tm_mday      = day_;
            t.tm_hour      = hour_;
            t.tm_min       = minute_;
            t.tm_sec       = second_;
            auto timePoint = Clock::from_time_t(
#ifdef _MSC_VER
                _mkgmtime
#else
                timegm
#endif
                (&t));
            return std::chrono::time_point_cast<TimePoint::duration>(timePoint) +
                   std::chrono::nanoseconds(static_cast<int64_t>(fractionalSecond_ * SECONDS_TO_NANOSECONDS));
        }

        // Method Description:
        ///@brief Converts the struct to an iso string
        ///
        ///@returns std::string
        ///
        [[nodiscard]] std::string toStr() const
        {
            const auto timePoint         = toTimePoint();
            const auto timeSinceEpoch    = timePoint.time_since_epoch().count();
            time_t     secondsFromEpoch  = timeSinceEpoch / Duration::period::den;
            const auto fractionalSeconds = static_cast<double>(timeSinceEpoch % Duration::period::den) /
                                           static_cast<double>(Duration::period::den);

            std::tm tm{};
#ifdef _MSC_VER
            gmtime_s(&tm, &secondsFromEpoch);
#else
            gmtime_r(&secondsFromEpoch, &tm);
#endif

            std::stringstream ss;
            if (fractionalSeconds > 0)
            {
                const auto        format = "%Y-%m-%dT%H:%M:%S.%msZ";
                std::stringstream ssFractionalSecond;
                ssFractionalSecond.precision(NANO_SECOND_PRECESION);
                ssFractionalSecond << std::fixed << fractionalSeconds;
                auto fractionalSecondStr = ssFractionalSecond.str();
                // strip of the preceding "0." and any trailing zeros
                fractionalSecondStr = fractionalSecondStr.substr(2, fractionalSecondStr.size());
                fractionalSecondStr = fractionalSecondStr.substr(0, fractionalSecondStr.find_last_not_of('0') + 1);
                const auto fractionalSecondsFormat = std::regex_replace(format, std::regex("%ms"), fractionalSecondStr);
                ss << std::put_time(&tm, fractionalSecondsFormat.c_str());
            }
            else
            {
                const auto format = "%Y-%m-%dT%H:%M:%SZ";
                ss << std::put_time(&tm, format);
            }

            return ss.str();
        }

        // Method Description:
        ///@brief Factory static method for returning a DateTime object
        ///       cooresponding to the system clock now.
        ///
        ///@returns DateTime
        ///
        [[nodiscard]] static DateTime now() noexcept
        {
            return DateTime(Clock::now());
        }

        // Method Description:
        ///@brief Converts the struct to an iso string
        ///@param timestamp: an iso formatted datetime string (0001-01-01T00:00:00.00000Z)
        ///@returns Timepoint
        ///
        static TimePoint strToTimepoint(const std::string& timestamp)
        {
            const std::regex regexIsoTime{ R"(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(.\d+)?Z)" };
            if (!std::regex_match(timestamp, regexIsoTime))
            {
                throw std::invalid_argument("Invalid iso timestamp format");
            }

            auto convertedTime = boost::posix_time::ptime{};
            try
            {
                convertedTime = boost::posix_time::from_iso_extended_string(timestamp.substr(0, timestamp.size() - 1));
            }
            catch (...)
            {
                throw std::invalid_argument("Invalid iso timestamp format");
            }

            const auto fromEpoch = convertedTime - POSIX_EPOCH;
            return TimePoint{ Duration{ fromEpoch.total_nanoseconds() } };
        }

    private:
        static constexpr int                         TM_EPOCH_YEAR    = 1900;
        static constexpr int                         POSIX_EPOCH_YEAR = 1970;
        static inline const std::string              POSIX_EPOCH_STR{ "1970-01-01T00:00:00" };
        static inline const boost::posix_time::ptime POSIX_EPOCH{ boost::posix_time::from_iso_extended_string(
            POSIX_EPOCH_STR) };
        static constexpr double                      SECONDS_TO_NANOSECONDS = 1e9;
        static constexpr int                         NANO_SECOND_PRECESION  = 9;

        /// years since 1
        int year_{ POSIX_EPOCH_YEAR };
        /// [1, 12]
        int month_{ 1 };
        /// [1, 31]
        int day_{ 1 };
        /// [0, 23]
        int hour_{ 0 };
        /// [0, 59]
        int minute_{ 0 };
        /// [0, 59]
        int second_{ 0 };
        /// [0, 1)
        double fractionalSecond_{ 0.0 };
    };

    // Method Description:
    ///@brief Equality operator for DateTime
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator==(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() == rhs.toTimePoint();
    }

    // Method Description:
    ///@brief Non Equality operator for DateTime
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator!=(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return !(lhs == rhs);
    }

    // Method Description:
    ///@brief Less than operator
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator<(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() < rhs.toTimePoint();
    }

    // Method Description:
    ///@brief Less than or equal operator
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator<=(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() <= rhs.toTimePoint();
    }

    // Method Description:
    ///@brief Greater than operator
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator>(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() > rhs.toTimePoint();
    }

    // Method Description:
    ///@brief Greater than or equal operator
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline bool operator>=(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() >= rhs.toTimePoint();
    }

    // Method Description:
    ///@brief Subtraction operator
    ///
    ///@param lhs: the left hand side value
    ///@param rhs: the right hand side value
    ///@returns bool
    ///
    [[nodiscard]] inline Duration operator-(const DateTime& lhs, const DateTime& rhs) noexcept
    {
        return lhs.toTimePoint() - rhs.toTimePoint();
    }

    // Method Description:
    /// @brief Stream operator
    ///
    /// @param os: the output stream
    /// @param datetime: the datetime object
    /// @returns ostream
    ///
    inline std::ostream& operator<<(std::ostream& os, const DateTime& datetime) noexcept
    {
        os << "DateTime:\n";
        os << "\tyear: " << datetime.year() << '\n';
        os << "\tmonth: " << datetime.month() << '\n';
        os << "\tday: " << datetime.day() << '\n';
        os << "\thour: " << datetime.hour() << '\n';
        os << "\tminute: " << datetime.minute() << '\n';
        os << "\tsecond: " << datetime.second() << '\n';
        os << "\tfractionalSecond: " << datetime.fractionalSecond() << '\n';
        return os;
    }
} // namespace nc

#endif

/*** End of inlined file: DateTime.hpp ***/

/*** End of inlined file: DateTime.hpp ***/


/*** Start of inlined file: Filter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Image and signal filtering module
///
#pragma once


/*** Start of inlined file: Boundary.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Boundary condition to apply to the image filter
///
#pragma once

namespace nc::filter
{

    // Enum Description:
    /// Boundary condition to apply to the image filter
    enum class Boundary
    {
        REFLECT = 0,
        CONSTANT,
        NEAREST,
        MIRROR,
        WRAP
    };
} // namespace nc::filter

/*** End of inlined file: Boundary.hpp ***/


/*** Start of inlined file: complementaryMeanFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculate a one-dimensional complemenatry mean filter.
///
#pragma once


/*** Start of inlined file: meanFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional mean filter.
///
#pragma once


/*** Start of inlined file: addBoundary1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Wrap boundary
///
#pragma once

#include <string>


/*** Start of inlined file: constant1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Constant boundary1d
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Constant boundary1d
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @param inConstantValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> constant1d(const NdArray<dtype>& inImage, uint32 inBoundarySize, dtype inConstantValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 outSize = inImage.size() + inBoundarySize * 2;

        NdArray<dtype> outArray(1, outSize);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inImage.size()), inImage);

        // left
        outArray.put(Slice(0, inBoundarySize), inConstantValue);

        // right
        outArray.put(Slice(inImage.size() + inBoundarySize, outSize), inConstantValue);

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: constant1d.hpp ***/


/*** Start of inlined file: mirror1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Mirror boundary1d
///
#pragma once


/*** Start of inlined file: fliplr.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: flip.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Reverse the order of elements in an array along the given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.flip.html
    ///
    /// @param inArray
    /// @param inAxis
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> flip(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        switch (inAxis)
        {
            case Axis::NONE:
            {
                NdArray<dtype> returnArray(inArray);
                stl_algorithms::reverse(returnArray.begin(), returnArray.end());
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<dtype> returnArray(inArray);
                for (uint32 row = 0; row < inArray.shape().rows; ++row)
                {
                    stl_algorithms::reverse(returnArray.begin(row), returnArray.end(row));
                }
                return returnArray;
            }
            case Axis::ROW:
            {
                return flip(inArray.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: flip.hpp ***/

namespace nc
{

    // Method Description:
    /// Flip array in the left/right direction.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fliplr.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fliplr(const NdArray<dtype>& inArray)
    {
        return flip(inArray, Axis::COL);
    }
} // namespace nc

/*** End of inlined file: fliplr.hpp ***/

namespace nc::filter::boundary
{

    // Method Description:
    /// Mirror boundary1d
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> mirror1d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 outSize = inImage.size() + inBoundarySize * 2;

        NdArray<dtype> outArray(1, outSize);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inImage.size()), inImage);

        // left
        outArray.put(Slice(0, inBoundarySize), fliplr(inImage[Slice(1, inBoundarySize + 1)]));

        // right
        outArray.put(Slice(inImage.size() + inBoundarySize, outSize),
                     fliplr(inImage[Slice(-static_cast<int32>(inBoundarySize) - 1, -1)]));

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: mirror1d.hpp ***/


/*** Start of inlined file: nearest1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Nearest boundary1d
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Nearest boundary1d
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nearest1d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 outSize = inImage.size() + inBoundarySize * 2;

        NdArray<dtype> outArray(1, outSize);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inImage.size()), inImage);

        // left
        outArray.put(Slice(0, inBoundarySize), inImage.front());

        // right
        outArray.put(Slice(inImage.size() + inBoundarySize, outSize), inImage.back());

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: nearest1d.hpp ***/


/*** Start of inlined file: reflect1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Reflects the boundaries
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Reflects the boundaries
    ///
    /// @param inImage
    /// @param inBoundarySize
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> reflect1d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 outSize = inImage.size() + inBoundarySize * 2;

        NdArray<dtype> outArray(1, outSize);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inImage.size()), inImage);

        // left
        outArray.put(Slice(0, inBoundarySize), fliplr(inImage[Slice(0, inBoundarySize)]));

        // right
        outArray.put(Slice(inImage.size() + inBoundarySize, outSize),
                     fliplr(inImage[Slice(-static_cast<int32>(inBoundarySize), inImage.size())]));

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: reflect1d.hpp ***/


/*** Start of inlined file: wrap1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Wrap boundary1d
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Wrap boundary1d
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> wrap1d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 outSize = inImage.size() + inBoundarySize * 2;

        NdArray<dtype> outArray(1, outSize);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inImage.size()), inImage);

        // left
        outArray.put(Slice(0, inBoundarySize), inImage[Slice(inImage.size() - inBoundarySize, inImage.size())]);

        // right
        outArray.put(Slice(inImage.size() + inBoundarySize, outSize), inImage[Slice(0, inBoundarySize)]);

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: wrap1d.hpp ***/

namespace nc::filter::boundary
{

    // Method Description:
    /// Wrap boundary
    ///
    /// @param inImage
    /// @param inBoundaryType
    /// @param inKernalSize
    /// @param inConstantValue (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> addBoundary1d(const NdArray<dtype>& inImage,
                                 Boundary              inBoundaryType,
                                 uint32                inKernalSize,
                                 dtype                 inConstantValue = 0)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inKernalSize % 2 == 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("input kernal size must be an odd value.");
        }

        const uint32 boundarySize = inKernalSize / 2; // integer division

        switch (inBoundaryType)
        {
            case Boundary::REFLECT:
            {
                return reflect1d(inImage, boundarySize);
            }
            case Boundary::CONSTANT:
            {
                return constant1d(inImage, boundarySize, inConstantValue);
            }
            case Boundary::NEAREST:
            {
                return nearest1d(inImage, boundarySize);
            }
            case Boundary::MIRROR:
            {
                return mirror1d(inImage, boundarySize);
            }
            case Boundary::WRAP:
            {
                return wrap1d(inImage, boundarySize);
            }
            default:
            {
                // This can't actually happen but just adding to get rid of compiler warning
                THROW_INVALID_ARGUMENT_ERROR("ERROR!");
            }
        }

        return NdArray<dtype>(); // get rid of compiler warning
    }
} // namespace nc::filter::boundary

/*** End of inlined file: addBoundary1d.hpp ***/


/*** Start of inlined file: mean.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>
#include <numeric>

namespace nc
{

    // Method Description:
    /// Compute the mean along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.mean.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> mean(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                auto            sum         = std::accumulate(inArray.cbegin(), inArray.cend(), 0.);
                NdArray<double> returnArray = { sum /= static_cast<double>(inArray.size()) };

                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    auto sum            = std::accumulate(inArray.cbegin(row), inArray.cend(row), 0.);
                    returnArray(0, row) = sum / static_cast<double>(inArray.numCols());
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return mean(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {};
            }
        }
    }

    // Method Description:
    /// Compute the mean along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.mean.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> mean(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                auto sum = std::accumulate(inArray.cbegin(), inArray.cend(), std::complex<double>(0.));
                NdArray<std::complex<double>> returnArray = { sum /= std::complex<double>(inArray.size()) };

                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<std::complex<double>> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    auto sum = std::accumulate(inArray.cbegin(row), inArray.cend(row), std::complex<double>(0.));
                    returnArray(0, row) = sum / std::complex<double>(inArray.numCols());
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                NdArray<std::complex<double>> transposedArray = inArray.transpose();
                NdArray<std::complex<double>> returnArray(1, transposedArray.numRows());
                for (uint32 row = 0; row < transposedArray.numRows(); ++row)
                {
                    auto sum            = std::accumulate(transposedArray.cbegin(row),
                                               transposedArray.cend(row),
                                               std::complex<double>(0.));
                    returnArray(0, row) = sum / std::complex<double>(transposedArray.numCols());
                }

                return returnArray;
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: mean.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional mean filter.
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> meanFilter1d(const NdArray<dtype>& inImageArray,
                                 uint32                inSize,
                                 Boundary              inBoundaryType  = Boundary::REFLECT,
                                 dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<double> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = mean(window).item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: meanFilter1d.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculate a one-dimensional complemenatry mean filter.
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> complementaryMeanFilter1d(const NdArray<dtype>& inImageArray,
                                              uint32                inSize,
                                              Boundary              inBoundaryType  = Boundary::REFLECT,
                                              dtype                 inConstantValue = 0)
    {
        auto inImageArrayCopy = inImageArray.template astype<double>();
        inImageArrayCopy -= meanFilter1d(inImageArray, inSize, inBoundaryType, inConstantValue);

        return inImageArrayCopy;
    }
} // namespace nc::filter

/*** End of inlined file: complementaryMeanFilter1d.hpp ***/


/*** Start of inlined file: complementaryMedianFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculate a one-dimensional complemenatry median filter.
///
#pragma once


/*** Start of inlined file: medianFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional median filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional median filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> medianFilter1d(const NdArray<dtype>& inImageArray,
                                  uint32                inSize,
                                  Boundary              inBoundaryType  = Boundary::REFLECT,
                                  dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = window.median().item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: medianFilter1d.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculate a one-dimensional complemenatry median filter.
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> complementaryMedianFilter1d(const NdArray<dtype>& inImageArray,
                                               uint32                inSize,
                                               Boundary              inBoundaryType  = Boundary::REFLECT,
                                               dtype                 inConstantValue = 0)
    {
        NdArray<dtype> inImageArrayCopy(inImageArray);
        inImageArrayCopy -= medianFilter1d(inImageArray, inSize, inBoundaryType, inConstantValue);

        return inImageArrayCopy;
    }
} // namespace nc::filter

/*** End of inlined file: complementaryMedianFilter1d.hpp ***/


/*** Start of inlined file: convolve1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional kernel convolution.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional kernel convolution.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d
    ///
    /// @param inImageArray
    /// @param inWeights
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> convolve1d(const NdArray<dtype>& inImageArray,
                              const NdArray<dtype>& inWeights,
                              Boundary              inBoundaryType  = Boundary::REFLECT,
                              dtype                 inConstantValue = 0)
    {
        const uint32   boundarySize = inWeights.size() / 2; // integer division
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inWeights.size(), inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        NdArray<dtype> weightsFlat = fliplr(inWeights.flatten());

        const uint32 endPointRow = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPointRow; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)].flatten();

            output[i - boundarySize] = dot(window, weightsFlat).item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: convolve1d.hpp ***/


/*** Start of inlined file: gaussianFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculate a one-dimensional gaussian filter.
///
#pragma once

#include <cmath>
#include <string>


/*** Start of inlined file: gaussian1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// samples a 1D gaussian of input mean and sigma
///
#pragma once

#include <cmath>

namespace nc::utils
{

    // Method Description:
    /// samples a 1D gaussian of input mean and sigma
    ///
    /// @param inX
    /// @param inMu
    /// @param inSigma
    ///
    /// @return dtype
    ///
    inline double gaussian1d(double inX, double inMu, double inSigma) noexcept
    {
        double exponent = sqr(inX - inMu);
        exponent /= 2;
        exponent /= sqr(inSigma);
        return std::exp(-exponent);
    }
} // namespace nc::utils

/*** End of inlined file: gaussian1d.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculate a one-dimensional gaussian filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    ///
    /// @param inImageArray
    /// @param inSigma: Standard deviation for Gaussian kernel
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> gaussianFilter1d(const NdArray<dtype>& inImageArray,
                                    double                inSigma,
                                    Boundary              inBoundaryType  = Boundary::REFLECT,
                                    dtype                 inConstantValue = 0)
    {
        if (inSigma <= 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("input sigma value must be greater than zero.");
        }

        // calculate the kernel size based off of the input sigma value
        constexpr uint32 MIN_KERNEL_SIZE = 5;
        uint32           kernelSize =
            std::max(static_cast<uint32>(std::ceil(inSigma * 2. * 4.)), MIN_KERNEL_SIZE); // 4 standard deviations
        if (kernelSize % 2 == 0)
        {
            ++kernelSize; // make sure the kernel is an odd size
        }

        const auto kernalHalfSize = static_cast<double>(kernelSize / 2); // integer division

        // calculate the gaussian kernel
        NdArray<double> kernel(1, kernelSize);
        for (double i = 0; i < kernelSize; ++i)
        {
            kernel[static_cast<uint32>(i)] = utils::gaussian1d(i - kernalHalfSize, 0., inSigma);
        }

        // normalize the kernel
        kernel /= kernel.sum().item();

        // perform the convolution
        NdArray<dtype> output =
            convolve1d(inImageArray.template astype<double>(), kernel, inBoundaryType, inConstantValue)
                .template astype<dtype>();

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: gaussianFilter1d.hpp ***/


/*** Start of inlined file: maximumFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional maximum filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional maximum filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> maximumFilter1d(const NdArray<dtype>& inImageArray,
                                   uint32                inSize,
                                   Boundary              inBoundaryType  = Boundary::REFLECT,
                                   dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = window.max().item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: maximumFilter1d.hpp ***/


/*** Start of inlined file: minimumFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional minumum filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional minumum filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> minumumFilter1d(const NdArray<dtype>& inImageArray,
                                   uint32                inSize,
                                   Boundary              inBoundaryType  = Boundary::REFLECT,
                                   dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = window.min().item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: minimumFilter1d.hpp ***/


/*** Start of inlined file: percentileFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional percentile filter.
///
#pragma once


/*** Start of inlined file: percentile.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>
#include <string>


/*** Start of inlined file: argmin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns the indices of the minimum values along an axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.argmin.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> argmin(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.argmin(inAxis);
    }
} // namespace nc

/*** End of inlined file: argmin.hpp ***/

namespace nc
{

    // Method Description:
    /// Compute the qth percentile of the data along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.percentile.html
    ///
    /// @param inArray
    /// @param inPercentile: percentile must be in the range [0, 100]
    /// @param inAxis (Optional, default NONE)
    /// @param inInterpMethod (Optional) interpolation method
    /// linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.
    /// lower : i.
    /// higher : j.
    /// nearest : i or j, whichever is nearest.
    /// midpoint : (i + j) / 2.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> percentile(const NdArray<dtype>& inArray,
                               double                inPercentile,
                               Axis                  inAxis         = Axis::NONE,
                               InterpolationMethod   inInterpMethod = InterpolationMethod::LINEAR)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inPercentile < 0. || inPercentile > 100.)
        {
            THROW_INVALID_ARGUMENT_ERROR("input percentile value must be of the range [0, 100].");
        }

        if (inArray.isempty())
        {
            return {};
        }
        else if (inArray.isscalar())
        {
            NdArray<double> returnArray = { static_cast<double>(inArray.front()) };
            return returnArray;
        }

        switch (inAxis)
        {
            case Axis::NONE:
            {
                NdArray<double> arrayCopy = inArray.template astype<double>();
                stl_algorithms::sort(arrayCopy.begin(), arrayCopy.end());

                if (utils::essentiallyEqual(inPercentile, 0.))
                {
                    NdArray<double> returnArray = { arrayCopy.front() };
                    return returnArray;
                }
                if (utils::essentiallyEqual(inPercentile, 100.))
                {
                    NdArray<double> returnArray = { arrayCopy.back() };
                    return returnArray;
                }

                const auto i =
                    static_cast<uint32>(std::floor(static_cast<double>(inArray.size() - 1) * inPercentile / 100.));
                const auto indexLower = clip<uint32>(i, 0, inArray.size() - 2);

                switch (inInterpMethod)
                {
                    case InterpolationMethod::LINEAR:
                    {
                        const double percentI =
                            static_cast<double>(indexLower) / static_cast<double>(inArray.size() - 1);
                        const double fraction =
                            (inPercentile / 100. - percentI) /
                            (static_cast<double>(indexLower + 1) / static_cast<double>(inArray.size() - 1) - percentI);

                        NdArray<double> returnArray = {
                            arrayCopy[indexLower] + (arrayCopy[indexLower + 1] - arrayCopy[indexLower]) * fraction
                        };
                        return returnArray;
                    }
                    case InterpolationMethod::LOWER:
                    {
                        NdArray<double> returnArray = { arrayCopy[indexLower] };
                        return returnArray;
                    }
                    case InterpolationMethod::HIGHER:
                    {
                        NdArray<double> returnArray = { arrayCopy[indexLower + 1] };
                        return returnArray;
                    }
                    case InterpolationMethod::NEAREST:
                    {
                        const double percent = inPercentile / 100.;
                        const double percent1 =
                            static_cast<double>(indexLower) / static_cast<double>(inArray.size() - 1);
                        const double percent2 =
                            static_cast<double>(indexLower + 1) / static_cast<double>(inArray.size() - 1);
                        const double diff1 = percent - percent1;
                        const double diff2 = percent2 - percent;

                        switch (argmin<double>({ diff1, diff2 }).item())
                        {
                            case 0:
                            {
                                NdArray<double> returnArray = { arrayCopy[indexLower] };
                                return returnArray;
                            }
                            case 1:
                            {
                                NdArray<double> returnArray = { arrayCopy[indexLower + 1] };
                                return returnArray;
                            }
                        }

                        return {}; // get rid of compiler warning
                    }
                    case InterpolationMethod::MIDPOINT:
                    {
                        NdArray<double> returnArray = { (arrayCopy[indexLower] + arrayCopy[indexLower + 1]) / 2. };
                        return returnArray;
                    }
                    default:
                    {
                        THROW_INVALID_ARGUMENT_ERROR("Unimplemented Interpolation method.");
                        return {}; // get rid of compiler warning
                    }
                }
            }
            case Axis::COL:
            {
                const Shape inShape = inArray.shape();

                NdArray<double> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    returnArray[row] =
                        percentile(NdArray<dtype>(const_cast<typename NdArray<dtype>::pointer>(&inArray.front(row)),
                                                  inShape.cols,
                                                  PointerPolicy::SHELL),
                                   inPercentile,
                                   Axis::NONE,
                                   inInterpMethod)
                            .item();
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return percentile(inArray.transpose(), inPercentile, Axis::COL, inInterpMethod);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }

        return {}; // get rid of compiler warning
    }
} // namespace nc

/*** End of inlined file: percentile.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional percentile filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inPercentile: percentile [0, 100]
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> percentileFilter1d(const NdArray<dtype>& inImageArray,
                                      uint32                inSize,
                                      double                inPercentile,
                                      Boundary              inBoundaryType  = Boundary::REFLECT,
                                      dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = percentile(window, inPercentile).item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: percentileFilter1d.hpp ***/


/*** Start of inlined file: rankFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional rank filter.
///
#pragma once


/*** Start of inlined file: sort.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a sorted copy of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sort.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> sort(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        NdArray<dtype> returnArray(inArray);
        returnArray.sort(inAxis);
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sort.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional rank filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inRank: ([0, inSize^2 - 1])
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> rankFilter1d(const NdArray<dtype>& inImageArray,
                                uint32                inSize,
                                uint8                 inRank,
                                Boundary              inBoundaryType  = Boundary::REFLECT,
                                dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = sort(window)[inRank];
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: rankFilter1d.hpp ***/


/*** Start of inlined file: uniformFilter1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a one-dimensional uniform filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a one-dimensional uniform filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d
    ///
    /// @param inImageArray
    /// @param inSize: linear size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> uniformFilter1d(const NdArray<dtype>& inImageArray,
                                   uint32                inSize,
                                   Boundary              inBoundaryType  = Boundary::REFLECT,
                                   dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary1d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(1, inImageArray.size());

        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPoint     = boundarySize + inImageArray.size();

        for (uint32 i = boundarySize; i < endPoint; ++i)
        {
            NdArray<dtype> window = arrayWithBoundary[Slice(i - boundarySize, i + boundarySize + 1)];

            output[i - boundarySize] = mean(window).item();
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: uniformFilter1d.hpp ***/


/*** Start of inlined file: complementaryMeanFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional complemenatry mean filter.
///
#pragma once


/*** Start of inlined file: meanFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional mean filter.
///
#pragma once


/*** Start of inlined file: addBoundary2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Wrap boundary
///
#pragma once

#include <string>


/*** Start of inlined file: constant2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Constant boundary
///
#pragma once


/*** Start of inlined file: fillCorners.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// extends the corner values
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// extends the corner values
    ///
    /// @param inArray
    /// @param inBorderWidth
    ///
    template<typename dtype>
    void fillCorners(NdArray<dtype>& inArray, uint32 inBorderWidth)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inArray.shape();
        const auto  numRows = static_cast<int32>(inShape.rows);
        const auto  numCols = static_cast<int32>(inShape.cols);

        // top left
        inArray.put(Slice(0, inBorderWidth), Slice(0, inBorderWidth), inArray(inBorderWidth, inBorderWidth));

        // top right
        inArray.put(Slice(0, inBorderWidth),
                    Slice(numCols - inBorderWidth, numCols),
                    inArray(inBorderWidth, numCols - inBorderWidth - 1));

        // bottom left
        inArray.put(Slice(numRows - inBorderWidth, numRows),
                    Slice(0, inBorderWidth),
                    inArray(numRows - inBorderWidth - 1, inBorderWidth));

        // bottom right
        inArray.put(Slice(numRows - inBorderWidth, numRows),
                    Slice(numCols - inBorderWidth, numCols),
                    inArray(numRows - inBorderWidth - 1, numCols - inBorderWidth - 1));
    }

    // Method Description:
    /// extends the corner values
    ///
    /// @param inArray
    /// @param inBorderWidth
    /// @param inFillValue
    ///
    template<typename dtype>
    void fillCorners(NdArray<dtype>& inArray, uint32 inBorderWidth, dtype inFillValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inArray.shape();
        const auto  numRows = static_cast<int32>(inShape.rows);
        const auto  numCols = static_cast<int32>(inShape.cols);

        // top left
        inArray.put(Slice(0, inBorderWidth), Slice(0, inBorderWidth), inFillValue);

        // top right
        inArray.put(Slice(0, inBorderWidth), Slice(numCols - inBorderWidth, numCols), inFillValue);

        // bottom left
        inArray.put(Slice(numRows - inBorderWidth, numRows), Slice(0, inBorderWidth), inFillValue);

        // bottom right
        inArray.put(Slice(numRows - inBorderWidth, numRows), Slice(numCols - inBorderWidth, numCols), inFillValue);
    }
} // namespace nc::filter::boundary

/*** End of inlined file: fillCorners.hpp ***/

namespace nc::filter::boundary
{

    // Method Description:
    /// Constant boundary
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @param inConstantValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> constant2d(const NdArray<dtype>& inImage, uint32 inBoundarySize, dtype inConstantValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inImage.shape();
        Shape       outShape(inShape);
        outShape.rows += inBoundarySize * 2;
        outShape.cols += inBoundarySize * 2;

        NdArray<dtype> outArray(outShape);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage);
        fillCorners(outArray, inBoundarySize, inConstantValue);

        outArray.put(Slice(0, inBoundarySize),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inConstantValue); /// bottom
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inConstantValue); /// top
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(0, inBoundarySize),
                     inConstantValue); /// left
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(outShape.cols - inBoundarySize, outShape.cols),
                     inConstantValue); /// right

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: constant2d.hpp ***/


/*** Start of inlined file: mirror2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Mirror boundary
///
#pragma once


/*** Start of inlined file: flipud.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Flip array in the up/down direction.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.flipud.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> flipud(const NdArray<dtype>& inArray)
    {
        return flip(inArray, Axis::ROW);
    }
} // namespace nc

/*** End of inlined file: flipud.hpp ***/

namespace nc::filter::boundary
{

    // Method Description:
    /// Mirror boundary
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> mirror2d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inImage.shape();
        Shape       outShape(inShape);
        outShape.rows += inBoundarySize * 2;
        outShape.cols += inBoundarySize * 2;

        NdArray<dtype> outArray(outShape);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage);

        for (uint32 row = 0; row < inBoundarySize; ++row)
        {
            // bottom
            outArray.put(row,
                         Slice(inBoundarySize, inBoundarySize + inShape.cols),
                         inImage(inBoundarySize - row, Slice(0, inShape.cols)));

            // top
            outArray.put(row + inBoundarySize + inShape.rows,
                         Slice(inBoundarySize, inBoundarySize + inShape.cols),
                         inImage(inShape.rows - row - 2, Slice(0, inShape.cols)));
        }

        for (uint32 col = 0; col < inBoundarySize; ++col)
        {
            // left
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                         col,
                         inImage(Slice(0, inShape.rows), inBoundarySize - col));

            // right
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                         col + inBoundarySize + inShape.cols,
                         inImage(Slice(0, inShape.rows), inShape.cols - col - 2));
        }

        // now fill in the corners
        NdArray<dtype> lowerLeft =
            flipud(outArray(Slice(inBoundarySize + 1, 2 * inBoundarySize + 1), Slice(0, inBoundarySize)));
        NdArray<dtype> lowerRight = flipud(outArray(Slice(inBoundarySize + 1, 2 * inBoundarySize + 1),
                                                    Slice(outShape.cols - inBoundarySize, outShape.cols)));

        const uint32   upperRowStart = outShape.rows - 2 * inBoundarySize - 1;
        NdArray<dtype> upperLeft =
            flipud(outArray(Slice(upperRowStart, upperRowStart + inBoundarySize), Slice(0, inBoundarySize)));
        NdArray<dtype> upperRight = flipud(outArray(Slice(upperRowStart, upperRowStart + inBoundarySize),
                                                    Slice(outShape.cols - inBoundarySize, outShape.cols)));

        outArray.put(Slice(0, inBoundarySize), Slice(0, inBoundarySize), lowerLeft);
        outArray.put(Slice(0, inBoundarySize), Slice(outShape.cols - inBoundarySize, outShape.cols), lowerRight);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows), Slice(0, inBoundarySize), upperLeft);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows),
                     Slice(outShape.cols - inBoundarySize, outShape.cols),
                     upperRight);

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: mirror2d.hpp ***/


/*** Start of inlined file: nearest2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Nearest boundary
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Nearest boundary
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nearest2d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inImage.shape();
        Shape       outShape(inShape);
        outShape.rows += inBoundarySize * 2;
        outShape.cols += inBoundarySize * 2;

        NdArray<dtype> outArray(outShape);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage);
        fillCorners(outArray, inBoundarySize);

        for (uint32 row = 0; row < inBoundarySize; ++row)
        {
            // bottom
            outArray.put(row, Slice(inBoundarySize, inBoundarySize + inShape.cols), inImage(0, Slice(0, inShape.cols)));

            // top
            outArray.put(row + inBoundarySize + inShape.rows,
                         Slice(inBoundarySize, inBoundarySize + inShape.cols),
                         inImage(inShape.rows - 1, Slice(0, inShape.cols)));
        }

        for (uint32 col = 0; col < inBoundarySize; ++col)
        {
            // left
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows), col, inImage(Slice(0, inShape.rows), 0));

            // right
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                         col + inBoundarySize + inShape.cols,
                         inImage(Slice(0, inShape.rows), inShape.cols - 1));
        }

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: nearest2d.hpp ***/


/*** Start of inlined file: reflect2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Reflects the boundaries
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Reflects the boundaries
    ///
    /// @param inImage
    /// @param inBoundarySize
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> reflect2d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inImage.shape();
        Shape       outShape(inShape);
        outShape.rows += inBoundarySize * 2;
        outShape.cols += inBoundarySize * 2;

        NdArray<dtype> outArray(outShape);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage);

        for (uint32 row = 0; row < inBoundarySize; ++row)
        {
            // bottom
            outArray.put(row,
                         Slice(inBoundarySize, inBoundarySize + inShape.cols),
                         inImage(inBoundarySize - row - 1, Slice(0, inShape.cols)));

            // top
            outArray.put(row + inBoundarySize + inShape.rows,
                         Slice(inBoundarySize, inBoundarySize + inShape.cols),
                         inImage(inShape.rows - row - 1, Slice(0, inShape.cols)));
        }

        for (uint32 col = 0; col < inBoundarySize; ++col)
        {
            // left
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                         col,
                         inImage(Slice(0, inShape.rows), inBoundarySize - col - 1));

            // right
            outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                         col + inBoundarySize + inShape.cols,
                         inImage(Slice(0, inShape.rows), inShape.cols - col - 1));
        }

        // now fill in the corners
        NdArray<dtype> lowerLeft =
            flipud(outArray(Slice(inBoundarySize, 2 * inBoundarySize), Slice(0, inBoundarySize)));
        NdArray<dtype> lowerRight = flipud(
            outArray(Slice(inBoundarySize, 2 * inBoundarySize), Slice(outShape.cols - inBoundarySize, outShape.cols)));

        const uint32   upperRowStart = outShape.rows - 2 * inBoundarySize;
        NdArray<dtype> upperLeft =
            flipud(outArray(Slice(upperRowStart, upperRowStart + inBoundarySize), Slice(0, inBoundarySize)));
        NdArray<dtype> upperRight = flipud(outArray(Slice(upperRowStart, upperRowStart + inBoundarySize),
                                                    Slice(outShape.cols - inBoundarySize, outShape.cols)));

        outArray.put(Slice(0, inBoundarySize), Slice(0, inBoundarySize), lowerLeft);
        outArray.put(Slice(0, inBoundarySize), Slice(outShape.cols - inBoundarySize, outShape.cols), lowerRight);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows), Slice(0, inBoundarySize), upperLeft);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows),
                     Slice(outShape.cols - inBoundarySize, outShape.cols),
                     upperRight);

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: reflect2d.hpp ***/


/*** Start of inlined file: wrap2d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Wrap boundary
///
#pragma once

namespace nc::filter::boundary
{

    // Method Description:
    /// Wrap boundary
    ///
    /// @param inImage
    /// @param inBoundarySize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> wrap2d(const NdArray<dtype>& inImage, uint32 inBoundarySize)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inImage.shape();
        Shape       outShape(inShape);
        outShape.rows += inBoundarySize * 2;
        outShape.cols += inBoundarySize * 2;

        NdArray<dtype> outArray(outShape);
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage);

        // bottom
        outArray.put(Slice(0, inBoundarySize),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage(Slice(inShape.rows - inBoundarySize, inShape.rows), Slice(0, inShape.cols)));

        // top
        outArray.put(Slice(inShape.rows + inBoundarySize, outShape.rows),
                     Slice(inBoundarySize, inBoundarySize + inShape.cols),
                     inImage(Slice(0, inBoundarySize), Slice(0, inShape.cols)));

        // left
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(0, inBoundarySize),
                     inImage(Slice(0, inShape.rows), Slice(inShape.cols - inBoundarySize, inShape.cols)));

        // right
        outArray.put(Slice(inBoundarySize, inBoundarySize + inShape.rows),
                     Slice(inShape.cols + inBoundarySize, outShape.cols),
                     inImage(Slice(0, inShape.rows), Slice(0, inBoundarySize)));

        // now fill in the corners
        NdArray<dtype> lowerLeft = outArray(Slice(inBoundarySize, 2 * inBoundarySize), Slice(0, inBoundarySize));
        NdArray<dtype> lowerRight =
            outArray(Slice(inBoundarySize, 2 * inBoundarySize), Slice(outShape.cols - inBoundarySize, outShape.cols));

        const uint32   upperRowStart = outShape.rows - 2 * inBoundarySize;
        NdArray<dtype> upperLeft =
            outArray(Slice(upperRowStart, upperRowStart + inBoundarySize), Slice(0, inBoundarySize));
        NdArray<dtype> upperRight = outArray(Slice(upperRowStart, upperRowStart + inBoundarySize),
                                             Slice(outShape.cols - inBoundarySize, outShape.cols));

        outArray.put(Slice(0, inBoundarySize), Slice(0, inBoundarySize), upperLeft);
        outArray.put(Slice(0, inBoundarySize), Slice(outShape.cols - inBoundarySize, outShape.cols), upperRight);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows), Slice(0, inBoundarySize), lowerLeft);
        outArray.put(Slice(outShape.rows - inBoundarySize, outShape.rows),
                     Slice(outShape.cols - inBoundarySize, outShape.cols),
                     lowerRight);

        return outArray;
    }
} // namespace nc::filter::boundary

/*** End of inlined file: wrap2d.hpp ***/

namespace nc::filter::boundary
{

    // Method Description:
    /// Wrap boundary
    ///
    /// @param inImage
    /// @param inBoundaryType
    /// @param inKernalSize
    /// @param inConstantValue (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> addBoundary2d(const NdArray<dtype>& inImage,
                                 Boundary              inBoundaryType,
                                 uint32                inKernalSize,
                                 dtype                 inConstantValue = 0)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inKernalSize % 2 == 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("input kernal size must be an odd value.");
        }

        const uint32 boundarySize = inKernalSize / 2; // integer division

        switch (inBoundaryType)
        {
            case Boundary::REFLECT:
            {
                return reflect2d(inImage, boundarySize);
            }
            case Boundary::CONSTANT:
            {
                return constant2d(inImage, boundarySize, inConstantValue);
            }
            case Boundary::NEAREST:
            {
                return nearest2d(inImage, boundarySize);
            }
            case Boundary::MIRROR:
            {
                return mirror2d(inImage, boundarySize);
            }
            case Boundary::WRAP:
            {
                return wrap2d(inImage, boundarySize);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc::filter::boundary

/*** End of inlined file: addBoundary2d.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional mean filter.
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> meanFilter(const NdArray<dtype>& inImageArray,
                               uint32                inSize,
                               Boundary              inBoundaryType  = Boundary::REFLECT,
                               dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<double> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = mean(window).item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: meanFilter.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional complemenatry mean filter.
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> complementaryMeanFilter(const NdArray<dtype>& inImageArray,
                                            uint32                inSize,
                                            Boundary              inBoundaryType  = Boundary::REFLECT,
                                            dtype                 inConstantValue = 0)
    {
        auto inImageArrayCopy = inImageArray.template astype<double>();
        inImageArrayCopy -= meanFilter(inImageArray, inSize, inBoundaryType, inConstantValue);

        return inImageArrayCopy;
    }
} // namespace nc::filter

/*** End of inlined file: complementaryMeanFilter.hpp ***/


/*** Start of inlined file: complementaryMedianFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional complemenatry median filter.
///
#pragma once


/*** Start of inlined file: medianFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional median filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional median filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> medianFilter(const NdArray<dtype>& inImageArray,
                                uint32                inSize,
                                Boundary              inBoundaryType  = Boundary::REFLECT,
                                dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = window.median().item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: medianFilter.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional complemenatry median filter.
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> complementaryMedianFilter(const NdArray<dtype>& inImageArray,
                                             uint32                inSize,
                                             Boundary              inBoundaryType  = Boundary::REFLECT,
                                             dtype                 inConstantValue = 0)
    {
        NdArray<dtype> inImageArrayCopy(inImageArray);
        inImageArrayCopy -= medianFilter(inImageArray, inSize, inBoundaryType, inConstantValue);

        return inImageArrayCopy;
    }
} // namespace nc::filter

/*** End of inlined file: complementaryMedianFilter.hpp ***/


/*** Start of inlined file: convolve.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional kernel convolution.
///
#pragma once

#include <string>


/*** Start of inlined file: rot90.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Rotate an array by 90 degrees counter clockwise in the plane.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.rot90.html
    ///
    /// @param inArray
    /// @param inK: the number of times to rotate 90 degrees
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> rot90(const NdArray<dtype>& inArray, uint8 inK = 1)
    {
        inK %= 4;
        switch (inK)
        {
            case 0:
            {
                return inArray;
            }
            case 1:
            {
                return flipud(inArray.transpose());
            }
            case 2:
            {
                return flip(inArray, Axis::NONE);
            }
            case 3:
            {
                return fliplr(inArray.transpose());
            }
            default:
            {
                // this isn't actually possible, just putting this here to get rid
                // of the compiler warning.
                return {};
            }
        }
    }
} // namespace nc

/*** End of inlined file: rot90.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional kernel convolution.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inWeights
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> convolve(const NdArray<dtype>& inImageArray,
                            uint32                inSize,
                            const NdArray<dtype>& inWeights,
                            Boundary              inBoundaryType  = Boundary::REFLECT,
                            dtype                 inConstantValue = 0)
    {
        if (inWeights.size() != utils::sqr(inSize))
        {
            THROW_INVALID_ARGUMENT_ERROR("input weights do no match input kernal size.");
        }

        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        NdArray<dtype> weightsFlat  = rot90(inWeights, 2).flatten();
        const Shape    inShape      = inImageArray.shape();
        const uint32   boundarySize = inSize / 2; // integer division
        const uint32   endPointRow  = boundarySize + inShape.rows;
        const uint32   endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1))
                                            .flatten();

                output(row - boundarySize, col - boundarySize) = dot(window, weightsFlat).item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: convolve.hpp ***/


/*** Start of inlined file: gaussianFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional gaussian filter.
///
#pragma once

#include <cmath>
#include <string>
#include <utility>


/*** Start of inlined file: gaussian.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// samples a 2D gaussian of mean zero and input STD sigma
///
#pragma once

#include <cmath>

namespace nc::utils
{

    // Method Description:
    /// samples a 2D gaussian of mean zero and input STD sigma
    ///
    /// @param inX
    /// @param inY
    /// @param inSigma
    ///
    /// @return dtype
    ///
    inline double gaussian(double inX, double inY, double inSigma) noexcept
    {
        double exponent = sqr(inX) + sqr(inY);
        exponent /= 2;
        exponent /= sqr(inSigma);
        return std::exp(-exponent);
    }
} // namespace nc::utils

/*** End of inlined file: gaussian.hpp ***/

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional gaussian filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    ///
    /// @param inImageArray
    /// @param inSigma: Standard deviation for Gaussian kernel
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> gaussianFilter(const NdArray<dtype>& inImageArray,
                                  double                inSigma,
                                  Boundary              inBoundaryType  = Boundary::REFLECT,
                                  dtype                 inConstantValue = 0)
    {
        if (inSigma <= 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("input sigma value must be greater than zero.");
        }

        // calculate the kernel size based off of the input sigma value
        constexpr uint32 MIN_KERNEL_SIZE = 5;
        uint32           kernelSize =
            std::max(static_cast<uint32>(std::ceil(inSigma * 2. * 4.)), MIN_KERNEL_SIZE); // 4 standard deviations
        if (kernelSize % 2 == 0)
        {
            ++kernelSize; // make sure the kernel is an odd size
        }

        const auto kernalHalfSize = static_cast<double>(kernelSize / 2); // integer division

        // calculate the gaussian kernel
        NdArray<double> kernel(kernelSize);
        for (double row = 0; row < kernelSize; ++row)
        {
            for (double col = 0; col < kernelSize; ++col)
            {
                kernel(static_cast<uint32>(row), static_cast<uint32>(col)) =
                    utils::gaussian(row - kernalHalfSize, col - kernalHalfSize, inSigma);
            }
        }

        // normalize the kernel
        kernel /= kernel.sum().item();

        // perform the convolution
        NdArray<dtype> output =
            convolve(inImageArray.template astype<double>(), kernelSize, kernel, inBoundaryType, inConstantValue)
                .template astype<dtype>();

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: gaussianFilter.hpp ***/


/*** Start of inlined file: laplace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculate the 2D laplace filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculate the 2D laplace filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace
    ///
    /// @param inImageArray
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> laplace(const NdArray<dtype>& inImageArray,
                           Boundary              inBoundaryType  = Boundary::REFLECT,
                           dtype                 inConstantValue = 0)
    {
        NdArray<dtype> kernel = { { 0, 1, 0 }, { 1, -4, 1 }, { 0, 1, 0 } };
        return convolve(inImageArray, 3, kernel, inBoundaryType, inConstantValue);
    }
} // namespace nc::filter

/*** End of inlined file: laplace.hpp ***/


/*** Start of inlined file: maximumFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional maximum filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional maximum filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> maximumFilter(const NdArray<dtype>& inImageArray,
                                 uint32                inSize,
                                 Boundary              inBoundaryType  = Boundary::REFLECT,
                                 dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = window.max().item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: maximumFilter.hpp ***/


/*** Start of inlined file: minimumFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional minimum filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional minimum filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> minimumFilter(const NdArray<dtype>& inImageArray,
                                 uint32                inSize,
                                 Boundary              inBoundaryType  = Boundary::REFLECT,
                                 dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = window.min().item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: minimumFilter.hpp ***/


/*** Start of inlined file: percentileFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional percentile filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional percentile filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inPercentile: percentile [0, 100]
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> percentileFilter(const NdArray<dtype>& inImageArray,
                                    uint32                inSize,
                                    double                inPercentile,
                                    Boundary              inBoundaryType  = Boundary::REFLECT,
                                    dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) =
                    percentile(window, inPercentile, Axis::NONE, InterpolationMethod::NEAREST).item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: percentileFilter.hpp ***/


/*** Start of inlined file: rankFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional rank filter.
///
#pragma once

#include <string>

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional rank filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inRank: ([0, inSize^2 - 1])
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> rankFilter(const NdArray<dtype>& inImageArray,
                              uint32                inSize,
                              uint32                inRank,
                              Boundary              inBoundaryType  = Boundary::REFLECT,
                              dtype                 inConstantValue = 0)
    {
        if (inRank >= utils::sqr(inSize))
        {
            THROW_INVALID_ARGUMENT_ERROR("rank not within filter footprint size.");
        }

        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = sort(window)[inRank];
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: rankFilter.hpp ***/


/*** Start of inlined file: uniformFilter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Calculates a multidimensional uniform filter.
///
#pragma once

namespace nc::filter
{

    // Method Description:
    /// Calculates a multidimensional uniform filter.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter
    ///
    /// @param inImageArray
    /// @param inSize: square size of the kernel to apply
    /// @param inBoundaryType: boundary mode (default Reflect) options (reflect, constant, nearest, mirror, wrap)
    /// @param inConstantValue: contant value if boundary = 'constant' (default 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> uniformFilter(const NdArray<dtype>& inImageArray,
                                 uint32                inSize,
                                 Boundary              inBoundaryType  = Boundary::REFLECT,
                                 dtype                 inConstantValue = 0)
    {
        NdArray<dtype> arrayWithBoundary =
            boundary::addBoundary2d(inImageArray, inBoundaryType, inSize, inConstantValue);
        NdArray<dtype> output(inImageArray.shape());

        const Shape  inShape      = inImageArray.shape();
        const uint32 boundarySize = inSize / 2; // integer division
        const uint32 endPointRow  = boundarySize + inShape.rows;
        const uint32 endPointCol  = boundarySize + inShape.cols;

        for (uint32 row = boundarySize; row < endPointRow; ++row)
        {
            for (uint32 col = boundarySize; col < endPointCol; ++col)
            {
                NdArray<dtype> window = arrayWithBoundary(Slice(row - boundarySize, row + boundarySize + 1),
                                                          Slice(col - boundarySize, col + boundarySize + 1));

                output(row - boundarySize, col - boundarySize) = mean(window).item();
            }
        }

        return output;
    }
} // namespace nc::filter

/*** End of inlined file: uniformFilter.hpp ***/

/*** End of inlined file: Filter.hpp ***/


/*** Start of inlined file: Functions.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Methods for interacting with NdArrays
///
#pragma once


/*** Start of inlined file: abs.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Calculate the absolute value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.absolute.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto abs(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::abs(inValue);
    }

    // Method Description:
    /// Calculate the absolute value element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.absolute.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto abs(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(nc::abs(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return nc::abs(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: abs.hpp ***/


/*** Start of inlined file: add.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> add(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 + inArray2;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> add(const NdArray<dtype>& inArray, dtype value)
    {
        return inArray + value;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> add(dtype value, const NdArray<dtype>& inArray)
    {
        return value + inArray;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        return inArray1 + inArray2;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 + inArray2;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(const NdArray<dtype>& inArray, const std::complex<dtype>& value)
    {
        return inArray + value;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(const std::complex<dtype>& value, const NdArray<dtype>& inArray)
    {
        return value + inArray;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(const NdArray<std::complex<dtype>>& inArray, dtype value)
    {
        return inArray + value;
    }

    // Method Description:
    /// Add arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.add.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> add(dtype value, const NdArray<std::complex<dtype>>& inArray)
    {
        return value + inArray;
    }
} // namespace nc

/*** End of inlined file: add.hpp ***/


/*** Start of inlined file: alen.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the length of the first dimension of the input array.
    ///
    /// @param inArray
    /// @return length uint16
    ///
    template<typename dtype>
    uint32 alen(const NdArray<dtype>& inArray) noexcept
    {
        return inArray.shape().rows;
    }
} // namespace nc

/*** End of inlined file: alen.hpp ***/


/*** Start of inlined file: all.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Test whether all array elements along a given axis evaluate to True.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.all.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return bool
    ///
    template<typename dtype>
    NdArray<bool> all(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.all(inAxis);
    }
} // namespace nc

/*** End of inlined file: all.hpp ***/


/*** Start of inlined file: allclose.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Returns True if two arrays are element-wise equal within a tolerance.
    /// inTolerance must be a positive number
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.allclose.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @param inTolerance: (Optional, default 1e-5)
    /// @return bool
    ///
    template<typename dtype>
    bool allclose(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2, double inTolerance = 1e-5)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inArray1.shape() != inArray2.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array dimensions are not consistant.");
        }

        for (uint32 i = 0; i < inArray1.size(); ++i)
        {
            if (std::abs(inArray1[i] - inArray2[i]) > inTolerance)
            {
                return false;
            }
        }

        return true;
    }
} // namespace nc

/*** End of inlined file: allclose.hpp ***/


/*** Start of inlined file: amax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the maximum of an array or maximum along an axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.amax.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return max value
    ///
    template<typename dtype>
    NdArray<dtype> amax(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.max(inAxis);
    }
} // namespace nc

/*** End of inlined file: amax.hpp ***/


/*** Start of inlined file: amin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the minimum of an array or minimum along an axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.amin.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return min value
    ///
    template<typename dtype>
    NdArray<dtype> amin(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.min(inAxis);
    }
} // namespace nc

/*** End of inlined file: amin.hpp ***/


/*** Start of inlined file: angle.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Return the angle of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.angle.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto angle(const std::complex<dtype>& inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::arg(inValue);
    }

    // Method Description:
    /// Return the angle of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.angle.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto angle(const NdArray<std::complex<dtype>>& inArray)
    {
        NdArray<decltype(angle(std::complex<dtype>{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](auto& inValue) -> auto { return angle(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: angle.hpp ***/


/*** Start of inlined file: any.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Test whether any array element along a given axis evaluates to True.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.any.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> any(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.any(inAxis);
    }
} // namespace nc

/*** End of inlined file: any.hpp ***/


/*** Start of inlined file: append.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Append values to the end of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.append.html
    ///
    /// @param inArray
    /// @param inAppendValues
    /// @param inAxis (Optional, default NONE): The axis along which values are appended.
    /// If axis is not given, both inArray and inAppendValues
    /// are flattened before use.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> append(const NdArray<dtype>& inArray, const NdArray<dtype>& inAppendValues, Axis inAxis = Axis::NONE)
    {
        if (inArray.shape().isnull())
        {
            return inAppendValues;
        }
        else if (inAppendValues.shape().isnull())
        {
            return inArray;
        }

        switch (inAxis)
        {
            case Axis::NONE:
            {
                NdArray<dtype> returnArray(1, inArray.size() + inAppendValues.size());
                stl_algorithms::copy(inArray.cbegin(), inArray.cend(), returnArray.begin());
                stl_algorithms::copy(inAppendValues.cbegin(),
                                     inAppendValues.cend(),
                                     returnArray.begin() + inArray.size());

                return returnArray;
            }
            case Axis::ROW:
            {
                const Shape inShape     = inArray.shape();
                const Shape appendShape = inAppendValues.shape();
                if (inShape.cols != appendShape.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "all the input array dimensions except for the concatenation axis must match exactly");
                }

                NdArray<dtype> returnArray(inShape.rows + appendShape.rows, inShape.cols);
                stl_algorithms::copy(inArray.cbegin(), inArray.cend(), returnArray.begin());
                stl_algorithms::copy(inAppendValues.cbegin(),
                                     inAppendValues.cend(),
                                     returnArray.begin() + inArray.size());

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape inShape     = inArray.shape();
                const Shape appendShape = inAppendValues.shape();
                if (inShape.rows != appendShape.rows)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "all the input array dimensions except for the concatenation axis must match exactly");
                }

                NdArray<dtype> returnArray(inShape.rows, inShape.cols + appendShape.cols);
                for (uint32 row = 0; row < returnArray.shape().rows; ++row)
                {
                    stl_algorithms::copy(inArray.cbegin(row), inArray.cend(row), returnArray.begin(row));
                    stl_algorithms::copy(inAppendValues.cbegin(row),
                                         inAppendValues.cend(row),
                                         returnArray.begin(row) + inShape.cols);
                }

                return returnArray;
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: append.hpp ***/


/*** Start of inlined file: applyFunction.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <functional>

namespace nc
{

    // Method Description:
    /// Apply the input function element wise to the input
    /// array in place.
    ///
    /// @param inArray
    /// @param inFunc
    ///
    template<typename dtype>
    void applyFunction(NdArray<dtype>& inArray, const std::function<dtype(dtype)>& inFunc)
    {
        stl_algorithms::transform(inArray.begin(), inArray.end(), inArray.begin(), inFunc);
    }
} // namespace nc

/*** End of inlined file: applyFunction.hpp ***/


/*** Start of inlined file: applyPoly1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: Poly1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Class for dealing with 1D polynomials
///
#pragma once

#include <iostream>
#include <numeric>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>


/*** Start of inlined file: diagflat.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Create a two-dimensional array with the flattened input as a diagonal.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.diagflat.html
    ///
    /// @param inArray
    /// @param k Diagonal to set; 0, the default, corresponds to the �main� diagonal,
    /// a positive (negative) k giving the number of the diagonal above (below) the main.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> diagflat(const NdArray<dtype>& inArray, int32 k = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto     absK = static_cast<uint32>(std::abs(k));
        NdArray<dtype> returnArray(inArray.size() + absK);

        const uint32 rowOffset = k < 0 ? absK : 0;
        const uint32 colOffset = k > 0 ? absK : 0;

        returnArray.zeros();
        for (uint32 i = 0; i < inArray.size(); ++i)
        {
            returnArray(i + rowOffset, i + colOffset) = inArray[i];
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: diagflat.hpp ***/


/*** Start of inlined file: inv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix inverse
///
#pragma once

#include <algorithm>
#include <string>


/*** Start of inlined file: zeros.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: full.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with inFillValue
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.full.html
    ///
    /// @param inSquareSize
    /// @param inFillValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> full(uint32 inSquareSize, dtype inFillValue)
    {
        NdArray<dtype> returnArray(inSquareSize, inSquareSize);
        returnArray.fill(inFillValue);
        return returnArray;
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with inFillValue
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.full.html
    ///
    /// @param inNumRows
    /// @param inNumCols
    /// @param inFillValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> full(uint32 inNumRows, uint32 inNumCols, dtype inFillValue)
    {
        NdArray<dtype> returnArray(inNumRows, inNumCols);
        returnArray.fill(inFillValue);
        return returnArray;
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with inFillValue
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.full.html
    ///
    /// @param inShape
    /// @param inFillValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> full(const Shape& inShape, dtype inFillValue)
    {
        return full(inShape.rows, inShape.cols, inFillValue);
    }
} // namespace nc

/*** End of inlined file: full.hpp ***/

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with zeros.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.zeros.html
    ///
    /// @param inSquareSize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> zeros(uint32 inSquareSize)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inSquareSize, dtype{ 0 });
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with zeros.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.zeros.html
    ///
    /// @param inNumRows
    /// @param inNumCols
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> zeros(uint32 inNumRows, uint32 inNumCols)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inNumRows, inNumCols, dtype{ 0 });
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with zeros.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.zeros.html
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> zeros(const Shape& inShape)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inShape, dtype{ 0 });
    }
} // namespace nc

/*** End of inlined file: zeros.hpp ***/


/*** Start of inlined file: det.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix determinant.
///
#pragma once

#include <cmath>
#include <string>
#include <type_traits>

namespace nc::linalg
{
    namespace detail
    {

        // Method Description:
        /// matrix determinant.
        ///
        /// @param inArray
        /// @param order
        /// @return matrix determinant
        ///
        template<typename dtype>
        auto det(const NdArray<dtype>& inArray, uint32 order)
            -> std::conditional_t<std::is_integral_v<dtype>, int64, double>
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            using ReturnType = std::conditional_t<std::is_integral_v<dtype>, int64, double>;

            if (order == 1)
            {
                return static_cast<ReturnType>(inArray.front());
            }

            if (order == 2)
            {
                return static_cast<ReturnType>(inArray(0, 0)) * static_cast<ReturnType>(inArray(1, 1)) -
                       static_cast<ReturnType>(inArray(0, 1)) * static_cast<ReturnType>(inArray(1, 0));
            }

            if (order == 3)
            {
                const auto aei = static_cast<ReturnType>(inArray(0, 0)) * static_cast<ReturnType>(inArray(1, 1)) *
                                 static_cast<ReturnType>(inArray(2, 2));
                const auto bfg = static_cast<ReturnType>(inArray(0, 1)) * static_cast<ReturnType>(inArray(1, 2)) *
                                 static_cast<ReturnType>(inArray(2, 0));
                const auto cdh = static_cast<ReturnType>(inArray(0, 2)) * static_cast<ReturnType>(inArray(1, 0)) *
                                 static_cast<ReturnType>(inArray(2, 1));
                const auto ceg = static_cast<ReturnType>(inArray(0, 2)) * static_cast<ReturnType>(inArray(1, 1)) *
                                 static_cast<ReturnType>(inArray(2, 0));
                const auto bdi = static_cast<ReturnType>(inArray(0, 1)) * static_cast<ReturnType>(inArray(1, 0)) *
                                 static_cast<ReturnType>(inArray(2, 2));
                const auto afh = static_cast<ReturnType>(inArray(0, 0)) * static_cast<ReturnType>(inArray(1, 2)) *
                                 static_cast<ReturnType>(inArray(2, 1));

                return aei + bfg + cdh - ceg - bdi - afh;
            }

            ReturnType     determinant = 0;
            ReturnType     sign        = 1;
            NdArray<dtype> submat(order - 1);

            for (uint32 c = 0; c < order; ++c)
            {
                uint32 subi = 0;
                for (uint32 i = 1; i < order; ++i)
                {
                    uint32 subj = 0;
                    for (uint32 j = 0; j < order; ++j)
                    {
                        if (j == c)
                        {
                            continue;
                        }

                        submat(subi, subj++) = inArray(i, j);
                    }
                    ++subi;
                }

                determinant += (sign * static_cast<ReturnType>(inArray(0, c)) * det(submat, order - 1));
                sign *= -1;
            }

            return determinant;
        }
    } // namespace detail

    // Method Description:
    /// matrix determinant.
    /// NOTE: can get verrrrry slow for large matrices (order > 10)
    ///
    /// SciPy Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.det.html#scipy.linalg.det
    ///
    /// @param inArray
    /// @return matrix determinant
    ///
    template<typename dtype>
    auto det(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inArray.shape();
        if (!inShape.issquare())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array must be square.");
        }

        return detail::det(inArray, inShape.rows);
    }
} // namespace nc::linalg

/*** End of inlined file: det.hpp ***/

namespace nc::linalg
{

    // Method Description:
    /// matrix inverse
    ///
    /// SciPy Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.inv.html#scipy.linalg.inv
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> inv(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape = inArray.shape();
        if (inShape.rows != inShape.cols)
        {
            THROW_INVALID_ARGUMENT_ERROR("input array must be square.");
        }

        NdArray<double> inArrayDouble = inArray.template astype<double>();
        NdArray<int>    incidence     = nc::zeros<int>(inShape);

        for (uint32 k = 0; k < inShape.rows - 1; ++k)
        {
            if (utils::essentiallyEqual(inArrayDouble(k, k), 0.))
            {
                uint32 l = k;
                while (l < inShape.cols && utils::essentiallyEqual(inArrayDouble(k, l), 0.))
                {
                    ++l;
                }

                inArrayDouble.swapRows(k, l);
                incidence(k, k) = 1;
                incidence(k, l) = 1;
            }
        }

        NdArray<double> result(inShape);

        for (uint32 k = 0; k < inShape.rows; ++k)
        {
            result(k, k) = -1. / inArrayDouble(k, k);
            for (uint32 i = 0; i < inShape.rows; ++i)
            {
                for (uint32 j = 0; j < inShape.cols; ++j)
                {
                    if ((i - k) && (j - k))
                    {
                        result(i, j) = inArrayDouble(i, j) + inArrayDouble(k, j) * inArrayDouble(i, k) * result(k, k);
                    }
                    else if ((i - k) && !(j - k))
                    {
                        result(i, k) = inArrayDouble(i, k) * result(k, k);
                    }
                    else if (!(i - k) && (j - k))
                    {
                        result(k, j) = inArrayDouble(k, j) * result(k, k);
                    }
                }
            }

            inArrayDouble = result;
        }

        result *= -1.;

        for (int i = static_cast<int>(inShape.rows) - 1; i >= 0; --i)
        {
            if (incidence(i, i) != 1)
            {
                continue;
            }

            int k = 0;
            for (; k < static_cast<int>(inShape.cols); ++k)
            {
                if ((k - i) && incidence(i, k) != 0)
                {
                    result.swapCols(i, k);
                    break;
                }
            }
        }

        return result;
    }
} // namespace nc::linalg

/*** End of inlined file: inv.hpp ***/

namespace nc::polynomial
{

    /// A one-dimensional polynomial class.
    /// A convenience class, used to encapsulate "natural"
    /// operations on polynomials
    template<typename dtype>
    class Poly1d
    {
    private:
        STATIC_ASSERT_ARITHMETIC(dtype);

    public:

        // Method Description:
        /// Default Constructor (not very usefull, but needed for other
        /// containers.
        ///
        Poly1d() = default;

        // Method Description:
        /// Constructor
        ///
        /// @param inValues: (polynomial coefficients in ascending order of power if second input is false,
        /// polynomial roots if second input is true)
        /// @param isRoots
        ///
        Poly1d(const NdArray<dtype>& inValues, IsRoots isRoots = IsRoots::NO)
        {
            if (inValues.size() > DtypeInfo<uint8>::max())
            {
                THROW_INVALID_ARGUMENT_ERROR("can only make a polynomial of order " +
                                             utils::num2str(DtypeInfo<uint8>::max()));
            }

            if (isRoots == IsRoots::YES)
            {
                coefficients_.push_back(1);
                for (auto value : inValues)
                {
                    NdArray<dtype> coeffs = { -(value), static_cast<dtype>(1) };
                    *this *= Poly1d<dtype>(coeffs, IsRoots::NO);
                }
            }
            else
            {
                coefficients_.resize(inValues.size());
                stl_algorithms::copy(inValues.begin(), inValues.end(), coefficients_.begin());
            }
        }

        // Method Description:
        /// Returns the area under the curve between the two bounds
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return double
        ///
        [[nodiscard]] double area(double a, double b) const
        {
            if (a > b)
            {
                std::swap(a, b);
            }

            auto polyIntegral = integ();
            return polyIntegral(b) - polyIntegral(a);
        }

        // Method Description:
        /// Returns a copy of the polynomial of the new type
        ///
        /// @return Poly1d
        ///
        template<typename dtypeOut>
        Poly1d<dtypeOut> astype() const
        {
            auto newCoefficients = NdArray<dtypeOut>(1, static_cast<uint32>(coefficients_.size()));

            const auto function = [](dtype value) -> dtypeOut { return static_cast<dtypeOut>(value); };

            stl_algorithms::transform(coefficients_.begin(), coefficients_.end(), newCoefficients.begin(), function);

            return Poly1d<dtypeOut>(newCoefficients);
        }

        // Method Description:
        /// Returns the Poly1d coefficients
        ///
        /// @return NdArray
        ///
        [[nodiscard]] NdArray<dtype> coefficients() const
        {
            auto coefficientsCopy = coefficients_;
            return NdArray<dtype>(coefficientsCopy);
        }

        // Method Description:
        /// Takes the derivative of the polynomial
        ///
        /// @return Poly1d
        [[nodiscard]] Poly1d<dtype> deriv() const
        {
            const auto numCoefficients = static_cast<uint32>(coefficients_.size());
            if (numCoefficients == 0)
            {
                return {};
            }
            if (numCoefficients == 1)
            {
                return Poly1d<dtype>({ 0 });
            }

            NdArray<dtype> derivativeCofficients(1, numCoefficients - 1);

            uint32 counter = 0;
            for (uint32 i = 1; i < numCoefficients; ++i)
            {
                derivativeCofficients[counter++] = coefficients_[i] * i;
            }

            return Poly1d<dtype>(derivativeCofficients);
        }

        // Method Description:
        /// Evaluates the Poly1D object for the input value
        ///
        /// @param xValue
        /// @return predicted yValue
        ///
        dtype eval(dtype xValue) const noexcept
        {
            return operator()(xValue);
        }

        // Method Description:
        /// Evaluates the Poly1D object for the input value
        ///
        /// @param xValues
        /// @return predicted yValues
        ///
        NdArray<dtype> eval(const NdArray<dtype>& xValues) const noexcept
        {
            return operator()(xValues);
        }

        // Method Description:
        /// Polynomial linear least squares regression: Ax = b
        ///
        /// @param xValues: the x measurements [1, n] or [n, 1] array
        /// @param yValues: the y measurements [n, 1] array
        /// @param polyOrder: the order of the poly nomial to fit
        /// @return Poly1d
        static Poly1d<double> fit(const NdArray<dtype>& xValues, const NdArray<dtype>& yValues, uint8 polyOrder)
        {
            const auto numMeasurements = xValues.size();

            if (yValues.size() != numMeasurements)
            {
                THROW_INVALID_ARGUMENT_ERROR("Input x and y arrays must be of equal size.");
            }

            if (!xValues.isflat())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input x must be a flattened [1, n] or [n, 1] array.");
            }

            if (!yValues.isflat())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input y must be a flattened [n, 1] array.");
            }

            NdArray<double> a(numMeasurements, polyOrder + 1);
            for (uint32 measIdx = 0; measIdx < numMeasurements; ++measIdx)
            {
                const auto xDouble = static_cast<double>(xValues[measIdx]);
                for (uint8 order = 0; order < a.numCols(); ++order)
                {
                    a(measIdx, order) = utils::power(xDouble, order);
                }
            }

            NdArray<double> aInv;
            if (a.issquare())
            {
                aInv = linalg::inv(a);
            }
            else
            {
                // psuedo-inverse
                auto aT     = a.transpose();
                auto aTaInv = linalg::inv(aT.dot(a));
                aInv        = aTaInv.dot(aT);
            }

            auto x = aInv.dot(yValues.template astype<double>());
            return Poly1d<double>(x);
        }

        // Method Description:
        /// Polynomial linear least squares regression: Ax = b
        ///
        /// @param xValues: the x measurements [1, n] or [n, 1] array
        /// @param yValues: the y measurements [n, 1] array
        /// @param weights: the measurement weights [1, n] or [n, 1] array
        /// @param polyOrder: the order of the poly nomial to fit
        /// @return Poly1d
        static Poly1d<double> fit(const NdArray<dtype>& xValues,
                                  const NdArray<dtype>& yValues,
                                  const NdArray<dtype>& weights,
                                  uint8                 polyOrder)
        {
            const auto numMeasurements = xValues.size();

            if (yValues.size() != numMeasurements)
            {
                THROW_INVALID_ARGUMENT_ERROR("Input x and y arrays must be of equal size.");
            }

            if (weights.size() != numMeasurements)
            {
                THROW_INVALID_ARGUMENT_ERROR("Input x and weights arrays must be of equal size.");
            }

            if (!xValues.isflat())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input x must be a flattened [1, n] or [n, 1] array.");
            }

            if (!yValues.isflat())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input y must be a flattened [n, 1] array.");
            }

            if (!weights.isflat())
            {
                THROW_INVALID_ARGUMENT_ERROR("Input weights must be a flattened [1, n] or [n, 1] array.");
            }

            NdArray<double> a(numMeasurements, polyOrder + 1);
            for (uint32 measIdx = 0; measIdx < numMeasurements; ++measIdx)
            {
                const auto xDouble = static_cast<double>(xValues[measIdx]);
                for (uint8 order = 0; order < a.numCols(); ++order)
                {
                    a(measIdx, order) = utils::power(xDouble, order);
                }
            }

            NdArray<double> aWeighted(a.shape());
            NdArray<double> yWeighted(yValues.shape());

            for (uint32 measIdx = 0; measIdx < numMeasurements; ++measIdx)
            {
                const auto weight = static_cast<double>(weights[measIdx]);

                yWeighted[measIdx] = yValues[measIdx] * weight;
                for (uint8 order = 0; order < a.numCols(); ++order)
                {
                    aWeighted(measIdx, order) = a(measIdx, order) * weight;
                }
            }

            NdArray<double> aInv;
            if (aWeighted.issquare())
            {
                aInv = linalg::inv(aWeighted);
            }
            else
            {
                // psuedo-inverse
                auto aT     = a.transpose();
                auto aTaInv = linalg::inv(aT.dot(aWeighted));
                aInv        = aTaInv.dot(aT);
            }

            auto x = aInv.dot(yWeighted);
            return Poly1d<double>(x); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Calculates the integral of the polynomial
        ///
        /// @return Poly1d
        [[nodiscard]] Poly1d<double> integ() const
        {
            const auto numCoefficients = static_cast<uint32>(coefficients_.size());
            if (numCoefficients == 0)
            {
                return {};
            }

            NdArray<double> integralCofficients(1, numCoefficients + 1);
            integralCofficients[0] = 0.;

            for (uint32 i = 0; i < numCoefficients; ++i)
            {
                integralCofficients[i + 1] = static_cast<double>(coefficients_[i]) / static_cast<double>(i + 1);
            }

            return Poly1d<double>(integralCofficients); // NOLINT(modernize-return-braced-init-list)
        }

        // Method Description:
        /// Returns the order of the Poly1d
        ///
        /// @return NdArray
        ///
        [[nodiscard]] uint32 order() const noexcept
        {
            return static_cast<uint32>(coefficients_.size() - 1);
        }

        // Method Description:
        /// Prints the string representation of the Poly1d object
        /// to the console
        ///
        void print() const
        {
            std::cout << *this << std::endl;
        }

        // Method Description:
        /// Converts the polynomial to a string representation
        ///
        /// @return Poly1d
        ///
        [[nodiscard]] std::string str() const
        {
            const auto numCoeffients = static_cast<uint32>(coefficients_.size());

            std::string repr  = "Poly1d<";
            uint32      power = 0;
            for (auto& coefficient : coefficients_)
            {
                if (utils::essentiallyEqual(coefficient, static_cast<dtype>(0)))
                {
                    ++power;
                    continue;
                }

                repr += utils::num2str(coefficient);

                if (power > 1)
                {
                    repr += "x^" + utils::num2str(power);
                }
                else if (power == 1)
                {
                    repr += "x";
                }

                ++power;

                if (power < numCoeffients)
                {
                    repr += " + ";
                }
            }

            return repr + ">";
        }

        // Method Description:
        /// Evaluates the Poly1D object for the input value
        ///
        /// @param inValue
        /// @return dtype scalar
        ///
        dtype operator()(dtype inValue) const noexcept
        {
            uint8 power = 0;
            return std::accumulate(coefficients_.begin(),
                                   coefficients_.end(),
                                   dtype{ 0 },
                                   [&power, inValue](dtype polyValue, const auto& coefficient) noexcept -> dtype
                                   { return polyValue + coefficient * utils::power(inValue, power++); });
        }

        // Method Description:
        /// Evaluates the Poly1D object for the input value
        ///
        /// @param xValues
        /// @return predicted yValues
        ///
        NdArray<dtype> operator()(const NdArray<dtype>& xValues) const noexcept
        {
            NdArray<dtype> returnArray(xValues.shape());

            stl_algorithms::transform(xValues.begin(),
                                      xValues.end(),
                                      returnArray.begin(),
                                      [this](const auto xValue) { return this->operator()(xValue); });
            return returnArray;
        }

        // Method Description:
        /// Adds the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype> operator+(const Poly1d<dtype>& inOtherPoly) const
        {
            return Poly1d<dtype>(*this) += inOtherPoly;
        }

        // Method Description:
        /// Adds the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype>& operator+=(const Poly1d<dtype>& inOtherPoly)
        {
            if (this->coefficients_.size() < inOtherPoly.coefficients_.size())
            {
                for (size_t i = 0; i < coefficients_.size(); ++i)
                {
                    coefficients_[i] += inOtherPoly.coefficients_[i];
                }
                for (size_t i = coefficients_.size(); i < inOtherPoly.coefficients_.size(); ++i)
                {
                    coefficients_.push_back(inOtherPoly.coefficients_[i]);
                }
            }
            else
            {
                for (size_t i = 0; i < inOtherPoly.coefficients_.size(); ++i)
                {
                    coefficients_[i] += inOtherPoly.coefficients_[i];
                }
            }

            return *this;
        }

        // Method Description:
        /// Subtracts the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype> operator-(const Poly1d<dtype>& inOtherPoly) const
        {
            return Poly1d<dtype>(*this) -= inOtherPoly;
        }

        // Method Description:
        /// Subtracts the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype>& operator-=(const Poly1d<dtype>& inOtherPoly)
        {
            if (this->coefficients_.size() < inOtherPoly.coefficients_.size())
            {
                for (size_t i = 0; i < coefficients_.size(); ++i)
                {
                    coefficients_[i] -= inOtherPoly.coefficients_[i];
                }
                for (size_t i = coefficients_.size(); i < inOtherPoly.coefficients_.size(); ++i)
                {
                    coefficients_.push_back(-inOtherPoly.coefficients_[i]);
                }
            }
            else
            {
                for (size_t i = 0; i < inOtherPoly.coefficients_.size(); ++i)
                {
                    coefficients_[i] -= inOtherPoly.coefficients_[i];
                }
            }

            return *this;
        }

        // Method Description:
        /// Multiplies the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype> operator*(const Poly1d<dtype>& inOtherPoly) const
        {
            return Poly1d<dtype>(*this) *= inOtherPoly;
        }

        // Method Description:
        /// Multiplies the two Poly1d objects
        ///
        /// @param inOtherPoly
        /// @return Poly1d
        ///
        Poly1d<dtype>& operator*=(const Poly1d<dtype>& inOtherPoly)
        {
            const uint32       finalCoefficientsSize = order() + inOtherPoly.order() + 1;
            std::vector<dtype> coeffsA(finalCoefficientsSize, 0);
            std::vector<dtype> coeffsB(finalCoefficientsSize, 0);
            stl_algorithms::copy(coefficients_.begin(), coefficients_.end(), coeffsA.begin());
            stl_algorithms::copy(inOtherPoly.coefficients_.cbegin(), inOtherPoly.coefficients_.cend(), coeffsB.begin());

            // now multiply out the coefficients
            std::vector<dtype> finalCoefficients(finalCoefficientsSize, 0);
            for (uint32 i = 0; i < finalCoefficientsSize; ++i)
            {
                for (uint32 k = 0; k <= i; ++k)
                {
                    finalCoefficients[i] += coeffsA[k] * coeffsB[i - k];
                }
            }

            this->coefficients_ = finalCoefficients;
            return *this;
        }

        // Method Description:
        /// Raise the Poly1d to an integer power
        ///
        /// @param inPower
        /// @return Poly1d
        ///
        Poly1d<dtype> operator^(uint32 inPower) const
        {
            return Poly1d(*this) ^= inPower;
        }

        // Method Description:
        /// Raise the Poly1d to an integer power
        ///
        /// @param inPower
        /// @return Poly1d
        ///
        Poly1d<dtype>& operator^=(uint32 inPower)
        {
            if (inPower == 0)
            {
                coefficients_.clear();
                coefficients_.push_back(1);
                return *this;
            }
            if (inPower == 1)
            {
                return *this;
            }

            auto thisPoly(*this);
            for (uint32 power = 1; power < inPower; ++power)
            {
                *this *= thisPoly;
            }

            return *this;
        }

        // Method Description:
        /// io operator for the Poly1d class
        ///
        /// @param inOStream
        /// @param inPoly
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inOStream, const Poly1d<dtype>& inPoly)
        {
            inOStream << inPoly.str() << std::endl;
            return inOStream;
        }

    private:
        std::vector<dtype> coefficients_{};
    };
} // namespace nc::polynomial

/*** End of inlined file: Poly1d.hpp ***/

namespace nc
{

    // Method Description:
    /// Apply polynomial elemnt wise to the input values.
    ///
    /// @param inArray
    /// @param inPoly
    ///
    template<typename dtype>
    void applyPoly1d(NdArray<dtype>& inArray, const polynomial::Poly1d<dtype>& inPoly)
    {
        applyFunction<dtype>(inArray, inPoly);
    }
} // namespace nc

/*** End of inlined file: applyPoly1d.hpp ***/


/*** Start of inlined file: arange.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>
#include <vector>

namespace nc
{

    // Method Description:
    /// Return evenly spaced values within a given interval.
    ///
    /// Values are generated within the half - open interval[start, stop)
    /// (in other words, the interval including start but excluding stop).
    /// For integer arguments the function is equivalent to the Python built - in
    /// range function, but returns an ndarray rather than a list.
    ///
    /// When using a non - integer step, such as 0.1, the results will often
    /// not be consistent.It is better to use linspace for these cases.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arange.html
    ///
    /// @param inStart
    /// @param inStop
    /// @param inStep: (Optional, defaults to 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> arange(dtype inStart, dtype inStop, dtype inStep = 1)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inStep > 0 && inStop < inStart)
        {
            THROW_INVALID_ARGUMENT_ERROR("stop value must be larger than the start value for positive step.");
        }

        if (inStep < 0 && inStop > inStart)
        {
            THROW_INVALID_ARGUMENT_ERROR("start value must be larger than the stop value for negative step.");
        }

        std::vector<dtype> values;

        dtype theValue = inStart;
        auto  counter  = dtype{ 1 };

        if (inStep > 0)
        {
            while (theValue < inStop)
            {
                values.push_back(theValue);
                theValue = inStart + inStep * counter++;
            }
        }
        else
        {
            while (theValue > inStop)
            {
                values.push_back(theValue);
                theValue = inStart + inStep * counter++;
            }
        }

        return NdArray<dtype>(values);
    }

    // Method Description:
    /// Return evenly spaced values within a given interval.
    ///
    /// Values are generated within the half - open interval[start, stop)
    /// (in other words, the interval including start but excluding stop).
    /// For integer arguments the function is equivalent to the Python built - in
    /// range function, but returns an ndarray rather than a list.
    ///
    /// When using a non - integer step, such as 0.1, the results will often
    /// not be consistent.It is better to use linspace for these cases.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arange.html
    ///
    /// @param inStop: start is 0 and step is 1
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> arange(dtype inStop)
    {
        if (inStop <= 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("stop value must ge greater than 0.");
        }

        return arange<dtype>(0, inStop, 1);
    }

    // Method Description:
    /// Return evenly spaced values within a given interval.
    ///
    /// Values are generated within the half - open interval[start, stop)
    /// (in other words, the interval including start but excluding stop).
    /// For integer arguments the function is equivalent to the Python built - in
    /// range function, but returns an ndarray rather than a list.
    ///
    /// When using a non - integer step, such as 0.1, the results will often
    /// not be consistent.It is better to use linspace for these cases.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arange.html
    ///
    /// @param inSlice
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> arange(const Slice& inSlice)
    {
        return arange<dtype>(inSlice.start, inSlice.stop, inSlice.step);
    }
} // namespace nc

/*** End of inlined file: arange.hpp ***/


/*** Start of inlined file: arccos.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse cosine
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arccos.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arccos(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::acos(inValue);
    }

    // Method Description:
    /// Trigonometric inverse cosine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arccos.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arccos(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arccos(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arccos(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arccos.hpp ***/


/*** Start of inlined file: arccosh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse hyperbolic cosine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arccosh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arccosh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::acosh(inValue);
    }

    // Method Description:
    /// Trigonometric inverse hyperbolic cosine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arccosh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arccosh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arccosh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arccosh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arccosh.hpp ***/


/*** Start of inlined file: arcsin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse sine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arcsin.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arcsin(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::asin(inValue);
    }

    // Method Description:
    /// Trigonometric inverse sine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arcsin.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arcsin(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arcsin(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arcsin(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arcsin.hpp ***/


/*** Start of inlined file: arcsinh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse hyperbolic sine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arcsinh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arcsinh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::asinh(inValue);
    }

    // Method Description:
    /// Trigonometric inverse hyperbolic sine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arcsinh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arcsinh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arcsinh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arcsinh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arcsinh.hpp ***/


/*** Start of inlined file: arctan.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse tangent.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctan.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arctan(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::atan(inValue);
    }

    // Method Description:
    /// Trigonometric inverse tangent, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctan.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arctan(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arctan(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arctan(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arctan.hpp ***/


/*** Start of inlined file: arctan2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse tangent.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctan2.html
    ///
    /// @param inY
    /// @param inX
    /// @return value
    ///
    template<typename dtype>
    auto arctan2(dtype inY, dtype inX) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::atan2(inY, inX);
    }

    // Method Description:
    /// Trigonometric inverse tangent, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctan2.html
    ///
    /// @param inY
    /// @param inX
    /// @return NdArray
    ///
    template<typename dtype>
    auto arctan2(const NdArray<dtype>& inY, const NdArray<dtype>& inX)
    {
        if (inX.shape() != inY.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array shapes are not consistant.");
        }

        NdArray<decltype(arctan2(dtype{ 0 }, dtype{ 0 }))> returnArray(inY.shape());
        stl_algorithms::transform(inY.cbegin(),
                                  inY.cend(),
                                  inX.cbegin(),
                                  returnArray.begin(),
                                  [](dtype y, dtype x) noexcept -> auto { return arctan2(y, x); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arctan2.hpp ***/


/*** Start of inlined file: arctanh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric inverse hyperbolic tangent.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctanh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto arctanh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::atanh(inValue);
    }

    // Method Description:
    /// Trigonometric inverse hyperbolic tangent, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.arctanh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto arctanh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(arctanh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return arctanh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: arctanh.hpp ***/


/*** Start of inlined file: argsort.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns the indices that would sort an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.argsort.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> argsort(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.argsort(inAxis);
    }
} // namespace nc

/*** End of inlined file: argsort.hpp ***/


/*** Start of inlined file: argwhere.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Find the indices of array elements that are non-zero, grouped by element.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.argwhere.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> argwhere(const NdArray<dtype>& inArray)
    {
        return inArray.flatnonzero();
    }
} // namespace nc

/*** End of inlined file: argwhere.hpp ***/


/*** Start of inlined file: around.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Evenly round to the given number of decimals.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.around.html
    ///
    /// @param inValue
    /// @param inNumDecimals: (Optional, default = 0)
    /// @return value
    ///
    template<typename dtype>
    dtype around(dtype inValue, uint8 inNumDecimals = 0)
    {
        NdArray<dtype> value = { inValue };
        return value.round(inNumDecimals).item();
    }

    // Method Description:
    /// Evenly round to the given number of decimals.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.around.html
    ///
    /// @param inArray
    /// @param inNumDecimals: (Optional, default = 0)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> around(const NdArray<dtype>& inArray, uint8 inNumDecimals = 0)
    {
        return inArray.round(inNumDecimals);
    }
} // namespace nc

/*** End of inlined file: around.hpp ***/


/*** Start of inlined file: array_equal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: array_equiv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns True if input arrays are shape consistent and all elements equal.
    ///
    /// Shape consistent means they are either the same shape, or one input array
    /// can be broadcasted to create the same shape as the other one.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.array_equiv.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool array_equiv(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (inArray1.size() != inArray2.size())
        {
            return false;
        }

        if (DtypeInfo<dtype>::isInteger())
        {
            return stl_algorithms::equal(inArray1.cbegin(), inArray1.cend(), inArray2.cbegin());
        }

        const auto comparitor = [](dtype value1, dtype value2) noexcept -> bool
        { return utils::essentiallyEqual(value1, value2); };

        return stl_algorithms::equal(inArray1.cbegin(), inArray1.cend(), inArray2.cbegin(), comparitor);
    }
} // namespace nc

/*** End of inlined file: array_equiv.hpp ***/

namespace nc
{

    // Method Description:
    /// True if two arrays have the same shape and elements, False otherwise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.array_equal.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool array_equal(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2) noexcept
    {
        if (inArray1.shape() != inArray2.shape())
        {
            return false;
        }

        return array_equiv(inArray1, inArray2);
    }
} // namespace nc

/*** End of inlined file: array_equal.hpp ***/


/*** Start of inlined file: asarray.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <array>
#include <deque>
#include <forward_list>
#include <initializer_list>
#include <iterator>
#include <list>
#include <set>
#include <type_traits>
#include <vector>

namespace nc
{

    // Method Description:
    /// Convert the list initializer to an array.
    /// eg: NdArray<int> myArray = NC::asarray<int>({1,2,3});
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inList
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
    NdArray<dtype> asarray(std::initializer_list<dtype> inList)
    {
        return NdArray<dtype>(inList);
    }

    // Method Description:
    /// Convert the list initializer to an array.
    /// eg: NdArray<int> myArray = NC::asarray<int>({{1,2,3}, {4, 5, 6}});
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inList
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(std::initializer_list<std::initializer_list<dtype>> inList)
    {
        return NdArray<dtype>(inList);
    }

    // Method Description:
    /// Convert the std::array to an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inArray
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype, size_t ArraySize, std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
    NdArray<dtype> asarray(std::array<dtype, ArraySize>& inArray, PointerPolicy pointerPolicy = PointerPolicy::COPY)
    {
        return NdArray<dtype>(inArray, pointerPolicy);
    }

    // Method Description:
    /// Convert the std::array to an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inArray
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype, size_t Dim0Size, size_t Dim1Size>
    NdArray<dtype> asarray(std::array<std::array<dtype, Dim1Size>, Dim0Size>& inArray,
                           PointerPolicy                                      pointerPolicy = PointerPolicy::COPY)
    {
        return NdArray<dtype>(inArray, pointerPolicy);
    }

    // Method Description:
    /// Convert the vector to an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inVector
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
    NdArray<dtype> asarray(std::vector<dtype>& inVector, PointerPolicy pointerPolicy = PointerPolicy::COPY)
    {
        return NdArray<dtype>(inVector, pointerPolicy);
    }

    // Method Description:
    /// Convert the vector to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inVector
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const std::vector<std::vector<dtype>>& inVector)
    {
        return NdArray<dtype>(inVector);
    }

    // Method Description:
    /// Convert the vector to an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inVector
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype, size_t Dim1Size>
    NdArray<dtype> asarray(std::vector<std::array<dtype, Dim1Size>>& inVector,
                           PointerPolicy                             pointerPolicy = PointerPolicy::COPY)
    {
        return NdArray<dtype>(inVector, pointerPolicy);
    }

    // Method Description:
    /// Convert the vector to an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inDeque
    /// @return NdArray
    ///
    template<typename dtype, std::enable_if_t<is_valid_dtype_v<dtype>, int> = 0>
    NdArray<dtype> asarray(const std::deque<dtype>& inDeque)
    {
        return NdArray<dtype>(inDeque);
    }

    // Method Description:
    /// Convert the vector to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inDeque
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const std::deque<std::deque<dtype>>& inDeque)
    {
        return NdArray<dtype>(inDeque);
    }

    // Method Description:
    /// Convert the set to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inSet
    /// @return NdArray
    ///
    template<typename dtype, typename dtypeComp>
    NdArray<dtype> asarray(const std::set<dtype, dtypeComp>& inSet)
    {
        return NdArray<dtype>(inSet);
    }

    // Method Description:
    /// Convert the list to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param inList
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const std::list<dtype>& inList)
    {
        return NdArray<dtype>(inList);
    }

    // Method Description:
    /// Convert the forward_list to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param iterBegin
    /// @param iterEnd
    /// @return NdArray
    ///
    template<typename Iterator>
    auto asarray(Iterator iterBegin, Iterator iterEnd)
    {
        return NdArray<typename std::iterator_traits<Iterator>::value_type>(iterBegin, iterEnd);
    }

    // Method Description:
    /// Convert the forward_list to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param iterBegin
    /// @param iterEnd
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const dtype* iterBegin, const dtype* iterEnd)
    {
        return NdArray<dtype>(iterBegin, iterEnd);
    }

    // Method Description:
    /// Convert the c-style array to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param ptr to array
    /// @param size: the number of elements in the array
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const dtype* ptr, uint32 size)
    {
        return NdArray<dtype>(ptr, size);
    }

    // Method Description:
    /// Convert the c-style array to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param ptr to array
    /// @param numRows: number of rows of the buffer
    /// @param numCols: number of cols of the buffer
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> asarray(const dtype* ptr, uint32 numRows, uint32 numCols)
    {
        return NdArray<dtype>(ptr, numRows, numCols);
    }

    // Method Description:
    /// Convert the c-style array to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param ptr to array
    /// @param size: the number of elements in the array
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype,
             typename UIntType,
             std::enable_if_t<std::is_integral_v<UIntType> && !std::is_same_v<UIntType, bool>, int> = 0>
    NdArray<dtype> asarray(dtype* ptr, UIntType size, PointerPolicy pointerPolicy = PointerPolicy::COPY) noexcept
    {
        return NdArray<dtype>(ptr, size, pointerPolicy);
    }

    // Method Description:
    /// Convert the c-style array to an array. Makes a copy of the data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.asarray.html
    ///
    /// @param ptr to array
    /// @param numRows: number of rows of the buffer
    /// @param numCols: number of cols of the buffer
    /// @param pointerPolicy: (optional) whether to make a copy and own the data, or
    ///                       act as a non-owning shell. Default Copy
    /// @return NdArray
    ///
    template<typename dtype,
             typename UIntType1,
             typename UIntType2,
             std::enable_if_t<std::is_integral_v<UIntType1> && !std::is_same_v<UIntType1, bool>, int> = 0,
             std::enable_if_t<std::is_integral_v<UIntType2> && !std::is_same_v<UIntType2, bool>, int> = 0>
    NdArray<dtype> asarray(dtype*        ptr,
                           UIntType1     numRows,
                           UIntType2     numCols,
                           PointerPolicy pointerPolicy = PointerPolicy::COPY) noexcept
    {
        return NdArray<dtype>(ptr, numRows, numCols, pointerPolicy);
    }
} // namespace nc

/*** End of inlined file: asarray.hpp ***/


/*** Start of inlined file: astype.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns a copy of the array, cast to a specified type.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtypeOut = double, typename dtype>
    NdArray<dtypeOut> astype(const NdArray<dtype> inArray)
    {
        return inArray.template astype<dtypeOut>();
    }
} // namespace nc

/*** End of inlined file: astype.hpp ***/


/*** Start of inlined file: average.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// Compute the average along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.average.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    auto average(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return mean(inArray, inAxis);
    }

    // Method Description:
    /// Compute the weighted average along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.average.html
    ///
    /// @param inArray
    /// @param inWeights
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> average(const NdArray<dtype>& inArray, const NdArray<dtype>& inWeights, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                if (inWeights.shape() != inArray.shape())
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array and weight values are not consistant.");
                }

                NdArray<double> weightedArray(inArray.shape());
                stl_algorithms::transform(inArray.cbegin(),
                                          inArray.cend(),
                                          inWeights.cbegin(),
                                          weightedArray.begin(),
                                          std::multiplies<double>()); // NOLINT(modernize-use-transparent-functors)

                double          sum         = std::accumulate(weightedArray.begin(), weightedArray.end(), 0.);
                NdArray<double> returnArray = { sum /= inWeights.template astype<double>().sum().item() };

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape arrayShape = inArray.shape();
                if (inWeights.size() != arrayShape.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array and weights value are not consistant.");
                }

                double          weightSum = inWeights.template astype<double>().sum().item();
                NdArray<double> returnArray(1, arrayShape.rows);
                for (uint32 row = 0; row < arrayShape.rows; ++row)
                {
                    NdArray<double> weightedArray(1, arrayShape.cols);
                    stl_algorithms::transform(inArray.cbegin(row),
                                              inArray.cend(row),
                                              inWeights.cbegin(),
                                              weightedArray.begin(),
                                              std::multiplies<double>()); // NOLINT(modernize-use-transparent-functors)

                    double sum          = std::accumulate(weightedArray.begin(), weightedArray.end(), 0.);
                    returnArray(0, row) = sum / weightSum;
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return average(inArray.transpose(), inWeights, Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {};
            }
        }
    }

    // Method Description:
    /// Compute the weighted average along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.average.html
    ///
    /// @param inArray
    /// @param inWeights
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>>
        average(const NdArray<std::complex<dtype>>& inArray, const NdArray<dtype>& inWeights, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto multiplies = [](const std::complex<dtype>& lhs, dtype rhs) -> std::complex<double>
        { return complex_cast<double>(lhs) * static_cast<double>(rhs); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                if (inWeights.shape() != inArray.shape())
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array and weight values are not consistant.");
                }

                NdArray<std::complex<double>> weightedArray(inArray.shape());
                stl_algorithms::transform(inArray.cbegin(),
                                          inArray.cend(),
                                          inWeights.cbegin(),
                                          weightedArray.begin(),
                                          multiplies);

                std::complex<double> sum =
                    std::accumulate(weightedArray.begin(), weightedArray.end(), std::complex<double>(0.));
                NdArray<std::complex<double>> returnArray = { sum /= inWeights.template astype<double>().sum().item() };

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape arrayShape = inArray.shape();
                if (inWeights.size() != arrayShape.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array and weights value are not consistant.");
                }

                double                        weightSum = inWeights.template astype<double>().sum().item();
                NdArray<std::complex<double>> returnArray(1, arrayShape.rows);
                for (uint32 row = 0; row < arrayShape.rows; ++row)
                {
                    NdArray<std::complex<double>> weightedArray(1, arrayShape.cols);
                    stl_algorithms::transform(inArray.cbegin(row),
                                              inArray.cend(row),
                                              inWeights.cbegin(),
                                              weightedArray.begin(),
                                              multiplies);

                    const std::complex<double> sum =
                        std::accumulate(weightedArray.begin(), weightedArray.end(), std::complex<double>(0.));
                    returnArray(0, row) = sum / weightSum;
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return average(inArray.transpose(), inWeights, Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: average.hpp ***/


/*** Start of inlined file: bartlett.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>


/*** Start of inlined file: linspace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Return evenly spaced numbers over a specified interval.
    ///
    /// Returns num evenly spaced samples, calculated over the
    /// interval[start, stop].
    ///
    /// The endpoint of the interval can optionally be excluded.
    ///
    /// Mostly only usefull if called with a floating point type
    /// for the template argument.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.linspace.html
    ///
    /// @param inStart
    /// @param inStop
    /// @param inNum: number of points (default = 50)
    /// @param endPoint: include endPoint (default = true)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> linspace(dtype inStart, dtype inStop, uint32 inNum = 50, EndPoint endPoint = EndPoint::YES)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inNum == 0)
        {
            return NdArray<dtype>(0);
        }

        if (inNum == 1)
        {
            NdArray<dtype> returnArray = { inStart };
            return returnArray;
        }

        if (inStop <= inStart)
        {
            THROW_INVALID_ARGUMENT_ERROR("stop value must be greater than the start value.");
        }

        if (endPoint == EndPoint::YES)
        {
            if (inNum == 2)
            {
                NdArray<dtype> returnArray = { inStart, inStop };
                return returnArray;
            }

            NdArray<dtype> returnArray(1, inNum);
            returnArray.front() = inStart;
            returnArray.back()  = inStop;

            dtype step = (inStop - inStart) / static_cast<dtype>(inNum - 1);

            for (uint32 i = 1; i < inNum - 1; ++i)
            {
                returnArray[i] = inStart + static_cast<dtype>(i) * step;
            }

            return returnArray;
        }

        if (inNum == 2)
        {
            dtype          step        = (inStop - inStart) / (inNum);
            NdArray<dtype> returnArray = { inStart, inStart + step };
            return returnArray;
        }

        NdArray<dtype> returnArray(1, inNum);
        returnArray.front() = inStart;

        dtype step = (inStop - inStart) / static_cast<dtype>(inNum);

        for (uint32 i = 1; i < inNum; ++i)
        {
            returnArray[i] = inStart + static_cast<dtype>(i) * step;
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: linspace.hpp ***/

namespace nc
{

    // Method Description:
    /// The Bartlett window is very similar to a triangular window, except that the end
    /// points are at zero. It is often used in signal processing for tapering a signal,
    /// without generating too much ripple in the frequency domain.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html
    ///
    /// @param m: Number of points in the output window. If zero or less, an empty array is returned.
    /// @return NdArray
    ///
    inline NdArray<double> bartlett(int32 m)
    {
        if (m < 1)
        {
            return {};
        }

        const auto mDouble         = static_cast<double>(m);
        const auto mMinus1Over2    = (mDouble - 1.) / 2.;
        const auto mMinus1Over2Inv = 1. / mMinus1Over2;

        NdArray<double> result(1, m);
        int32           i = 0;
        for (auto n : linspace(0., mDouble - 1., m, EndPoint::YES))
        {
            result[i++] = mMinus1Over2Inv * (mMinus1Over2 - std::abs(n - mMinus1Over2));
        }

        return result;
    }
} // namespace nc

/*** End of inlined file: bartlett.hpp ***/


/*** Start of inlined file: binaryRepr.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <bitset>
#include <string>

namespace nc
{

    // Method Description:
    /// Return the binary representation of the input number as a string.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.binary_repr.html
    ///
    /// @param inValue
    /// @return std::string
    ///
    template<typename dtype>
    std::string binaryRepr(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::bitset<DtypeInfo<dtype>::bits()>(inValue).to_string();
    }
} // namespace nc

/*** End of inlined file: binaryRepr.hpp ***/


/*** Start of inlined file: bincount.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Count number of occurrences of each value in array of non-negative ints.
    /// Negative values will be counted in the zero bin.
    ///
    /// The number of bins(of size 1) is one larger than the largest value in x.
    /// If minlength is specified, there will be at least this number of bins in
    /// the output array(though it will be longer if necessary, depending on the
    /// contents of x).Each bin gives the number of occurrences of its index value
    /// in x.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.bincount.html
    ///
    /// @param inArray
    /// @param inMinLength
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bincount(const NdArray<dtype>& inArray, uint16 inMinLength = 1)
    {
        STATIC_ASSERT_INTEGER(dtype);

        dtype maxValue = inArray.max().item();
        if (maxValue < 0)
        {
            // no positive values so just return an empty array
            return NdArray<dtype>(0);
        }

        if (maxValue + 1 > DtypeInfo<dtype>::max())
        {
            THROW_INVALID_ARGUMENT_ERROR(
                "array values too large, will result in gigantic array that will take up alot of memory...");
        }

        const uint16   outArraySize = std::max(static_cast<uint16>(maxValue + 1), inMinLength);
        NdArray<dtype> clippedArray = inArray.clip(0, maxValue);

        NdArray<dtype> outArray(1, outArraySize);
        outArray.zeros();
        std::for_each(clippedArray.cbegin(),
                      clippedArray.cend(),
                      [&outArray](dtype value) noexcept -> void { ++outArray[value]; });

        return outArray;
    }

    // Method Description:
    /// Count number of occurrences of each value in array of non-negative ints.
    /// Negative values will be counted in the zero bin.
    ///
    /// The number of bins(of size 1) is one larger than the largest value in x.
    /// If minlength is specified, there will be at least this number of bins in
    /// the output array(though it will be longer if necessary, depending on the
    /// contents of x).Each bin gives the number of occurrences of its index value
    /// in x.If weights is specified the input array is weighted by it, i.e. if a
    /// value n is found at position i, out[n] += weight[i] instead of out[n] += 1.
    /// Weights array shall be of the same shape as inArray.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.bincount.html
    ///
    /// @param inArray
    /// @param inWeights
    /// @param inMinLength
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bincount(const NdArray<dtype>& inArray, const NdArray<dtype>& inWeights, uint16 inMinLength = 1)
    {
        STATIC_ASSERT_INTEGER(dtype);

        if (inArray.shape() != inWeights.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("weights array must be the same shape as the input array.");
        }

        dtype maxValue = inArray.max().item();
        if (maxValue < 0)
        {
            // no positive values so just return an empty array
            return NdArray<dtype>(0);
        }

        if (maxValue + 1 > DtypeInfo<dtype>::max())
        {
            THROW_INVALID_ARGUMENT_ERROR(
                "array values too large, will result in gigantic array that will take up alot of memory...");
        }

        const uint16   outArraySize = std::max(static_cast<uint16>(maxValue + 1), inMinLength);
        NdArray<dtype> clippedArray = inArray.clip(0, maxValue);

        NdArray<dtype> outArray(1, outArraySize);
        outArray.zeros();
        uint32 counter = 0;
        std::for_each(clippedArray.cbegin(),
                      clippedArray.cend(),
                      [&outArray, &inWeights, &counter](dtype value) noexcept -> void
                      { outArray[value] += inWeights[counter++]; });

        return outArray;
    }
} // namespace nc

/*** End of inlined file: bincount.hpp ***/


/*** Start of inlined file: bit_count.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Computes the number of 1-bits in an integer
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    constexpr int bit_count(dtype inValue) noexcept
    {
        STATIC_ASSERT_UNSIGNED_INTEGER(dtype);

        int count = 0;
        for (int bit = 0; bit < DtypeInfo<dtype>::bits(); ++bit)
        {
            count += static_cast<int>((inValue & (dtype{ 1 } << bit)) >> bit);
        }

        return count;
    }

    // Method Description:
    /// Computes the number of 1-bits in an integer
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<int> bit_count(const NdArray<dtype>& inArray)
    {
        NdArray<int> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> int { return bit_count(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: bit_count.hpp ***/


/*** Start of inlined file: bitwise_and.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the bit-wise AND of two arrays element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.bitwise_and.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bitwise_and(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 & inArray2;
    }
} // namespace nc

/*** End of inlined file: bitwise_and.hpp ***/


/*** Start of inlined file: bitwise_not.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the bit-wise NOT the input array element-wise.
    ///
    /// inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bitwise_not(const NdArray<dtype>& inArray)
    {
        return ~inArray;
    }
} // namespace nc

/*** End of inlined file: bitwise_not.hpp ***/


/*** Start of inlined file: bitwise_or.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the bit-wise OR of two arrays element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.bitwise_or.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bitwise_or(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 | inArray2;
    }
} // namespace nc

/*** End of inlined file: bitwise_or.hpp ***/


/*** Start of inlined file: bitwise_xor.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the bit-wise XOR of two arrays element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.bitwise_xor.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> bitwise_xor(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 ^ inArray2;
    }
} // namespace nc

/*** End of inlined file: bitwise_xor.hpp ***/


/*** Start of inlined file: blackman.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// The Blackman window is a taper formed by using the first three terms of a summation of
    /// cosines. It was designed to have close to the minimal leakage possible. It is close to
    /// optimal, only slightly worse than a Kaiser window.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.blackman.html
    ///
    /// @param m: Number of points in the output window. If zero or less, an empty array is returned.
    /// @return NdArray
    ///
    inline NdArray<double> blackman(int32 m)
    {
        if (m < 1)
        {
            return {};
        }

        const auto mDouble = static_cast<double>(m);

        NdArray<double> result(1, m);
        int32           i = 0;
        for (auto n : linspace(0., mDouble, m, EndPoint::YES))
        {
            const auto nOverM = n / mDouble;
            result[i++] =
                0.42 - 0.5 * std::cos(2. * constants::pi * nOverM) + 0.08 * std::cos(4. * constants::pi * nOverM);
        }

        return result;
    }
} // namespace nc

/*** End of inlined file: blackman.hpp ***/


/*** Start of inlined file: byteswap.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array with the bytes of the array elements
    /// swapped.
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> byteswap(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray);
        returnArray.byteswap();
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: byteswap.hpp ***/


/*** Start of inlined file: cbrt.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the cube-root of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cbrt.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    double cbrt(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::cbrt(static_cast<double>(inValue));
    }

    // Method Description:
    /// Return the cube-root of an array, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cbrt.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> cbrt(const NdArray<dtype>& inArray)
    {
        NdArray<double> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> double { return cbrt(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: cbrt.hpp ***/


/*** Start of inlined file: ceil.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the ceiling of the input.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ceil.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    dtype ceil(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::ceil(inValue);
    }

    // Method Description:
    /// Return the ceiling of the input, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ceil.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ceil(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return ceil(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: ceil.hpp ***/


/*** Start of inlined file: centerOfMass.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns the center of mass of the array values along an axis.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE which is a 2d center of mass)
    /// @return NdArray: if axis is NONE then a 1x2 array of the centroid row/col is returned.
    ///
    template<typename dtype>
    NdArray<double> centerOfMass(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape shape = inArray.shape();

        switch (inAxis)
        {
            case Axis::NONE:
            {
                double inten     = 0.;
                double rowCenter = 0.;
                double colCenter = 0.;

                for (uint32 row = 0; row < shape.rows; ++row)
                {
                    for (uint32 col = 0; col < shape.cols; ++col)
                    {
                        const auto pixelValue = static_cast<double>(inArray(row, col));

                        inten += pixelValue;
                        rowCenter += pixelValue * static_cast<double>(row);
                        colCenter += pixelValue * static_cast<double>(col);
                    }
                }

                rowCenter /= inten;
                colCenter /= inten;

                return { rowCenter, colCenter };
            }
            case Axis::ROW:
            {
                NdArray<double> returnArray(1, shape.cols);
                returnArray.zeros();

                const NdArray<double> inten = inArray.template astype<double>().sum(inAxis);

                for (uint32 colIdx = 0; colIdx < shape.cols; ++colIdx)
                {
                    for (uint32 rowIdx = 0; rowIdx < shape.rows; ++rowIdx)
                    {
                        returnArray(0, colIdx) +=
                            static_cast<double>(inArray(rowIdx, colIdx)) * static_cast<double>(rowIdx);
                    }

                    returnArray(0, colIdx) /= inten[colIdx];
                }

                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(1, shape.rows);
                returnArray.zeros();

                const NdArray<double> inten = inArray.template astype<double>().sum(inAxis);

                for (uint32 rowIdx = 0; rowIdx < shape.rows; ++rowIdx)
                {
                    for (uint32 colIdx = 0; colIdx < shape.cols; ++colIdx)
                    {
                        returnArray(0, rowIdx) +=
                            static_cast<double>(inArray(rowIdx, colIdx)) * static_cast<double>(colIdx);
                    }

                    returnArray(0, rowIdx) /= inten[rowIdx];
                }

                return returnArray;
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: centerOfMass.hpp ***/


/*** Start of inlined file: column_stack.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <string>
#include <vector>

namespace nc
{
    namespace detail
    {

        // Method Description:
        /// Stack 1-D arrays as columns into a 2-D array.
        ///
        /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.column_stack.html
        ///
        /// @param begin: iterator to the beginning of the span
        /// @param end: iterator to one past the end of the span
        /// @return NdArray
        ///
        template<typename dtype, typename Iterator>
        NdArray<dtype> column_stack(Iterator begin, Iterator end)
        {
            // first loop through to calculate the final size of the array
            Shape finalShape;
            auto  iter = begin;
            while (iter != end)
            {
                const auto& ndarray = *iter++;
                if (ndarray.shape().isnull())
                {
                    continue;
                }

                if (finalShape.isnull())
                {
                    finalShape = ndarray.shape();
                }
                else if (ndarray.shape().rows != finalShape.rows)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input arrays must have the same number of rows.");
                }
                else
                {
                    finalShape.cols += ndarray.shape().cols;
                }
            }

            // now that we know the final size, contruct the output array
            NdArray<dtype> returnArray(finalShape);
            uint32         colStart = 0;
            iter                    = begin;
            while (iter != end)
            {
                const auto& ndarray  = *iter++;
                const Shape theShape = ndarray.shape();
                for (uint32 row = 0; row < theShape.rows; ++row)
                {
                    for (uint32 col = 0; col < theShape.cols; ++col)
                    {
                        returnArray(row, colStart + col) = ndarray(row, col);
                    }
                }
                colStart += theShape.cols;
            }

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Stack 1-D arrays as columns into a 2-D array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.column_stack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> column_stack(const std::initializer_list<NdArray<dtype>>& inArrayList)
    {
        return detail::column_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }

    // Method Description:
    /// Stack 1-D arrays as columns into a 2-D array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.column_stack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> column_stack(const std::vector<NdArray<dtype>>& inArrayList)
    {
        return detail::column_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }
} // namespace nc

/*** End of inlined file: column_stack.hpp ***/


/*** Start of inlined file: concatenate.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <vector>


/*** Start of inlined file: row_stack.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <string>
#include <vector>

namespace nc
{
    namespace detail
    {

        // Method Description:
        /// Stack arrays in sequence vertically (row wise).
        ///
        /// @param begin: iterator to the beginning of the span
        /// @param end: iterator to one past the end of the span
        ///
        /// @return NdArray
        ///
        template<typename dtype, typename Iterator>
        NdArray<dtype> row_stack(Iterator begin, Iterator end)
        {
            // first loop through to calculate the final size of the array
            Shape finalShape;
            auto  iter = begin;
            while (iter != end)
            {
                const auto& ndarray = *iter++;
                if (ndarray.shape().isnull())
                {
                    continue;
                }

                if (finalShape.isnull())
                {
                    finalShape = ndarray.shape();
                }
                else if (ndarray.shape().cols != finalShape.cols)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input arrays must have the same number of columns.");
                }
                else
                {
                    finalShape.rows += ndarray.shape().rows;
                }
            }

            // now that we know the final size, contruct the output array
            NdArray<dtype> returnArray(finalShape);
            uint32         rowStart = 0;
            iter                    = begin;
            while (iter != end)
            {
                const auto& ndarray  = *iter++;
                const Shape theShape = ndarray.shape();
                for (uint32 row = 0; row < theShape.rows; ++row)
                {
                    for (uint32 col = 0; col < theShape.cols; ++col)
                    {
                        returnArray(rowStart + row, col) = ndarray(row, col);
                    }
                }
                rowStart += theShape.rows;
            }

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Stack arrays in sequence vertically (row wise).
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> row_stack(const std::initializer_list<NdArray<dtype>>& inArrayList)
    {
        return detail::row_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }

    // Method Description:
    /// Stack arrays in sequence vertically (row wise).
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> row_stack(const std::vector<NdArray<dtype>>& inArrayList)
    {
        return detail::row_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }
} // namespace nc

/*** End of inlined file: row_stack.hpp ***/

namespace nc
{
    namespace detail
    {

        // Method Description:
        /// Join a sequence of arrays along an existing axis.
        ///
        /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.concatenate.html
        ///
        /// @param begin: the begin iterator
        /// @param end: the end iterator
        /// @param inAxis (Optional, default NONE)
        /// @return NdArray
        ///
        template<typename dtype, typename Iterator>
        NdArray<dtype> concatenate(Iterator begin, Iterator end, Axis inAxis = Axis::NONE)
        {
            switch (inAxis)
            {
                case Axis::NONE:
                {
                    uint32 finalSize = 0;
                    auto   iter      = begin;
                    while (iter != end)
                    {
                        const auto& ndarray = *iter++;
                        finalSize += ndarray.size();
                    }

                    NdArray<dtype> returnArray(1, finalSize);
                    uint32         offset = 0;
                    iter                  = begin;
                    while (iter != end)
                    {
                        const auto& ndarray = *iter++;
                        stl_algorithms::copy(ndarray.cbegin(), ndarray.cend(), returnArray.begin() + offset);
                        offset += ndarray.size();
                    }

                    return returnArray;
                }
                case Axis::ROW:
                {
                    return row_stack<dtype>(begin, end);
                }
                case Axis::COL:
                {
                    return column_stack<dtype>(begin, end);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                    return {}; // get rid of compiler warning
                }
            }
        }
    } // namespace detail

    // Method Description:
    /// Join a sequence of arrays along an existing axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.concatenate.html
    ///
    /// @param inArrayList
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> concatenate(const std::initializer_list<NdArray<dtype>>& inArrayList, Axis inAxis = Axis::NONE)
    {
        return detail::concatenate<dtype>(inArrayList.begin(), inArrayList.end(), inAxis);
    }

    // Method Description:
    /// Join a sequence of arrays along an existing axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.concatenate.html
    ///
    /// @param inArrayList
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> concatenate(const std::vector<NdArray<dtype>>& inArrayList, Axis inAxis = Axis::NONE)
    {
        return detail::concatenate<dtype>(inArrayList.begin(), inArrayList.end(), inAxis);
    }
} // namespace nc

/*** End of inlined file: concatenate.hpp ***/


/*** Start of inlined file: conj.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Return the complex conjugate of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.conj.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto conj(const std::complex<dtype>& inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::conj(inValue);
    }

    // Method Description:
    /// Return the complex conjugate of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.conj.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto conj(const NdArray<std::complex<dtype>>& inArray)
    {
        NdArray<decltype(nc::conj(std::complex<dtype>{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](auto& inValue) -> auto { return nc::conj(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: conj.hpp ***/


/*** Start of inlined file: contains.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// returns whether or not a value is included the array
    ///
    /// @param inArray
    /// @param inValue
    /// @param inAxis (Optional, default NONE)
    /// @return bool
    ///
    template<typename dtype>
    NdArray<bool> contains(const NdArray<dtype>& inArray, dtype inValue, Axis inAxis = Axis::NONE)
    {
        return inArray.contains(inValue, inAxis);
    }
} // namespace nc

/*** End of inlined file: contains.hpp ***/


/*** Start of inlined file: copy.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return an array copy of the given object.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.copy.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> copy(const NdArray<dtype>& inArray)
    {
        return NdArray<dtype>(inArray);
    }
} // namespace nc

/*** End of inlined file: copy.hpp ***/


/*** Start of inlined file: copySign.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Change the sign of x1 to that of x2, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.copysign.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> copySign(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inArray1.shape() != inArray2.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input arrays are not consistant.");
        }

        NdArray<dtype> returnArray(inArray1.shape());
        stl_algorithms::transform(inArray1.cbegin(),
                                  inArray1.cend(),
                                  inArray2.cbegin(),
                                  returnArray.begin(),
                                  [](dtype inValue1, dtype inValue2) -> dtype
                                  { return inValue2 < dtype{ 0 } ? std::abs(inValue1) * -1 : std::abs(inValue1); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: copySign.hpp ***/


/*** Start of inlined file: copyto.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Copies values from one array to another
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.copyto.html
    ///
    /// @param inDestArray
    /// @param inSrcArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& copyto(NdArray<dtype>& inDestArray, const NdArray<dtype>& inSrcArray)
    {
        inDestArray = inSrcArray;
        return inDestArray;
    }
} // namespace nc

/*** End of inlined file: copyto.hpp ***/


/*** Start of inlined file: corrcoef.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: cov.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <type_traits>

namespace nc
{

    // Method Description:
    /// Estimate a covariance matrix.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.cov.html
    ///
    /// @param x: A 1-D or 2-D array containing multiple variables and observations.
    /// Each row of x represents a variable, and each column a single observation
    /// of all those variables.
    /// @param bias: Default normalization (false) is by (N - 1), where N is the number of observations
    /// given (unbiased estimate). If bias is True, then normalization is by N.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> cov(const NdArray<dtype>& x, Bias bias = Bias::NO)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto varMeans = mean(x, Axis::COL);
        const auto numVars  = x.numRows();
        const auto numObs   = x.numCols();
        const auto normilizationFactor =
            bias == Bias::YES ? static_cast<double>(numObs) : static_cast<double>(numObs - 1);
        using IndexType = typename std::remove_const<decltype(numVars)>::type;

        // upper triangle
        auto covariance = NdArray<double>(numVars);
        for (IndexType i = 0; i < numVars; ++i)
        {
            const auto var1Mean = varMeans[i];

            for (IndexType j = i; j < numVars; ++j)
            {
                const auto var2Mean = varMeans[j];

                double sum = 0.;
                for (IndexType iObs = 0; iObs < numObs; ++iObs)
                {
                    sum += (x(i, iObs) - var1Mean) * (x(j, iObs) - var2Mean);
                }

                covariance(i, j) = sum / normilizationFactor;
            }
        }

        // fill in the rest of the symmetric matrix
        for (IndexType j = 0; j < numVars; ++j)
        {
            for (IndexType i = j + 1; i < numVars; ++i)
            {
                covariance(i, j) = covariance(j, i);
            }
        }

        return covariance;
    }
} // namespace nc

/*** End of inlined file: cov.hpp ***/


/*** Start of inlined file: empty_like.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array with the same shape as a given array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.empty_like.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> empty_like(const NdArray<dtype>& inArray)
    {
        return NdArray<dtype>(inArray.shape());
    }
} // namespace nc

/*** End of inlined file: empty_like.hpp ***/


/*** Start of inlined file: sqrt.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Return the positive square-root of a value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sqrt.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto sqrt(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::sqrt(inValue);
    }

    // Method Description:
    /// Return the positive square-root of an array, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sqrt.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto sqrt(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(sqrt(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return sqrt(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sqrt.hpp ***/

namespace nc
{

    // Method Description:
    /// Return Pearson product-moment correlation coefficients.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html
    ///
    /// @param x: A 1-D or 2-D array containing multiple variables and observations.
    /// Each row of x represents a variable, and each column a single observation
    /// of all those variables.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> corrcoef(const NdArray<dtype>& x)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto covariance           = cov(x);
        auto       normalizedCovariance = empty_like(covariance);
        for (decltype(covariance.numRows()) i = 0; i < covariance.numRows(); ++i)
        {
            for (decltype(covariance.numCols()) j = 0; j < covariance.numCols(); ++j)
            {
                normalizedCovariance(i, j) = covariance(i, j) / sqrt(covariance(i, i) * covariance(j, j));
            }
        }

        return normalizedCovariance;
    }
} // namespace nc

/*** End of inlined file: corrcoef.hpp ***/


/*** Start of inlined file: cos.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Cosine
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cos.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto cos(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::cos(inValue);
    }

    // Method Description:
    /// Cosine element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cos.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto cos(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(cos(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return cos(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: cos.hpp ***/


/*** Start of inlined file: cosh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Hyperbolic Cosine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cosh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto cosh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::cosh(inValue);
    }

    // Method Description:
    /// Hyperbolic Cosine element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cosh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto cosh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(cosh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return cosh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: cosh.hpp ***/


/*** Start of inlined file: count_nonzero.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Counts the number of non-zero values in the array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.count_nonzero.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> count_nonzero(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                NdArray<uint32> count = { inArray.size() -
                                          static_cast<uint32>(
                                              stl_algorithms::count(inArray.cbegin(), inArray.cend(), dtype{ 0 })) };
                return count;
            }
            case Axis::COL:
            {
                Shape inShape = inArray.shape();

                NdArray<uint32> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    returnArray(0, row) =
                        inShape.cols -
                        static_cast<uint32>(stl_algorithms::count(inArray.cbegin(row), inArray.cend(row), dtype{ 0 }));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return count_nonzero(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: count_nonzero.hpp ***/


/*** Start of inlined file: cov_inv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Estimate an inverse covariance matrix, aka the concentration matrix
    ///
    /// @param x: A 1-D or 2-D array containing multiple variables and observations.
    /// Each row of x represents a variable, and each column a single observation
    /// of all those variables.
    /// @param bias: Default normalization (false) is by (N - 1), where N is the number of observations
    /// given (unbiased estimate). If bias is True, then normalization is by N.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> cov_inv(const NdArray<dtype>& x, Bias bias = Bias::NO)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return linalg::inv(cov(x, bias));
    }
} // namespace nc

/*** End of inlined file: cov_inv.hpp ***/


/*** Start of inlined file: cross.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Return the cross product of two (arrays of) vectors.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cross.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> cross(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (inArray1.shape() != inArray2.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("the input array dimensions are not consistant.");
        }

        switch (inAxis)
        {
            case Axis::NONE:
            {
                const uint32 arraySize = inArray1.size();
                if (arraySize != inArray2.size() || arraySize < 2 || arraySize > 3)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "incompatible dimensions for cross product (dimension must be 2 or 3)");
                }

                NdArray<dtype> in1 = inArray1.flatten();
                NdArray<dtype> in2 = inArray2.flatten();

                switch (arraySize)
                {
                    case 2:
                    {
                        NdArray<dtype> returnArray = { in1[0] * in2[1] - in1[1] * in2[0] };
                        return returnArray;
                    }
                    case 3:
                    {
                        dtype i = in1[1] * in2[2] - in1[2] * in2[1];
                        dtype j = -(in1[0] * in2[2] - in1[2] * in2[0]);
                        dtype k = in1[0] * in2[1] - in1[1] * in2[0];

                        NdArray<dtype> returnArray = { i, j, k };
                        return returnArray;
                    }
                    default:
                    {
                        THROW_INVALID_ARGUMENT_ERROR("Unimplemented array size.");
                        return {}; // get rid of compiler warning
                    }
                }
            }
            case Axis::ROW:
            {
                const Shape arrayShape = inArray1.shape();
                if (arrayShape != inArray2.shape() || arrayShape.rows < 2 || arrayShape.rows > 3)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "incompatible dimensions for cross product (dimension must be 2 or 3)");
                }

                Shape returnArrayShape;
                returnArrayShape.cols = arrayShape.cols;
                if (arrayShape.rows == 2)
                {
                    returnArrayShape.rows = 1;
                }
                else
                {
                    returnArrayShape.rows = 3;
                }

                NdArray<dtype> returnArray(returnArrayShape);
                for (uint32 col = 0; col < arrayShape.cols; ++col)
                {
                    const auto     theCol   = static_cast<int32>(col);
                    NdArray<dtype> vec1     = inArray1(inArray1.rSlice(), { theCol, theCol + 1 });
                    NdArray<dtype> vec2     = inArray2(inArray2.rSlice(), { theCol, theCol + 1 });
                    NdArray<dtype> vecCross = cross(vec1, vec2, Axis::NONE);

                    returnArray.put({ 0, static_cast<int32>(returnArrayShape.rows) }, { theCol, theCol + 1 }, vecCross);
                }

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape arrayShape = inArray1.shape();
                if (arrayShape != inArray2.shape() || arrayShape.cols < 2 || arrayShape.cols > 3)
                {
                    THROW_INVALID_ARGUMENT_ERROR(
                        "incompatible dimensions for cross product (dimension must be 2 or 3)");
                }

                Shape returnArrayShape;
                returnArrayShape.rows = arrayShape.rows;
                if (arrayShape.cols == 2)
                {
                    returnArrayShape.cols = 1;
                }
                else
                {
                    returnArrayShape.cols = 3;
                }

                NdArray<dtype> returnArray(returnArrayShape);
                for (uint32 row = 0; row < arrayShape.rows; ++row)
                {
                    const auto     theRow   = static_cast<int32>(row);
                    NdArray<dtype> vec1     = inArray1({ theRow, theRow + 1 }, inArray1.cSlice());
                    NdArray<dtype> vec2     = inArray2({ theRow, theRow + 1 }, inArray2.cSlice());
                    NdArray<dtype> vecCross = cross(vec1, vec2, Axis::NONE);

                    returnArray.put({ theRow, theRow + 1 }, { 0, static_cast<int32>(returnArrayShape.cols) }, vecCross);
                }

                return returnArray;
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: cross.hpp ***/


/*** Start of inlined file: cube.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: cube.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Cubes in input value
///
#pragma once

namespace nc::utils
{

    /// Cubes in input value
    ///
    /// @param inValue
    ///
    /// @return cubed value
    ///
    template<typename dtype>
    constexpr dtype cube(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return inValue * inValue * inValue;
    }
} // namespace nc::utils

/*** End of inlined file: cube.hpp ***/

namespace nc
{

    // Method Description:
    /// Cubes the input
    ///
    /// @param inValue
    /// @return cubed value
    ///
    template<typename dtype>
    constexpr dtype cube(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return utils::cube(inValue);
    }

    // Method Description:
    /// Cubes the elements of the array
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> cube(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return cube(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: cube.hpp ***/


/*** Start of inlined file: cumprod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the cumulative product of elements along a given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cumprod.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> cumprod(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.cumprod(inAxis);
    }
} // namespace nc

/*** End of inlined file: cumprod.hpp ***/


/*** Start of inlined file: cumsum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the cumulative sum of the elements along a given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.cumsum.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> cumsum(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.cumsum(inAxis);
    }
} // namespace nc

/*** End of inlined file: cumsum.hpp ***/


/*** Start of inlined file: degrees.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.degrees.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    constexpr auto degrees(dtype inValue) noexcept
    {
        return rad2deg(inValue);
    }

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.degrees.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto degrees(const NdArray<dtype>& inArray)
    {
        return rad2deg(inArray);
    }
} // namespace nc

/*** End of inlined file: degrees.hpp ***/


/*** Start of inlined file: deleteIndices.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>
#include <vector>


/*** Start of inlined file: unique.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>
#include <vector>

namespace nc
{

    // Method Description:
    /// Find the unique elements of an array.
    ///
    /// Returns the sorted unique elements of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.unique.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> unique(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto comp = [](const dtype lhs, const dtype rhs) noexcept -> bool
        { return utils::essentiallyEqual(lhs, rhs); };

        const auto sorted = sort(inArray);

        std::vector<dtype> res(sorted.size());
        const auto         last = stl_algorithms::unique_copy(sorted.begin(), sorted.end(), res.begin(), comp);

        return NdArray<dtype>(res.begin(), last);
    }
} // namespace nc

/*** End of inlined file: unique.hpp ***/

namespace nc
{
    namespace detail
    {

        // Method Description:
        /// Return a new array with sub-arrays deleted.
        ///
        /// @param inArray
        /// @param inIndices
        /// @return NdArray
        ///
        template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        NdArray<dtype> deleteFlatIndices(const NdArray<dtype>& inArray, Indices inIndices)
        {
            if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
            {
                const auto arraySize = inArray.size();
                stl_algorithms::for_each(inIndices.begin(),
                                         inIndices.end(),
                                         [arraySize](auto& value)
                                         {
                                             if (value < 0)
                                             {
                                                 value += arraySize;
                                             }
                                         });
            }

            auto indices = unique(inIndices);

            std::vector<dtype> values;
            values.reserve(indices.size());
            for (int32 i = 0; i < static_cast<int32>(inArray.size()); ++i)
            {
                if (std::binary_search(indices.begin(), indices.end(), i))
                {
                    continue;
                }

                values.push_back(inArray[i]);
            }

            return NdArray<dtype>(values);
        }

        // Method Description:
        /// Return a new array with sub-arrays along the row axis deleted.
        ///
        /// @param inArray
        /// @param inIndices
        /// @return NdArray
        ///
        template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        NdArray<dtype> deleteRowIndices(const NdArray<dtype>& inArray, Indices inIndices)
        {
            const auto arrayRows = static_cast<int32>(inArray.numRows());
            if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
            {
                stl_algorithms::for_each(inIndices.begin(),
                                         inIndices.end(),
                                         [arrayRows](auto& value)
                                         {
                                             if (value < 0)
                                             {
                                                 value += arrayRows;
                                             }
                                         });
            }

            auto indices = unique(inIndices);

            uint32 indicesSize = 0;
            std::for_each(indices.begin(),
                          indices.end(),
                          [arrayRows, &indicesSize](const auto& value)
                          {
                              if constexpr (std::is_signed_v<decltype(value)>)
                              {
                                  if (value >= 0 && value < arrayRows)
                                  {
                                      ++indicesSize;
                                  }
                              }
                              else
                              {
                                  if (value < arrayRows)
                                  {
                                      ++indicesSize;
                                  }
                              }
                          });

            const auto     arrayCols = static_cast<int32>(inArray.numCols());
            NdArray<dtype> returnArray(arrayRows - indicesSize, arrayCols);

            uint32 rowCounter = 0;
            for (int32 row = 0; row < arrayRows; ++row)
            {
                if (std::binary_search(indices.begin(), indices.end(), row))
                {
                    continue;
                }

                for (int32 col = 0; col < arrayCols; ++col)
                {
                    returnArray(rowCounter, col) = inArray(row, col);
                }

                ++rowCounter;
            }

            return returnArray;
        }

        // Method Description:
        /// Return a new array with sub-arrays along the col axis deleted.
        ///
        /// @param inArray
        /// @param inIndices
        /// @return NdArray
        ///
        template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
        NdArray<dtype> deleteColumnIndices(const NdArray<dtype>& inArray, Indices inIndices)
        {
            const auto arrayCols = static_cast<int32>(inArray.numCols());
            if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
            {
                stl_algorithms::for_each(inIndices.begin(),
                                         inIndices.end(),
                                         [arrayCols](auto& value)
                                         {
                                             if (value < 0)
                                             {
                                                 value += arrayCols;
                                             }
                                         });
            }

            auto indices = unique(inIndices);

            uint32 indicesSize = 0;
            std::for_each(indices.begin(),
                          indices.end(),
                          [arrayCols, &indicesSize](const auto& value)
                          {
                              if constexpr (std::is_signed_v<decltype(value)>)
                              {
                                  if (value >= 0 && value < arrayCols)
                                  {
                                      ++indicesSize;
                                  }
                              }
                              else
                              {
                                  if (value < arrayCols)
                                  {
                                      ++indicesSize;
                                  }
                              }
                          });

            const auto     arrayRows = static_cast<int32>(inArray.numRows());
            NdArray<dtype> returnArray(arrayRows, arrayCols - indicesSize);

            uint32 colCounter = 0;
            for (int32 col = 0; col < arrayCols; ++col)
            {
                if (std::binary_search(indices.begin(), indices.end(), col))
                {
                    continue;
                }

                for (int32 row = 0; row < arrayRows; ++row)
                {
                    returnArray(row, colCounter) = inArray(row, col);
                }

                ++colCounter;
            }

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Return a new array with sub-arrays along an axis deleted.
    ///
    /// @param inArray
    /// @param inIndices
    /// @param inAxis (Optional, default NONE) if NONE the indices will be applied to the flattened array
    /// @return NdArray
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype> deleteIndices(const NdArray<dtype>& inArray, const Indices& inIndices, Axis inAxis = Axis::NONE)
    {
        switch (inAxis)
        {
            case Axis::NONE:
            {
                return detail::deleteFlatIndices(inArray, inIndices);
            }
            case Axis::ROW:
            {
                return detail::deleteRowIndices(inArray, inIndices);
            }
            case Axis::COL:
            {
                return detail::deleteColumnIndices(inArray, inIndices);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Return a new array with sub-arrays along an axis deleted.
    ///
    /// @param inArray
    /// @param inIndicesSlice
    /// @param inAxis (Optional, default NONE) if none the indices will be applied to the flattened array
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> deleteIndices(const NdArray<dtype>& inArray, Slice inIndicesSlice, Axis inAxis = Axis::NONE)
    {
        switch (inAxis)
        {
            case Axis::NONE:
            {
                inIndicesSlice.makePositiveAndValidate(inArray.size());
                break;
            }
            case Axis::ROW:
            {
                inIndicesSlice.makePositiveAndValidate(inArray.numRows());
                break;
            }
            case Axis::COL:
            {
                inIndicesSlice.makePositiveAndValidate(inArray.numCols());
                break;
            }
        }

        std::vector<int32> indices;
        for (auto i = inIndicesSlice.start; i < inIndicesSlice.stop; i += inIndicesSlice.step)
        {
            indices.push_back(i);
        }

        return deleteIndices(inArray, NdArray<int32>(indices.data(), indices.size(), PointerPolicy::SHELL), inAxis);
    }

    // Method Description:
    /// Return a new array with sub-arrays along an axis deleted.
    ///
    /// @param inArray
    /// @param inIndex
    /// @param inAxis (Optional, default NONE) if none the indices will be applied to the flattened array
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> deleteIndices(const NdArray<dtype>& inArray, int32 inIndex, Axis inAxis = Axis::NONE)
    {
        NdArray<int32> inIndices = { inIndex };
        return deleteIndices(inArray, inIndices, inAxis);
    }
} // namespace nc

/*** End of inlined file: deleteIndices.hpp ***/


/*** Start of inlined file: diag.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: diagonal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return specified diagonals.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.diagonal.html
    ///
    /// @param inArray
    /// @param inOffset (Defaults to 0)
    /// @param inAxis (Optional, default ROW) axis the offset is applied to
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> diagonal(const NdArray<dtype>& inArray, int32 inOffset = 0, Axis inAxis = Axis::ROW)
    {
        return inArray.diagonal(inOffset, inAxis);
    }
} // namespace nc

/*** End of inlined file: diagonal.hpp ***/

namespace nc
{

    // Method Description:
    /// Extract a diagonal or construct a diagonal array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.diag.html
    ///
    /// @param inArray
    /// @param k Diagonal in question. The default is 0.
    /// Use k>0 for diagonals above the main diagonal, and k<0
    /// for diagonals below the main diagonal.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> diag(const NdArray<dtype>& inArray, int32 k = 0)
    {
        if (inArray.isflat())
        {
            return diagflat(inArray, k);
        }

        return diagonal(inArray, k, Axis::ROW);
    }
} // namespace nc

/*** End of inlined file: diag.hpp ***/


/*** Start of inlined file: diff.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Calculate the n-th discrete difference along given axis.
    /// Unsigned dtypes will give you weird results...obviously.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.diff.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> diff(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape = inArray.shape();

        switch (inAxis)
        {
            case Axis::NONE:
            {
                if (inArray.size() < 2)
                {
                    return NdArray<dtype>(0);
                }

                NdArray<dtype> returnArray(1, inArray.size() - 1);
                stl_algorithms::transform(inArray.cbegin(),
                                          inArray.cend() - 1,
                                          inArray.cbegin() + 1,
                                          returnArray.begin(),
                                          [](dtype inValue1, dtype inValue2) noexcept -> dtype
                                          { return inValue2 - inValue1; });

                return returnArray;
            }
            case Axis::COL:
            {
                if (inShape.cols < 2)
                {
                    return NdArray<dtype>(0);
                }

                NdArray<dtype> returnArray(inShape.rows, inShape.cols - 1);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    stl_algorithms::transform(inArray.cbegin(row),
                                              inArray.cend(row) - 1,
                                              inArray.cbegin(row) + 1,
                                              returnArray.begin(row),
                                              [](dtype inValue1, dtype inValue2) noexcept -> dtype
                                              { return inValue2 - inValue1; });
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return diff(inArray.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: diff.hpp ***/


/*** Start of inlined file: digitize.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cstdint>
#include <iterator>

namespace nc
{

    // Method Description:
    /// Return the indices of the bins to which each value in input array belongs.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.digitize.html
    ///
    /// @param x: Input array to be binned.
    /// @param bins: Array of bins.
    ///
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    NdArray<uint32> digitize(const NdArray<dtype1>& x, const NdArray<dtype2>& bins)
    {
        const auto uniqueBins = unique(bins);
        auto       result     = NdArray<uint32>(1, x.size());
        result.fill(0);

        typename decltype(result)::size_type idx{ 0 };
        std::for_each(x.begin(),
                      x.end(),
                      [&uniqueBins, &result, &idx](const auto value)
                      {
                          const auto upperBin = std::upper_bound(uniqueBins.begin(), uniqueBins.end(), value);
                          result[idx++]       = static_cast<uint32>(std::distance(uniqueBins.begin(), upperBin));
                      });

        return result;
    }
} // namespace nc

/*** End of inlined file: digitize.hpp ***/


/*** Start of inlined file: divide.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> divide(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 / inArray2;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> divide(const NdArray<dtype>& inArray, dtype value)
    {
        return inArray / value;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> divide(dtype value, const NdArray<dtype>& inArray)
    {
        return value / inArray;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        return inArray1 / inArray2;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 / inArray2;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(const NdArray<dtype>& inArray, const std::complex<dtype>& value)
    {
        return inArray / value;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(const std::complex<dtype>& value, const NdArray<dtype>& inArray)
    {
        return value / inArray;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(const NdArray<std::complex<dtype>>& inArray, dtype value)
    {
        return inArray / value;
    }

    // Method Description:
    /// divide arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.divide.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> divide(dtype value, const NdArray<std::complex<dtype>>& inArray)
    {
        return value / inArray;
    }
} // namespace nc

/*** End of inlined file: divide.hpp ***/


/*** Start of inlined file: dump.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Dump a binary file of the array to the specified file.
    /// The array can be read back with or NC::load.
    ///
    /// @param inArray
    /// @param inFilename
    ///
    template<typename dtype>
    void dump(const NdArray<dtype>& inArray, const std::string& inFilename)
    {
        inArray.dump(inFilename);
    }
} // namespace nc

/*** End of inlined file: dump.hpp ***/


/*** Start of inlined file: empty.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, without initializing entries.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.empty.html
    ///
    /// @param inNumRows
    /// @param inNumCols
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> empty(uint32 inNumRows, uint32 inNumCols)
    {
        return NdArray<dtype>(inNumRows, inNumCols);
    }

    // Method Description:
    /// Return a new array of given shape and type, without initializing entries.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.empty.html
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> empty(const Shape& inShape)
    {
        return NdArray<dtype>(inShape);
    }
} // namespace nc

/*** End of inlined file: empty.hpp ***/


/*** Start of inlined file: endianess.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the endianess of the array values.
    ///
    /// @param inArray
    /// @return Endian
    ///
    template<typename dtype>
    Endian endianess(const NdArray<dtype>& inArray) noexcept
    {
        return inArray.endianess();
    }
} // namespace nc

/*** End of inlined file: endianess.hpp ***/


/*** Start of inlined file: equal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return (x1 == x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.equal.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> equal(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 == inArray2;
    }
} // namespace nc

/*** End of inlined file: equal.hpp ***/


/*** Start of inlined file: exp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Calculate the exponential of the input value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.exp.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto exp(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::exp(inValue);
    }

    // Method Description:
    /// Calculate the exponential of all elements in the input array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.exp.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto exp(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(exp(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return exp(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: exp.hpp ***/


/*** Start of inlined file: exp2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Calculate 2**p for all p in the input value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.exp2.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto exp2(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::exp2(inValue);
    }

    // Method Description:
    /// Calculate 2**p for all p in the input array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.exp2.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto exp2(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(exp2(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return exp2(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: exp2.hpp ***/


/*** Start of inlined file: expm1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Calculate exp(x) - 1 for the input value.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.expm1.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto expm1(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::exp(inValue) - dtype{ 1 };
    }

    // Method Description:
    /// Calculate exp(x) - 1 for all elements in the array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.expm1.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto expm1(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(expm1(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return expm1(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: expm1.hpp ***/


/*** Start of inlined file: extract.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <vector>

namespace nc
{

    // Method Description:
    /// Return the elements of an array that satisfy some condition.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.extract.html
    ///
    /// @param condition: An array whose nonzero or True entries indicate the elements of arr to extract.
    /// @param arr: Input array of the same size as condition
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> extract(const NdArray<bool>& condition, const NdArray<dtype>& arr)
    {
        if (condition.size() != arr.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Input arguments 'condition' and 'arr' must have the same size.");
        }

        std::vector<dtype> values;
        for (decltype(arr.size()) i = 0; i < arr.size(); ++i)
        {
            if (condition[i])
            {
                values.push_back(arr[i]);
            }
        }

        return NdArray<dtype>(values.begin(), values.end());
    }
} // namespace nc

/*** End of inlined file: extract.hpp ***/


/*** Start of inlined file: eye.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a 2-D array with ones on the diagonal and zeros elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.eye.html
    ///
    /// @param inN: number of rows (N)
    /// @param inM: number of columns (M)
    /// @param inK: Index of the diagonal: 0 (the default) refers to the main diagonal,
    /// a positive value refers to an upper diagonal, and a negative value to a lower diagonal.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> eye(uint32 inN, uint32 inM, int32 inK = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<dtype> returnArray(inN, inM);
        returnArray.zeros();

        if (inK < 0)
        {
            uint32 col = 0;
            for (uint32 row = inK; row < inN; ++row)
            {
                if (col >= inM)
                {
                    break;
                }

                returnArray(row, col++) = dtype{ 1 };
            }
        }
        else
        {
            uint32 row = 0;
            for (uint32 col = inK; col < inM; ++col)
            {
                if (row >= inN)
                {
                    break;
                }

                returnArray(row++, col) = dtype{ 1 };
            }
        }

        return returnArray;
    }

    // Method Description:
    /// Return a 2-D array with ones on the diagonal and zeros elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.eye.html
    ///
    /// @param inN: number of rows and columns (N)
    /// @param inK: Index of the diagonal: 0 (the default) refers to the main diagonal,
    /// a positive value refers to an upper diagonal, and a negative value to a lower diagonal.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> eye(uint32 inN, int32 inK = 0)
    {
        return eye<dtype>(inN, inN, inK);
    }

    // Method Description:
    /// Return a 2-D array with ones on the diagonal and zeros elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.eye.html
    ///
    /// @param inShape
    /// @param inK: Index of the diagonal: 0 (the default) refers to the main diagonal,
    /// a positive value refers to an upper diagonal, and a negative value to a lower diagonal.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> eye(const Shape& inShape, int32 inK = 0)
    {
        return eye<dtype>(inShape.rows, inShape.cols, inK);
    }
} // namespace nc

/*** End of inlined file: eye.hpp ***/


/*** Start of inlined file: fillDiagnol.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Fill the main diagonal of the given array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fill_diagonal.html
    ///
    /// @param inArray
    /// @param inValue
    ///
    template<typename dtype>
    void fillDiagonal(NdArray<dtype>& inArray, dtype inValue) noexcept
    {
        const auto inShape = inArray.shape();
        for (uint32 row = 0; row < inShape.rows; ++row)
        {
            if (row < inShape.cols)
            {
                inArray(row, row) = inValue;
            }
        }
    }
} // namespace nc

/*** End of inlined file: fillDiagnol.hpp ***/


/*** Start of inlined file: find.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <limits>

namespace nc
{

    // Method Description:
    /// Find flat indices of nonzero elements.
    ///
    /// @param mask: the mask to apply to the array
    /// @param n: the first n indices to return (optional, default all)
    ///
    /// @return NdArray
    ///
    inline NdArray<uint32> find(const NdArray<bool>& mask, uint32 n = std::numeric_limits<uint32>::max())
    {
        NdArray<uint32> indices = mask.flatnonzero();

        if (indices.size() <= n)
        {
            return indices;
        }

        return indices[Slice(0, n)];
    }
} // namespace nc

/*** End of inlined file: find.hpp ***/


/*** Start of inlined file: fix.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Round to nearest integer towards zero.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fix.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    dtype fix(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return inValue > 0 ? std::floor(inValue) : std::ceil(inValue);
    }

    // Method Description:
    /// Round to nearest integer towards zero.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fix.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fix(const NdArray<dtype>& inArray)
    {
        NdArray<double> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> double { return fix(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: fix.hpp ***/


/*** Start of inlined file: flatnonzero.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return indices that are non-zero in the flattened version of a.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.flatnonzero.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> flatnonzero(const NdArray<dtype>& inArray)
    {
        return inArray.flatnonzero();
    }
} // namespace nc

/*** End of inlined file: flatnonzero.hpp ***/


/*** Start of inlined file: flatten.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a copy of the array collapsed into one dimension.
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> flatten(const NdArray<dtype>& inArray)
    {
        return inArray.flatten();
    }
} // namespace nc

/*** End of inlined file: flatten.hpp ***/


/*** Start of inlined file: floor.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the floor of the input.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.floor.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    dtype floor(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::floor(inValue);
    }

    // Method Description:
    /// Return the floor of the input, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.floor.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> floor(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return floor(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: floor.hpp ***/


/*** Start of inlined file: floor_divide.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the largest integer smaller or equal to the division of the inputs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.floor_divide.html
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return value
    ///
    template<typename dtype>
    dtype floor_divide(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::floor(inValue1 / inValue2);
    }

    // Method Description:
    /// Return the largest integer smaller or equal to the division of the inputs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.floor_divide.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> floor_divide(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return floor(inArray1 / inArray2);
    }
} // namespace nc

/*** End of inlined file: floor_divide.hpp ***/


/*** Start of inlined file: fmax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// maximum of inputs.
    ///
    /// Compare two value and returns a value containing the
    /// maxima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmax.html
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return value
    ///
    template<typename dtype>
    dtype fmax(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::max(inValue1,
                        inValue2,
                        [](const dtype value1, const dtype value2) noexcept -> bool { return value1 < value2; });
    }

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise maxima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmax.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmax(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return broadcast::broadcaster<dtype>(inArray1,
                                             inArray2,
                                             [](dtype inValue1, dtype inValue2) noexcept -> dtype
                                             { return fmax(inValue1, inValue2); });
    }

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise maxima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmax.html
    ///
    /// @param inArray
    /// @param inScalar
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmax(const NdArray<dtype>& inArray, const dtype& inScalar)
    {
        const NdArray<dtype> inArray2 = { inScalar };
        return fmax(inArray, inArray2);
    }

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise maxima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmax.html
    ///
    /// @param inScalar
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmax(const dtype& inScalar, const NdArray<dtype>& inArray)
    {
        return fmax(inArray, inScalar);
    }
} // namespace nc

/*** End of inlined file: fmax.hpp ***/


/*** Start of inlined file: fmin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// minimum of inputs.
    ///
    /// Compare two value and returns a value containing the
    /// minima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmin.html
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return value
    ///
    template<typename dtype>
    dtype fmin(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::min(inValue1,
                        inValue2,
                        [](const dtype value1, const dtype value2) noexcept -> bool { return value1 < value2; });
    }

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise minima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmin.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmin(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return broadcast::broadcaster<dtype>(inArray1,
                                             inArray2,
                                             [](dtype inValue1, dtype inValue2) noexcept -> dtype
                                             { return fmin(inValue1, inValue2); });
    }

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise minima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmin.html
    ///
    /// @param inArray
    /// @param inScalar
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmin(const NdArray<dtype>& inArray, const dtype& inScalar)
    {
        const NdArray<dtype> inArray2 = { inScalar };
        return fmin(inArray, inArray2);
    }

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// Compare two arrays and returns a new array containing the
    /// element - wise minima
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmin.html
    ///
    /// @param inScalar
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmin(const dtype& inScalar, const NdArray<dtype>& inArray)
    {
        return fmin(inArray, inScalar);
    }
} // namespace nc

/*** End of inlined file: fmin.hpp ***/


/*** Start of inlined file: fmod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Return the remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmod.html
    ///
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return value
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype>, int> = 0>
    dtype fmod(dtype inValue1, dtype inValue2) noexcept
    {
        return inValue1 % inValue2;
    }

    // Method Description:
    /// Return the remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmod.html
    ///
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return value
    ///
    template<typename dtype, std::enable_if_t<std::is_floating_point_v<dtype>, int> = 0>
    dtype fmod(dtype inValue1, dtype inValue2) noexcept
    {
        return std::fmod(inValue1, inValue2);
    }

    // Method Description:
    /// Return the element-wise remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fmod.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fmod(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 % inArray2;
    }
} // namespace nc

/*** End of inlined file: fmod.hpp ***/


/*** Start of inlined file: frombuffer.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Interpret a buffer as a 1-dimensional array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.frombuffer.html
    ///
    /// @param inBufferPtr
    /// @param inNumBytes
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> frombuffer(const char* inBufferPtr, uint32 inNumBytes)
    {
        if (inNumBytes % sizeof(dtype) != 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("inNumBytes % sizeof(dtype) != 0");
        }

        const auto numElements = static_cast<uint32>(inNumBytes / sizeof(dtype));
        return NdArray<dtype>(reinterpret_cast<const dtype*>(inBufferPtr), numElements);
    }
} // namespace nc

/*** End of inlined file: frombuffer.hpp ***/


/*** Start of inlined file: fromfile.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <filesystem>
#include <fstream>
#include <memory>
#include <sstream>
#include <string>


/*** Start of inlined file: fromstring.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <sstream>
#include <string_view>

namespace nc
{

    // Method Description:
    /// Construct an array from data in a string
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fromstring.html
    ///
    /// @param inStr
    /// @param inSep: Delimiter separator between values in the string
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fromstring(const std::string& inStr, const char inSep = ' ')
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::istringstream inputStream(inStr);
        auto               values = std::vector<dtype>{};
        dtype              value{};
        for (std::string segment; std::getline(inputStream, segment, inSep);)
        {
            if (!inputStream.fail())
            {
                std::istringstream segmentStream(segment);
                while (segmentStream >> value)
                {
                    if (!inputStream.fail())
                    {
                        values.push_back(value);
                    }
                }
            }
        }

        return NdArray<dtype>(values);
    }
} // namespace nc

/*** End of inlined file: fromstring.hpp ***/

namespace nc
{

    // Method Description:
    /// Construct an array from data in a binary file.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fromfile.html
    ///
    /// @param inFilename
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fromfile(const std::string& inFilename)
    {
        if (!std::filesystem::exists(inFilename))
        {
            THROW_INVALID_ARGUMENT_ERROR("input filename does not exist.\n\t" + inFilename);
        }

        // read in as binary file
        std::ifstream file(inFilename.c_str(), std::ios::in | std::ios::binary);
        if (!file.is_open())
        {
            THROW_INVALID_ARGUMENT_ERROR("unable to open file\n\t" + inFilename);
        }

        file.seekg(0, std::ifstream::end);
        const uint32 fileSize = static_cast<uint32>(file.tellg());
        file.seekg(0, std::ifstream::beg);

        std::vector<char> fileBuffer;
        fileBuffer.reserve(fileSize);
        file.read(fileBuffer.data(), fileSize);

        if (file.bad() || file.fail())
        {
            THROW_INVALID_ARGUMENT_ERROR("error occured while reading the file");
        }

        file.close();

        NdArray<dtype> returnArray(reinterpret_cast<dtype*>(fileBuffer.data()), fileSize / sizeof(dtype));

        return returnArray;
    }

    // Method Description:
    /// Construct an array from data in a text file.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fromfile.html
    ///
    /// @param inFilename
    /// @param inSep: Delimiter separator between values in the file
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fromfile(const std::string& inFilename, const char inSep)
    {
        std::ifstream file(inFilename.c_str());
        if (!file.is_open())
        {
            THROW_INVALID_ARGUMENT_ERROR("unable to open file\n\t" + inFilename);
        }

        std::stringstream buffer;
        buffer << file.rdbuf();
        file.close();

        return fromstring<dtype>(buffer.str(), inSep);
    }
} // namespace nc

/*** End of inlined file: fromfile.hpp ***/


/*** Start of inlined file: fromfunction.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <functional>
#include <numeric>
#include <vector>

namespace nc
{

    // Method Description:
    /// Construct an array by executing a function over each coordinate.
    /// The resulting array therefore has a value fn(x) at coordinate(x).
    ///
    ///  NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html
    ///
    ///  @param func: callable that accepts an integer coordinate and returns type T
    ///  @param size: the size of the 1d array to create
    ///
    ///  @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fromfunction(const std::function<dtype(typename NdArray<dtype>::size_type)> func,
                                typename NdArray<dtype>::size_type                             size)
    {
        NdArray<dtype> result(1, size);
        const auto     indices = [size]
        {
            std::vector<typename NdArray<dtype>::size_type> temp(size);
            std::iota(temp.begin(), temp.end(), 0);
            return temp;
        }();

        stl_algorithms::transform(indices.begin(),
                                  indices.end(),
                                  result.begin(),
                                  [&func](const auto idx) { return func(idx); });

        return result;
    }

    // Method Description:
    /// Construct an array by executing a function over each coordinate.
    /// The resulting array therefore has a value fn(x, y) at coordinate(x, y).
    ///
    ///  NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html
    ///
    ///  @param func: callable that accepts an integer coordinate and returns type T
    ///  @param shape: the shape of the array to create
    ///
    ///  @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> fromfunction(
        const std::function<dtype(typename NdArray<dtype>::size_type, typename NdArray<dtype>::size_type)> func,
        Shape                                                                                              shape)
    {
        NdArray<dtype> result(shape);
        const auto     rows = [&shape]
        {
            std::vector<typename NdArray<dtype>::size_type> temp(shape.rows);
            std::iota(temp.begin(), temp.end(), 0);
            return temp;
        }();
        const auto cols = [&shape]
        {
            std::vector<typename NdArray<dtype>::size_type> temp(shape.cols);
            std::iota(temp.begin(), temp.end(), 0);
            return temp;
        }();

        stl_algorithms::for_each(rows.begin(),
                                 rows.end(),
                                 [&cols, &result, &func](const auto row)
                                 {
                                     stl_algorithms::transform(cols.begin(),
                                                               cols.end(),
                                                               result.begin(row),
                                                               [&func, row](const auto col) { return func(row, col); });
                                 });

        return result;
    }
} // namespace nc

/*** End of inlined file: fromfunction.hpp ***/


/*** Start of inlined file: fromiter.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <iterator>
#include <vector>

namespace nc
{

    // Method Description:
    /// Create a new 1-dimensional array from an iterable object.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.fromiter.html
    ///
    /// @param inBegin
    /// @param inEnd
    /// @return NdArray
    ///
    template<typename dtype, typename Iter>
    NdArray<dtype> fromiter(Iter inBegin, Iter inEnd)
    {
        return NdArray<dtype>(inBegin, inEnd);
    }
} // namespace nc

/*** End of inlined file: fromiter.hpp ***/


/*** Start of inlined file: full_like.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a full array with the same shape and type as a given array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.full_like.html
    ///
    /// @param inArray
    /// @param inFillValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> full_like(const NdArray<dtype>& inArray, dtype inFillValue)
    {
        return full(inArray.shape(), inFillValue);
    }
} // namespace nc

/*** End of inlined file: full_like.hpp ***/


/*** Start of inlined file: gcd.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <numeric>

#if defined(__cpp_lib_gcd_lcm) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef NUMCPP_NO_USE_BOOST
#include "boost/integer/common_factor_rt.hpp"
#endif

namespace nc
{

    // Method Description:
    /// Returns the greatest common divisor of |x1| and |x2|.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.gcd.html
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return dtype
    ///
    template<typename dtype>
    dtype gcd(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_INTEGER(dtype);

#ifdef __cpp_lib_gcd_lcm
        return std::gcd(inValue1, inValue2);
#else
        return boost::integer::gcd(inValue1, inValue2);
#endif // #ifdef __cpp_lib_gcd_lcm
    }

#ifndef NUMCPP_NO_USE_BOOST

    // Method Description:
    /// Returns the greatest common divisor of the values in the
    /// input array.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.gcd.html
    ///
    /// @param inArray
    /// @return NdArray<double>
    ///
    template<typename dtype>
    dtype gcd(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_INTEGER(dtype);
        return boost::integer::gcd_range(inArray.cbegin(), inArray.cend()).first;
    }
#endif // #ifndef NUMCPP_NO_USE_BOOST
} // namespace nc

#endif // defined(__cpp_lib_gcd_lcm) || !defined(NUMCPP_NO_USE_BOOST)
/*** End of inlined file: gcd.hpp ***/


/*** Start of inlined file: geomspace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: logb.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Logarithm of an arbitrary base
    ///
    /// @param inValue
    /// @param inBase: the logorithm base
    ///
    /// @return value
    ///
    template<typename dtype>
    auto logb(dtype inValue, dtype inBase) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::log(inValue) / std::log(inBase);
    }

    // Method Description:
    /// Logarithm of an arbitrary base
    ///
    /// @param inArray
    /// @param inBase: the logorithm base
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto logb(const NdArray<dtype>& inArray, dtype inBase)
    {
        NdArray<decltype(logb(dtype{ 0 }, dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inBase](dtype inValue) noexcept -> auto { return logb(inValue, inBase); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: logb.hpp ***/


/*** Start of inlined file: logspace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once


/*** Start of inlined file: powerf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Raises the input value to a floating point power
///
#pragma once

#include <cmath>
#include <complex>

namespace nc::utils
{

    /// Raises the input value to a floating point power
    ///
    /// @param inValue
    /// @param inPower
    ///
    /// @return inValue raised to inPower
    ///
    template<typename dtype1, typename dtype2>
    auto powerf(dtype1 inValue, const dtype2 inPower) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype1);

        return std::pow(inValue, inPower);
    }
} // namespace nc::utils

/*** End of inlined file: powerf.hpp ***/

namespace nc
{

    // Method Description:
    /// Return numbers spaced evenly on a log scale.
    ///
    /// This is similar to logspace, but with endpoints specified directly.
    /// Each output sample is a constant multiple of the previous.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.logspace.html
    ///
    /// @param start: the starting value of a sequence
    /// @param stop: The final value of the sequence, unless endpoint is False.
    /// In that case, num + 1 values are spaced over the interval
    /// in log-space, of which all but the last (a sequence of length num) are returned.
    /// @param num: Number of samples to generate. Default 50.
    /// @param endPoint: If true, stop is the last sample. Otherwise,it is not included. Default is true.
    /// @param base: The base of the log space. The step size between the elements in ln(samples) / ln(base)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double>
        logspace(dtype start, dtype stop, uint32 num = 50, EndPoint endPoint = EndPoint::YES, double base = 10.)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        auto spacedValues = linspace(static_cast<double>(start), static_cast<double>(stop), num, endPoint);
        stl_algorithms::for_each(spacedValues.begin(),
                                 spacedValues.end(),
                                 [base](auto& value) -> void { value = utils::powerf(base, value); });

        return spacedValues;
    }
} // namespace nc

/*** End of inlined file: logspace.hpp ***/


/*** Start of inlined file: nth_root.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the nth-root of an value.
    ///
    /// @param inValue
    /// @param inRoot
    /// @return value
    ///
    template<typename dtype1, typename dtype2>
    double nth_root(dtype1 inValue, dtype2 inRoot) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return utils::powerf(static_cast<double>(inValue), 1. / static_cast<double>(inRoot));
    }

    // Method Description:
    /// Return the nth-root of an array.
    ///
    /// @param inArray
    /// @param inRoot
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    NdArray<double> nth_root(const NdArray<dtype1>& inArray, dtype2 inRoot)
    {
        NdArray<double> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inRoot](dtype1 inValue) noexcept -> double { return nth_root(inValue, inRoot); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: nth_root.hpp ***/

namespace nc
{

    // Method Description:
    /// Return numbers spaced evenly on a log scale (a geometric progression).
    ///
    /// This is similar to logspace, but with endpoints specified directly.
    /// Each output sample is a constant multiple of the previous.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.geomspace.html
    ///
    /// @param start: the starting value of a sequence
    /// @param stop: The final value of the sequence, unless endpoint is False.
    /// In that case, num + 1 values are spaced over the interval
    /// in log-space, of which all but the last (a sequence of length num) are returned.
    /// @param num: Number of samples to generate. Default 50.
    /// @param endPoint: If true, stop is the last sample. Otherwide,it is not included. Default is true.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> geomspace(dtype start, dtype stop, uint32 num = 50, EndPoint endPoint = EndPoint::YES)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (utils::essentiallyEqual(start, dtype{ 0 }))
        {
            THROW_INVALID_ARGUMENT_ERROR("Geometric sequence cannot include zero");
        }

        if (num == 1)
        {
            return { static_cast<double>(start) };
        }
        else if (num == 2 && endPoint == EndPoint::YES)
        {
            return { static_cast<double>(start), static_cast<double>(stop) };
        }

        const auto base     = nth_root(stop / start, num - 1);
        const auto logStart = logb(start, base);
        const auto logStop  = logb(stop, base);
        return logspace(logStart, logStop, num, endPoint, base);
    }
} // namespace nc

/*** End of inlined file: geomspace.hpp ***/


/*** Start of inlined file: gradient.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// Return the gradient of the array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.gradient.html
    ///
    ///
    /// @param inArray
    /// @param inAxis (default ROW)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> gradient(const NdArray<dtype>& inArray, Axis inAxis = Axis::ROW)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::ROW:
            {
                const auto inShape = inArray.shape();
                if (inShape.rows < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 row.");
                }

                // first do the first and last rows
                auto returnArray = NdArray<double>(inShape);
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    returnArray(0, col) = static_cast<double>(inArray(1, col)) - static_cast<double>(inArray(0, col));
                    returnArray(-1, col) =
                        static_cast<double>(inArray(-1, col)) - static_cast<double>(inArray(-2, col));
                }

                // then rip through the rest of the array
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    for (uint32 row = 1; row < inShape.rows - 1; ++row)
                    {
                        returnArray(row, col) =
                            (static_cast<double>(inArray(row + 1, col)) - static_cast<double>(inArray(row - 1, col))) /
                            2.;
                    }
                }

                return returnArray;
            }
            case Axis::COL:
            {
                const auto inShape = inArray.shape();
                if (inShape.cols < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 columns.");
                }

                // first do the first and last columns
                auto returnArray = NdArray<double>(inShape);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    returnArray(row, 0) = static_cast<double>(inArray(row, 1)) - static_cast<double>(inArray(row, 0));
                    returnArray(row, -1) =
                        static_cast<double>(inArray(row, -1)) - static_cast<double>(inArray(row, -2));
                }

                // then rip through the rest of the array
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    for (uint32 col = 1; col < inShape.cols - 1; ++col)
                    {
                        returnArray(row, col) =
                            (static_cast<double>(inArray(row, col + 1)) - static_cast<double>(inArray(row, col - 1))) /
                            2.;
                    }
                }

                return returnArray;
            }
            default:
            {
                // will return the gradient of the flattened array
                if (inArray.size() < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 element.");
                }

                auto returnArray = NdArray<double>(1, inArray.size());
                returnArray[0]   = static_cast<double>(inArray[1]) - static_cast<double>(inArray[0]);
                returnArray[-1]  = static_cast<double>(inArray[-1]) - static_cast<double>(inArray[-2]);

                stl_algorithms::transform(inArray.cbegin() + 2,
                                          inArray.cend(),
                                          inArray.cbegin(),
                                          returnArray.begin() + 1,
                                          [](dtype value1, dtype value2) -> double
                                          { return (static_cast<double>(value1) - static_cast<double>(value2)) / 2.; });

                return returnArray;
            }
        }
    }

    // Method Description:
    /// Return the gradient of the array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.gradient.html
    ///
    ///
    /// @param inArray
    /// @param inAxis (default ROW)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> gradient(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::ROW)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::ROW:
            {
                const auto inShape = inArray.shape();
                if (inShape.rows < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 row.");
                }

                // first do the first and last rows
                auto returnArray = NdArray<std::complex<double>>(inShape);
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    returnArray(0, col) = complex_cast<double>(inArray(1, col)) - complex_cast<double>(inArray(0, col));
                    returnArray(-1, col) =
                        complex_cast<double>(inArray(-1, col)) - complex_cast<double>(inArray(-2, col));
                }

                // then rip through the rest of the array
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    for (uint32 row = 1; row < inShape.rows - 1; ++row)
                    {
                        returnArray(row, col) = (complex_cast<double>(inArray(row + 1, col)) -
                                                 complex_cast<double>(inArray(row - 1, col))) /
                                                2.;
                    }
                }

                return returnArray;
            }
            case Axis::COL:
            {
                const auto inShape = inArray.shape();
                if (inShape.cols < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 columns.");
                }

                // first do the first and last columns
                auto returnArray = NdArray<std::complex<double>>(inShape);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    returnArray(row, 0) = complex_cast<double>(inArray(row, 1)) - complex_cast<double>(inArray(row, 0));
                    returnArray(row, -1) =
                        complex_cast<double>(inArray(row, -1)) - complex_cast<double>(inArray(row, -2));
                }

                // then rip through the rest of the array
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    for (uint32 col = 1; col < inShape.cols - 1; ++col)
                    {
                        returnArray(row, col) = (complex_cast<double>(inArray(row, col + 1)) -
                                                 complex_cast<double>(inArray(row, col - 1))) /
                                                2.;
                    }
                }

                return returnArray;
            }
            default:
            {
                // will return the gradient of the flattened array
                if (inArray.size() < 2)
                {
                    THROW_INVALID_ARGUMENT_ERROR("input array must have more than 1 element.");
                }

                auto returnArray = NdArray<std::complex<double>>(1, inArray.size());
                returnArray[0]   = complex_cast<double>(inArray[1]) - complex_cast<double>(inArray[0]);
                returnArray[-1]  = complex_cast<double>(inArray[-1]) - complex_cast<double>(inArray[-2]);

                stl_algorithms::transform(
                    inArray.cbegin() + 2,
                    inArray.cend(),
                    inArray.cbegin(),
                    returnArray.begin() + 1,
                    [](const std::complex<dtype>& value1, const std::complex<dtype>& value2) -> std::complex<double>
                    { return (complex_cast<double>(value1) - complex_cast<double>(value2)) / 2.; });

                return returnArray;
            }
        }
    }
} // namespace nc

/*** End of inlined file: gradient.hpp ***/


/*** Start of inlined file: greater.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the truth value of (x1 > x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.greater.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> greater(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 > inArray2;
    }
} // namespace nc

/*** End of inlined file: greater.hpp ***/


/*** Start of inlined file: greater_equal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the truth value of (x1 >= x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.greater_equal.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> greater_equal(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 >= inArray2;
    }
} // namespace nc

/*** End of inlined file: greater_equal.hpp ***/


/*** Start of inlined file: hamming.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the Hamming window.
    ///
    /// The Hamming window is a taper formed by using a weighted cosine.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.hamming.html
    ///
    /// @param m: Number of points in the output window. If zero or less, an empty array is returned.
    /// @return NdArray
    ///
    inline NdArray<double> hamming(int32 m)
    {
        if (m < 1)
        {
            return {};
        }

        const auto mDouble         = static_cast<double>(m);
        const auto twoPiDivMMinus1 = (2. * constants::pi) / (mDouble - 1.);

        NdArray<double> result(1, m);
        int32           i = 0;
        for (auto n : linspace(0., mDouble - 1., m, EndPoint::YES))
        {
            result[i++] = 0.54 - 0.46 * std::cos(twoPiDivMMinus1 * n);
        }

        return result;
    }
} // namespace nc

/*** End of inlined file: hamming.hpp ***/


/*** Start of inlined file: hammingEncode.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Hamming EDAC encoding https://en.wikipedia.org/wiki/Hamming_code
///

#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <bitset>
#include <cmath>
#include <cstdlib>
#include <numeric>
#include <stdexcept>
#include <type_traits>
#include <vector>

#include "boost/dynamic_bitset.hpp"

namespace nc::edac
{
    namespace detail
    {

        // Method Description:
        /// @brief Tests if value is a power of two
        ///
        /// @param n integer value
        /// @return bool true if value is a power of two, else false
        ///
        template<typename IntType, std::enable_if_t<std::is_integral_v<IntType>, int> = 0>
        constexpr bool isPowerOfTwo(IntType n) noexcept
        {
            // Returns true if the given non-negative integer n is a power of two.
            return n != 0 && (n & (n - 1)) == 0;
        }

        // Method Description:
        /// Calculates the next power of two after n
        /// >>> _next_power_of_two(768)
        /// 1024
        /// >>> _next_power_of_two(4)
        /// 8
        ///
        /// @param n integer value
        /// @return next power of two
        /// @exception std::invalid_argument if input value is less than zero
        ////
        template<typename IntType, std::enable_if_t<std::is_integral_v<IntType>, int> = 0>
        std::size_t nextPowerOfTwo(IntType n)
        {
            if (n < 0)
            {
                throw std::invalid_argument("Input value must be greater than or equal to zero.");
            }

            if (isPowerOfTwo(n))
            {
                return static_cast<std::size_t>(n) << 1;
            }

            return static_cast<std::size_t>(std::pow(2, std::ceil(std::log2(n))));
        }

        // Method Description:
        /// Calculates the first n powers of two
        ///
        /// @param n integer value
        /// @return first n powers of two
        /// @exception std::bad_alloc if unable to allocate for return vector
        ///
        template<typename IntType, std::enable_if_t<std::is_integral_v<IntType>, int> = 0>
        std::vector<std::size_t> powersOfTwo(IntType n)
        {
            auto i      = std::size_t{ 0 };
            auto power  = std::size_t{ 1 };
            auto powers = std::vector<std::size_t>();
            powers.reserve(n);

            while (i < static_cast<std::size_t>(n))
            {
                powers.push_back(power);
                power <<= 1;
                ++i;
            }

            return powers;
        }

        // Method Description:
        /// Calculates the number of needed Hamming SECDED parity bits to encode the data
        ///
        /// @param numDataBits the number of data bits to encode
        /// @return number of Hamming SECDED parity bits
        /// @exception std::invalid_argument if input value is less than zero
        /// @exception std::runtime_error if the number of data bits does not represent a valid Hamming SECDED code
        ///
        template<typename IntType, std::enable_if_t<std::is_integral_v<IntType>, int> = 0>
        std::size_t numSecdedParityBitsNeeded(IntType numDataBits)
        {
            const auto n               = nextPowerOfTwo(numDataBits);
            const auto lowerBin        = static_cast<std::size_t>(std::floor(std::log2(n)));
            const auto upperBin        = lowerBin + 1;
            const auto dataBitBoundary = n - lowerBin - 1;
            const auto numParityBits   = numDataBits <= dataBitBoundary ? lowerBin + 1 : upperBin + 1;

            if (!isPowerOfTwo(numParityBits + numDataBits))
            {
                throw std::runtime_error("input number of data bits is not a valid Hamming SECDED code configuration.");
            }

            return numParityBits;
        }

        // Method Description:
        /// Returns the indices of all data bits covered by a specified parity bit in a bitstring
        /// of length numDataBits. The indices are relative to DATA BITSTRING ITSELF, NOT including
        /// parity bits.
        ///
        /// @param numDataBits the number of data bits to encode
        /// @param parityBit the parity bit number
        /// @return number of Hamming SECDED parity bits
        /// @exception std::invalid_argument if parityBit is not a power of two
        /// @exception std::bad_alloc if unable to allocate return vector
        ///
        template<typename IntType1,
                 typename IntType2,
                 std::enable_if_t<std::is_integral_v<IntType1>, int> = 0,
                 std::enable_if_t<std::is_integral_v<IntType2>, int> = 0>
        std::vector<std::size_t> dataBitsCovered(IntType1 numDataBits, IntType2 parityBit)
        {
            if (!isPowerOfTwo(parityBit))
            {
                throw std::invalid_argument("All hamming parity bits are indexed by powers of two.");
            }

            std::size_t dataIndex  = 1; // bit we're currently at in the DATA bitstring
            std::size_t totalIndex = 3; // bit we're currently at in the OVERALL bitstring
            auto        parityBit_ = static_cast<std::size_t>(parityBit);

            auto indices = std::vector<std::size_t>();
            indices.reserve(numDataBits); // worst case

            while (dataIndex <= static_cast<std::size_t>(numDataBits))
            {
                const auto currentBitIsData = !isPowerOfTwo(totalIndex);
                if (currentBitIsData && (totalIndex % (parityBit_ << 1)) >= parityBit_)
                {
                    indices.push_back(dataIndex - 1); // adjust output to be zero indexed
                }

                dataIndex += currentBitIsData ? 1 : 0;
                ++totalIndex;
            }

            return indices;
        }

        // Method Description:
        /// Calculates the overall parity of the data, assumes last bit is the parity bit itself
        ///
        /// @param data the data word
        /// @return overall parity bit value
        ///
        template<std::size_t DataBits>
        constexpr bool calculateParity(const std::bitset<DataBits>& data) noexcept
        {
            bool parity = false;
            for (std::size_t i = 0; i < DataBits - 1; ++i)
            {
                parity ^= data[i];
            }

            return parity;
        }

        // Method Description:
        /// Calculates the overall parity of the data, assumes last bit is the parity bit itself
        ///
        /// @param data the data word
        /// @return overall parity bit value
        ///
        inline bool calculateParity(const boost::dynamic_bitset<>& data) noexcept
        {
            bool parity = false;
            for (std::size_t i = 0; i < data.size() - 1; ++i)
            {
                parity ^= data[i];
            }

            return parity;
        }

        // Method Description:
        /// Calculates the specified Hamming parity bit (1, 2, 4, 8, etc.) for the given data.
        /// Assumes even parity to allow for easier computation of parity using XOR.
        ///
        /// @param data the data word
        /// @param parityBit the parity bit number
        /// @return parity bit value
        /// @exception std::invalid_argument if parityBit is not a power of two
        /// @exception std::bad_alloc if unable to allocate return vector
        ///
        template<std::size_t DataBits, typename IntType, std::enable_if_t<std::is_integral_v<IntType>, int> = 0>
        bool calculateParity(const std::bitset<DataBits>& data, IntType parityBit)
        {
            const auto bitsCovered = dataBitsCovered(DataBits, parityBit);
            return std::accumulate(bitsCovered.begin(),
                                   bitsCovered.end(),
                                   false,
                                   [&data](bool parity, const auto value) noexcept -> bool { return parity ^= value; });
        }

        // Method Description:
        /// Checks that the number of DataBits and EncodedBits are consistent
        ///
        /// @return the number of parity bits
        /// @exception std::runtime_error if DataBits and EncodedBits are not consistent
        /// @exception std::runtime_error if the number of data bits does not represent a valid Hamming SECDED code
        ///
        template<std::size_t DataBits,
                 std::size_t EncodedBits,
                 std::enable_if_t<greaterThan_v<EncodedBits, DataBits>, int> = 0>
        std::size_t checkBitsConsistent()
        {
            const auto numParityBits = detail::numSecdedParityBitsNeeded(DataBits);
            if (numParityBits + DataBits != EncodedBits)
            {
                throw std::runtime_error("DataBits and EncodedBits are not consistent");
            }

            return numParityBits;
        }

        // Method Description:
        /// Returns the Hamming SECDED decoded bits from the endoded bits. Assumes that the
        /// DataBits and EncodedBits have been checks for consistancy already
        ///
        /// @param encodedBits the Hamming SECDED encoded word
        /// @return data bits from the encoded word
        ///
        template<std::size_t DataBits,
                 std::size_t EncodedBits,
                 std::enable_if_t<greaterThan_v<EncodedBits, DataBits>, int> = 0>
        std::bitset<DataBits> extractData(const std::bitset<EncodedBits>& encodedBits) noexcept
        {
            auto dataBits = std::bitset<DataBits>();

            std::size_t dataIndex = 0;
            for (std::size_t encodedIndex = 0; encodedIndex < EncodedBits; ++encodedIndex)
            {
                if (!isPowerOfTwo(encodedIndex + 1))
                {
                    dataBits[dataIndex++] = encodedBits[encodedIndex];
                    if (dataIndex == DataBits)
                    {
                        break;
                    }
                }
            }

            return dataBits;
        }
    } // namespace detail

    // Method Description:
    /// Returns the Hamming SECDED encoded bits for the data bits
    ///
    /// @param dataBits the data bits to encode
    /// @return encoded data bits
    /// @exception std::runtime_error if the number of data bits does not represent a valid Hamming SECDED code
    ///
    template<std::size_t DataBits>
    boost::dynamic_bitset<> encode(const std::bitset<DataBits>& dataBits)
    {
        const auto numParityBits  = detail::numSecdedParityBitsNeeded(DataBits);
        const auto numEncodedBits = numParityBits + DataBits;

        auto encodedBits = boost::dynamic_bitset<>(numEncodedBits); // NOLINT(google-readability-casting)

        // set the parity bits
        for (const auto parityBit :
             detail::powersOfTwo(numParityBits - 1)) // -1 because overall parity will be calculated seperately later
        {
            encodedBits[parityBit - 1] = detail::calculateParity(dataBits, parityBit);
        }

        // set the data bits, switch to 1 based to make things easier for isPowerOfTwo
        std::size_t dataBitIndex = 0;
        for (std::size_t bitIndex = 1; bitIndex <= numEncodedBits - 1;
             ++bitIndex) // -1 to account for the overall parity bit
        {
            if (!detail::isPowerOfTwo(bitIndex))
            {
                encodedBits[bitIndex - 1] = dataBits[dataBitIndex++];
            }
        }

        // compute and set overall parity for the entire encoded data (not including the overall parity bit itself)
        encodedBits[numEncodedBits - 1] = detail::calculateParity(encodedBits); // overall parity at the end

        // all done!
        return encodedBits;
    }

    // Method Description:
    /// Returns the Hamming SECDED decoded bits for the enocoded bits
    /// https://en.wikipedia.org/wiki/Hamming_code
    ///
    /// @param encodedBits the encoded bits to decode
    /// @param decodedBits the output decoded bits
    /// @return int status (0=no errors, 1=1 corrected error, 2=2 errors detected)
    /// @exception std::runtime_error if DataBits and EncodedBits are not consistent
    /// @exception std::runtime_error if the number of data bits does not represent a valid Hamming SECDED code
    ///
    template<std::size_t DataBits,
             std::size_t EncodedBits,
             std::enable_if_t<greaterThan_v<EncodedBits, DataBits>, int> = 0>
    int decode(std::bitset<EncodedBits> encodedBits, std::bitset<DataBits>& decodedBits)
    {
        const auto numParityBits = detail::checkBitsConsistent<DataBits, EncodedBits>();

        // the data bits, which may be corrupted
        decodedBits = detail::extractData<DataBits>(encodedBits);

        // check the overall parity bit
        const auto overallExpected = detail::calculateParity(encodedBits);
        const auto overallActual   = encodedBits[EncodedBits - 1];
        const auto overallCorrect  = overallExpected == overallActual;

        // check individual parities - each parity bit's index (besides overall parity) is a power of two
        std::size_t indexOfError = 0;
        for (const auto parityBit : detail::powersOfTwo(numParityBits - 1))
        {
            const auto expected = detail::calculateParity(decodedBits, parityBit);
            const auto actual   = encodedBits[parityBit - 1]; // -1 because parityBit is 1 based
            if (expected != actual)
            {
                indexOfError += parityBit;
            }
        }

        // attempt to repair a single flipped bit or throw exception if more than one
        if (overallCorrect && indexOfError != 0)
        {
            // two errors found
            return 2;
        }
        else if (!overallCorrect && indexOfError != 0)
        {
            // one error found, flip the bit in error and we're good
            encodedBits.flip(indexOfError - 1);
            decodedBits = detail::extractData<DataBits>(encodedBits);
            return 1;
        }

        return 0;
    }
} // namespace nc::edac
#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: hammingEncode.hpp ***/


/*** Start of inlined file: hanning.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the Hamming window.
    ///
    /// The Hanning window is a taper formed by using a weighted cosine.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.hanning.html
    ///
    /// @param m: Number of points in the output window. If zero or less, an empty array is returned.
    /// @return NdArray
    ///
    inline NdArray<double> hanning(int32 m)
    {
        if (m < 1)
        {
            return {};
        }

        const auto mDouble         = static_cast<double>(m);
        const auto twoPiDivMMinus1 = (2. * constants::pi) / (mDouble - 1.);

        NdArray<double> result(1, m);
        int32           i = 0;
        for (auto n : linspace(0., mDouble - 1., m, EndPoint::YES))
        {
            result[i++] = 0.5 - 0.5 * std::cos(twoPiDivMMinus1 * n);
        }

        return result;
    }
} // namespace nc

/*** End of inlined file: hanning.hpp ***/


/*** Start of inlined file: histogram.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>
#include <utility>

namespace nc
{

    // Method Description:
    /// Compute the histogram of a set of data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.histogram.html
    ///
    ///
    /// @param inArray
    /// @param inBinEdges: monotonically increasing array of bin edges, including the
    /// rightmost edge, allowing for non-uniform bin widths.
    ///
    /// @return array of histogram counts
    ///
    template<typename dtype>
    NdArray<uint32> histogram(const NdArray<dtype>& inArray, const NdArray<double>& inBinEdges)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inBinEdges.size() < 2)
        {
            THROW_INVALID_ARGUMENT_ERROR("number of bin edges must be >= 2.");
        }

        // sort just in case the user hasn't already
        const auto binEdges = sort(inBinEdges);

        NdArray<uint32> histo = zeros<uint32>(1, binEdges.size() - 1);
        for (const auto value : inArray)
        {
            if (value < binEdges.front() || value > binEdges.back())
            {
                continue;
            }

            // binary search to find the bin idx
            constexpr bool keepSearching = true;
            uint32         lowIdx        = 0;
            uint32         highIdx       = binEdges.size() - 1;
            while (keepSearching)
            {
                const uint32 idx = (lowIdx + highIdx) / 2; // integer division
                if (lowIdx == highIdx || lowIdx == highIdx - 1)
                {
                    // we found the bin
                    ++histo[lowIdx];
                    break;
                }

                if (value > binEdges[idx])
                {
                    lowIdx = idx;
                }
                else if (value < binEdges[idx])
                {
                    highIdx = idx;
                }
                else
                {
                    // we found the bin
                    ++histo[idx];
                    break;
                }
            }
        }

        return histo;
    }

    // Method Description:
    /// Compute the histogram of a set of data.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.histogram.html
    ///
    ///
    /// @param inArray
    /// @param inNumBins( default 10)
    ///
    /// @return std::pair of NdArrays; first is histogram counts, seconds is the bin edges
    ///
    template<typename dtype>
    std::pair<NdArray<uint32>, NdArray<double>> histogram(const NdArray<dtype>& inArray, uint32 inNumBins = 10)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inNumBins == 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("number of bins must be positive.");
        }

        const NdArray<double> binEdges = linspace(static_cast<double>(inArray.min().item()),
                                                  static_cast<double>(inArray.max().item()),
                                                  inNumBins + 1,
                                                  EndPoint::YES);

        const auto histo = histogram(inArray, binEdges);
        return std::make_pair(histo, binEdges);
    }
} // namespace nc

/*** End of inlined file: histogram.hpp ***/


/*** Start of inlined file: hsplit.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <vector>

namespace nc
{

    // Method Description:
    /// Split an array into multiple sub-arrays horizontal (column-wise).
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.hsplit.html
    ///
    /// @param inArray
    /// @param indices: the indices to split
    ///
    /// @return NdArray
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    std::vector<NdArray<dtype>> hsplit(const NdArray<dtype>& inArray, const Indices& indices)
    {
        const auto     numCols = static_cast<int32>(inArray.numCols());
        NdArray<int32> uniqueIndices(1, indices.size());
        stl_algorithms::transform(indices.begin(),
                                  indices.end(),
                                  uniqueIndices.begin(),
                                  [numCols](auto index) noexcept -> int32
                                  {
                                      if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                      {
                                          if (index < 0)
                                          {
                                              index = std::max(index + numCols, int32{ 0 });
                                          }
                                      }
                                      if (static_cast<int32>(index) > numCols - 1)
                                      {
                                          index = numCols - 1;
                                      }

                                      return static_cast<int32>(index);
                                  });
        uniqueIndices = unique(uniqueIndices);

        std::vector<NdArray<dtype>> splits{};
        splits.reserve(uniqueIndices.size() + 1);

        const auto rSlice   = inArray.rSlice();
        int32      lowerIdx = 0;
        for (const auto index : uniqueIndices)
        {
            if (index == 0)

            {
                splits.push_back(NdArray<dtype>(Shape(inArray.numRows(), 0)));
                continue;
            }
            else
            {
                splits.push_back(inArray(rSlice, Slice(lowerIdx, index)));
            }

            lowerIdx = index;
        }

        if (lowerIdx < numCols - 1)
        {
            splits.push_back(inArray(rSlice, Slice(lowerIdx, numCols)));
        }
        else
        {
            splits.push_back(inArray(rSlice, -1));
        }

        return splits;
    }
} // namespace nc

/*** End of inlined file: hsplit.hpp ***/


/*** Start of inlined file: hstack.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <vector>

namespace nc
{

    // Method Description:
    /// Stack arrays in sequence horizontally (column wise).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hstack.html
    ///
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> hstack(std::initializer_list<NdArray<dtype>> inArrayList)
    {
        return detail::column_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }

    // Method Description:
    /// Stack arrays in sequence horizontally (column wise).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.hstack.html
    ///
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> hstack(std::vector<NdArray<dtype>> inArrayList)
    {
        return detail::column_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }
} // namespace nc

/*** End of inlined file: hstack.hpp ***/


/*** Start of inlined file: identity.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the identity array.
    ///
    /// The identity array is a square array with ones on the main diagonal.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.identity.html
    ///
    /// @param inSquareSize
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> identity(uint32 inSquareSize)
    {
        NdArray<dtype> returnArray(inSquareSize);
        returnArray.zeros();
        for (uint32 i = 0; i < inSquareSize; ++i)
        {
            returnArray(i, i) = dtype{ 1 };
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: identity.hpp ***/


/*** Start of inlined file: imag.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Return the imaginar  part of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.imag.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto imag(const std::complex<dtype>& inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::imag(inValue);
    }

    // Method Description:
    /// Return the imaginary part of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.imag.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto imag(const NdArray<std::complex<dtype>>& inArray)
    {
        NdArray<decltype(nc::imag(std::complex<dtype>{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](auto& inValue) -> auto { return nc::imag(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: imag.hpp ***/


/*** Start of inlined file: inner.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>

namespace nc
{

    // Method Description:
    /// Inner product of two 1-D arrays.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.inner.html
    ///
    /// @param a: array 1
    /// @param b: array 2
    /// @return NdArray
    ///
    template<typename dtype>
    dtype inner(const NdArray<dtype>& a, const NdArray<dtype>& b)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (a.size() != b.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Inputs 'a' and 'b' must have the same size");
        }

        return std::inner_product(a.cbegin(), a.cend(), b.cbegin(), dtype{ 0 });
    }
} // namespace nc

/*** End of inlined file: inner.hpp ***/


/*** Start of inlined file: insert.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <utility>
#include <vector>


/*** Start of inlined file: ones_like.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with ones.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ones_like.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtypeOut, typename dtype>
    NdArray<dtypeOut> ones_like(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<dtypeOut> returnArray(inArray.shape());
        returnArray.ones();
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: ones_like.hpp ***/

namespace nc
{

    // Method Description:
    /// Insert values before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param index: index to insert the value before in the flattened
    /// @param value: value to insert
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, int32 index, const dtype& value)
    {
        const NdArray<dtype> values = { value };
        return insert(arr, index, values);
    }

    // Method Description:
    /// Insert values before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param index: index to insert the values before in the flattened
    /// @param values: value to insert
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, int32 index, const NdArray<dtype>& values)
    {
        if (index < 0)
        {
            index += arr.size();
            // still
            if (index < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("index out of range");
            }
        }
        else if (index > static_cast<int32>(arr.size()))
        {
            THROW_INVALID_ARGUMENT_ERROR("index out of range");
        }

        const auto valuesSlice = Slice(index, index + values.size());
        auto       result      = NdArray<dtype>(1, arr.size() + values.size());
        result.put(valuesSlice, values);

        NdArray<bool> mask(result.shape());
        mask.fill(true);
        mask.put(valuesSlice, false);
        result.putMask(mask, arr.flatten());

        return result;
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param index: index to insert the values before
    /// @param value: value to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, int32 index, const dtype& value, Axis axis)
    {
        const NdArray<dtype> values = { value };
        return insert(arr, index, values, axis);
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param index: index to insert the values before
    /// @param values: values to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, int32 index, const NdArray<dtype>& values, Axis axis)
    {
        switch (axis)
        {
            case Axis::NONE:
            {
                return insert(arr, index, values);
            }
            case Axis::ROW:
            {
                if (!(values.size() == arr.numCols() || values.isscalar() || values.numCols() == arr.numCols()))
                {
                    THROW_INVALID_ARGUMENT_ERROR("input values shape cannot be broadcast to input array dimensions");
                }

                if (index < 0)
                {
                    index += arr.numRows();
                    // still
                    if (index < 0)
                    {
                        THROW_INVALID_ARGUMENT_ERROR("index out of range");
                    }
                }
                else if (index > static_cast<int32>(arr.numRows()))
                {
                    THROW_INVALID_ARGUMENT_ERROR("index out of range");
                }

                auto  result = NdArray<dtype>();
                int32 valuesSize{};
                if (values.size() == arr.numCols() || values.isscalar())
                {
                    result.resizeFast(arr.numRows() + 1, arr.numCols());
                    valuesSize = 1;
                }
                else if (values.numCols() == arr.numCols())
                {
                    result.resizeFast(arr.numRows() + values.numRows(), arr.numCols());
                    valuesSize = values.numRows();
                }

                auto mask = ones_like<bool>(result);
                mask.put(Slice(index, index + valuesSize), mask.cSlice(), false);

                result.putMask(mask, arr);
                result.putMask(!mask, values);

                return result;
            }
            case Axis::COL:
            {
                if (!(values.size() == arr.numRows() || values.isscalar() || values.numRows() == arr.numRows()))
                {
                    THROW_INVALID_ARGUMENT_ERROR("input values shape cannot be broadcast to input array dimensions");
                }

                if (index < 0)
                {
                    index += arr.numCols();
                    // still
                    if (index < 0)
                    {
                        THROW_INVALID_ARGUMENT_ERROR("index out of range");
                    }
                }
                else if (index > static_cast<int32>(arr.numCols()))
                {
                    THROW_INVALID_ARGUMENT_ERROR("index out of range");
                }

                auto  result = NdArray<dtype>();
                int32 valuesSize{};
                if (values.size() == arr.numRows() || values.isscalar())
                {
                    result.resizeFast(arr.numRows(), arr.numCols() + 1);
                    valuesSize = 1;
                }
                else if (values.numRows() == arr.numRows())
                {
                    result.resizeFast(arr.numRows(), arr.numCols() + values.numCols());
                    valuesSize = values.numCols();
                }

                auto mask = ones_like<bool>(result);
                mask.put(mask.rSlice(), Slice(index, index + valuesSize), false);

                result.putMask(mask, arr);
                result.putMask(!mask, values);

                return result;
            }
            default:
            {
                // get rid of compiler warning
                return {};
            }
        }
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param indices: indices to insert the values before
    /// @param value: value to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype> insert(const NdArray<dtype>& arr, const Indices& indices, const dtype& value, Axis axis = Axis::NONE)
    {
        const NdArray<dtype> values = { value };
        return insert(arr, indices, values, axis);
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param slice: slice to insert the values before
    /// @param value: values to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, Slice slice, const dtype& value, Axis axis = Axis::NONE)
    {
        auto sliceIndices = slice.toIndices(arr.dimSize(axis));
        return insert(arr,
                      NdArray<uint32>(sliceIndices.data(), sliceIndices.size(), PointerPolicy::SHELL),
                      value,
                      axis);
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param indices: indices to insert the values before
    /// @param values: values to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>
        insert(const NdArray<dtype>& arr, const Indices& indices, const NdArray<dtype>& values, Axis axis = Axis::NONE)
    {
        const auto isScalarValue = values.isscalar();

        switch (axis)
        {
            case Axis::NONE:
            {
                if (!isScalarValue && indices.size() != values.size())
                {
                    THROW_INVALID_ARGUMENT_ERROR("could not broadcast values into indices");
                }

                const auto arrSize = static_cast<int32>(arr.size());

                std::vector<std::pair<int32, dtype>> indexValues(indices.size());
                if (isScalarValue)
                {
                    const auto value = values.front();
                    stl_algorithms::transform(indices.begin(),
                                              indices.end(),
                                              indexValues.begin(),
                                              [arrSize, value](auto index) -> std::pair<int32, dtype>
                                              {
                                                  if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                                  {
                                                      if (index < 0)
                                                      {
                                                          index += arrSize;
                                                      }
                                                      // still
                                                      if (index < 0)
                                                      {
                                                          THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                      }
                                                  }
                                                  if (static_cast<int32>(index) > arrSize)
                                                  {
                                                      THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                  }

                                                  return std::make_pair(static_cast<int32>(index), value);
                                              });
                }
                else
                {
                    stl_algorithms::transform(indices.begin(),
                                              indices.end(),
                                              values.begin(),
                                              indexValues.begin(),
                                              [arrSize](auto index, const auto& value) -> std::pair<int32, dtype>
                                              {
                                                  if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                                  {
                                                      if (index < 0)
                                                      {
                                                          index += arrSize;
                                                      }
                                                      // still
                                                      if (index < 0)
                                                      {
                                                          THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                      }
                                                  }
                                                  if (static_cast<int32>(index) > arrSize)
                                                  {
                                                      THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                  }

                                                  return std::make_pair(static_cast<int32>(index), value);
                                              });
                }

                stl_algorithms::sort(indexValues.begin(),
                                     indexValues.end(),
                                     [](const auto& indexValue1, const auto& indexValue2) noexcept -> bool
                                     { return indexValue1.first < indexValue2.first; });
                auto indexValuesUnique = std::vector<typename decltype(indexValues)::value_type>{};
                std::unique_copy(indexValues.begin(),
                                 indexValues.end(),
                                 std::back_inserter(indexValuesUnique),
                                 [](const auto& indexValue1, const auto& indexValue2) noexcept -> bool
                                 { return indexValue1.first == indexValue2.first; });

                auto result = NdArray<dtype>(1, arr.size() + indexValuesUnique.size());

                auto  mask    = ones_like<bool>(result);
                int32 counter = 0;
                std::for_each(indexValuesUnique.begin(),
                              indexValuesUnique.end(),
                              [&counter, &mask](auto& indexValue) noexcept -> void
                              { mask[indexValue.first + counter++] = false; });

                result.putMask(mask, arr);

                auto valuesSorted = [&indexValuesUnique]
                {
                    std::vector<dtype> values_;
                    values_.reserve(indexValuesUnique.size());
                    std::transform(indexValuesUnique.begin(),
                                   indexValuesUnique.end(),
                                   std::back_inserter(values_),
                                   [](const auto& indexValue) { return indexValue.second; });
                    return values_;
                }();

                result.putMask(!mask, NdArray<dtype>(valuesSorted.data(), valuesSorted.size(), PointerPolicy::SHELL));

                return result;
            }
            case Axis::ROW:
            {
                const auto arrNumRows = static_cast<int32>(arr.numRows());

                std::vector<std::pair<int32, NdArray<dtype>>> indexValues(indices.size());
                if (values.isscalar())
                {
                    const auto value    = values.front();
                    auto       valueRow = NdArray<dtype>(1, arr.numCols());
                    valueRow.fill(value);
                    stl_algorithms::transform(indices.begin(),
                                              indices.end(),
                                              indexValues.begin(),
                                              [arrNumRows, &valueRow](auto index) -> std::pair<int32, NdArray<dtype>>
                                              {
                                                  if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                                  {
                                                      if (index < 0)
                                                      {
                                                          index += arrNumRows;
                                                      }
                                                      // still
                                                      if (index < 0)
                                                      {
                                                          THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                      }
                                                  }
                                                  if (static_cast<int32>(index) > arrNumRows)
                                                  {
                                                      THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                  }

                                                  return std::make_pair(static_cast<int32>(index), valueRow);
                                              });
                }
                else if (values.size() == arr.numCols())
                {
                    stl_algorithms::transform(indices.begin(),
                                              indices.end(),
                                              indexValues.begin(),
                                              [arrNumRows, &values](auto index) -> std::pair<int32, NdArray<dtype>>
                                              {
                                                  if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                                  {
                                                      if (index < 0)
                                                      {
                                                          index += arrNumRows;
                                                      }
                                                      // still
                                                      if (index < 0)
                                                      {
                                                          THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                      }
                                                  }
                                                  if (static_cast<int32>(index) > arrNumRows)
                                                  {
                                                      THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                                  }

                                                  return std::make_pair(static_cast<int32>(index), values);
                                              });
                }
                else if (values.numCols() == arr.numCols() && values.numRows() == indices.size())
                {
                    int32 counter = 0;
                    std::transform(indices.begin(),
                                   indices.end(),
                                   indexValues.begin(),
                                   [arrNumRows, &values, &counter](auto index) -> std::pair<int32, NdArray<dtype>>
                                   {
                                       if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                       {
                                           if (index < 0)
                                           {
                                               index += arrNumRows;
                                           }
                                           // still
                                           if (index < 0)
                                           {
                                               THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                           }
                                       }
                                       if (static_cast<int32>(index) > arrNumRows)
                                       {
                                           THROW_INVALID_ARGUMENT_ERROR("index out of range");
                                       }

                                       return std::make_pair(static_cast<int32>(index),
                                                             values(counter++, values.cSlice()));
                                   });
                }
                else
                {
                    THROW_INVALID_ARGUMENT_ERROR("input values shape cannot be broadcast to input array dimensions");
                }

                stl_algorithms::sort(indexValues.begin(),
                                     indexValues.end(),
                                     [](const auto& indexValue1, const auto& indexValue2) noexcept -> bool
                                     { return indexValue1.first < indexValue2.first; });
                auto indexValuesUnique = std::vector<typename decltype(indexValues)::value_type>{};
                std::unique_copy(indexValues.begin(),
                                 indexValues.end(),
                                 std::back_inserter(indexValuesUnique),
                                 [](const auto& indexValue1, const auto& indexValue2) noexcept -> bool
                                 { return indexValue1.first == indexValue2.first; });

                auto result = NdArray<dtype>(arrNumRows + indexValuesUnique.size(), arr.numCols());

                auto  mask    = ones_like<bool>(result);
                int32 counter = 0;
                std::for_each(indexValuesUnique.begin(),
                              indexValuesUnique.end(),
                              [&counter, &mask](auto& indexValue) noexcept -> void
                              { mask.put(indexValue.first + counter++, mask.cSlice(), false); });

                result.putMask(mask, arr);

                counter = 0;
                for (const auto& [index, values_] : indexValuesUnique)
                {
                    result.put(index + counter++, result.cSlice(), values_);
                }

                return result;
            }
            case Axis::COL:
            {
                return insert(arr.transpose(), indices, values.transpose(), Axis::ROW).transpose();
            }
            default:
            {
                // get rid of compiler warning
                return {};
            }
        }
    }

    // Method Description:
    /// Insert values along the given axis before the given indices.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.insert.html
    ///
    /// @param arr: input array.
    /// @param slice: slice to insert the values before
    /// @param values: values to insert
    /// @param axis: axis along which to insert values
    /// @return index: index before which values are inserted.
    ///
    template<typename dtype>
    NdArray<dtype> insert(const NdArray<dtype>& arr, Slice slice, const NdArray<dtype>& values, Axis axis = Axis::NONE)
    {
        auto sliceIndices = slice.toIndices(arr.dimSize(axis));
        return insert(arr,
                      NdArray<uint32>(sliceIndices.data(), sliceIndices.size(), PointerPolicy::SHELL),
                      values,
                      axis);
    }
} // namespace nc

/*** End of inlined file: insert.hpp ***/


/*** Start of inlined file: interp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    /// Returns the linear interpolation between two points
    ///
    /// @param inValue1
    /// @param inValue2
    /// @param inPercent
    ///
    /// @return linear interpolated point
    ///
    template<typename dtype>
    constexpr double interp(dtype inValue1, dtype inValue2, double inPercent) noexcept
    {
        return utils::interp(inValue1, inValue2, inPercent);
    }

    // Method Description:
    /// One-dimensional linear interpolation.
    ///
    /// Returns the one - dimensional piecewise linear interpolant
    /// to a function with given values at discrete data - points.
    /// If input arrays are not one dimensional they will be
    /// internally flattened.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.interp.html
    ///
    /// @param inX: The x-coordinates at which to evaluate the interpolated values.
    /// @param inXp: The x-coordinates of the data points, must be increasing. Otherwise, xp is internally sorted.
    /// @param inFp: The y-coordinates of the data points, same length as inXp.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> interp(const NdArray<dtype>& inX, const NdArray<dtype>& inXp, const NdArray<dtype>& inFp)
    {
        // do some error checking first
        if (inXp.size() != inFp.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("inXp and inFp need to be the same size().");
        }

        if (inX.min().item() < inXp.min().item() || inX.max().item() > inXp.max().item())
        {
            THROW_INVALID_ARGUMENT_ERROR("endpoints of inX should be contained within inXp.");
        }

        // sort the input inXp and inFp data
        NdArray<uint32> sortedXpIdxs = argsort(inXp);
        NdArray<dtype>  sortedXp(1, inFp.size());
        NdArray<dtype>  sortedFp(1, inFp.size());
        uint32          counter = 0;
        for (auto sortedXpIdx : sortedXpIdxs)
        {
            sortedXp[counter]   = inXp[sortedXpIdx];
            sortedFp[counter++] = inFp[sortedXpIdx];
        }

        // get the sorted input inX array indices
        NdArray<uint32> sortedXIdxs = argsort(inX);

        NdArray<dtype> returnArray(1, inX.size());

        uint32 currXpIdx = 0;
        uint32 currXidx  = 0;
        while (currXidx < inX.size())
        {
            const auto sortedXIdx = sortedXIdxs[currXidx];
            const auto x          = inX[sortedXIdx];
            const auto xPLow      = sortedXp[currXpIdx];
            const auto xPHigh     = sortedXp[currXpIdx + 1];
            const auto fPLow      = sortedFp[currXpIdx];
            const auto fPHigh     = sortedFp[currXpIdx + 1];

            if (xPLow <= x && x <= xPHigh)
            {
                const double percent    = static_cast<double>(x - xPLow) / static_cast<double>(xPHigh - xPLow);
                returnArray[sortedXIdx] = utils::interp(fPLow, fPHigh, percent);
                ++currXidx;
            }
            else
            {
                ++currXpIdx;
            }
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: interp.hpp ***/


/*** Start of inlined file: intersect1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <set>
#include <vector>

namespace nc
{

    // Method Description:
    /// Find the intersection of two arrays.
    ///
    /// Return the sorted, unique values that are in both of the input arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.intersect1d.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> intersect1d(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::vector<dtype>    res(inArray1.size() + inArray2.size());
        const std::set<dtype> in1(inArray1.cbegin(), inArray1.cend());
        const std::set<dtype> in2(inArray2.cbegin(), inArray2.cend());

        const auto iter = stl_algorithms::set_intersection(in1.begin(), in1.end(), in2.begin(), in2.end(), res.begin());
        res.resize(iter - res.begin());
        return NdArray<dtype>(res);
    }
} // namespace nc

/*** End of inlined file: intersect1d.hpp ***/


/*** Start of inlined file: invert.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute bit-wise inversion, or bit-wise NOT, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.invert.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> invert(const NdArray<dtype>& inArray)
    {
        return ~inArray;
    }
} // namespace nc

/*** End of inlined file: invert.hpp ***/


/*** Start of inlined file: isclose.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Returns a boolean array where two arrays are element-wise
    /// equal within a tolerance.
    ///
    /// For finite values, isclose uses the following equation to test whether two floating point values are equivalent.
    /// absolute(a - b) <= (atol + rtol * absolute(b))
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isclose.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @param inRtol: relative tolerance (default 1e-5)
    /// @param inAtol: absolute tolerance (default 1e-9)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> isclose(const NdArray<dtype>& inArray1,
                          const NdArray<dtype>& inArray2,
                          double                inRtol = 1e-05,
                          double                inAtol = 1e-08)
    {
        STATIC_ASSERT_FLOAT(dtype);

        if (inArray1.shape() != inArray2.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array shapes are not consistant.");
        }

        NdArray<bool> returnArray(inArray1.shape());
        stl_algorithms::transform(inArray1.cbegin(),
                                  inArray1.cend(),
                                  inArray2.cbegin(),
                                  returnArray.begin(),
                                  [inRtol, inAtol](dtype inValueA, dtype inValueB) noexcept -> bool
                                  { return std::abs(inValueA - inValueB) <= (inAtol + inRtol * std::abs(inValueB)); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: isclose.hpp ***/


/*** Start of inlined file: isinf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Test for inf and return result as a boolean.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isinf.html
    ///
    /// @param inValue
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool isinf(dtype inValue) noexcept
    {
        STATIC_ASSERT_FLOAT(dtype);

        return std::isinf(inValue);
    }

    // Method Description:
    /// Test element-wise for inf and return result as a boolean array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isinf.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> isinf(const NdArray<dtype>& inArray)
    {
        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> bool { return isinf(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: isinf.hpp ***/


/*** Start of inlined file: isnan.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Test for NaN and return result as a boolean.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isnan.html
    ///
    /// @param inValue
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool isnan(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (DtypeInfo<dtype>::isInteger())
        {
            return false;
        }

        return std::isnan(static_cast<double>(inValue)); // static_cast is needed for compiler error
    }

    // Method Description:
    /// Test element-wise for NaN and return result as a boolean array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isnan.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> isnan(const NdArray<dtype>& inArray)
    {
        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> bool { return isnan(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: isnan.hpp ***/


/*** Start of inlined file: isneginf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Test for negative inf and return result as a boolean.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isneginf.html
    ///
    /// @param inValue
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool isneginf(dtype inValue) noexcept
    {
        STATIC_ASSERT_FLOAT(dtype);

        return inValue < 0 && std::isinf(inValue);
    }

    // Method Description:
    /// Test element-wise for negative inf and return result as a boolean array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isneginf.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> isneginf(const NdArray<dtype>& inArray)
    {
        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> bool { return isneginf(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: isneginf.hpp ***/


/*** Start of inlined file: isposinf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Test for positive inf and return result as a boolean.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isposinf.html
    ///
    /// @param inValue
    ///
    /// @return bool
    ///
    template<typename dtype>
    bool isposinf(dtype inValue) noexcept
    {
        STATIC_ASSERT_FLOAT(dtype);

        return inValue > 0 && std::isinf(inValue);
    }

    // Method Description:
    /// Test element-wise for positive inf and return result as a boolean array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.isposinf.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> isposinf(const NdArray<dtype>& inArray)
    {
        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> bool { return isposinf(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: isposinf.hpp ***/


/*** Start of inlined file: kaiser.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)


/*** Start of inlined file: bessel_in.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Modified Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_in(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::cyl_bessel_i(static_cast<double>(inV), static_cast<double>(inX));
#else
        return boost::math::cyl_bessel_i(static_cast<double>(inV), static_cast<double>(inX));
#endif
    }

    // Method Description:
    /// Modified Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_in(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_in(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_in(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: bessel_in.hpp ***/

namespace nc
{

    // Method Description:
    /// The Kaiser window is a taper formed by using a Bessel function.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.kaiser.html
    ///
    /// @param m: Number of points in the output window. If zero or less, an empty array is returned.
    /// @param beta: shape parameter for the window
    /// @return NdArray
    ///
    inline NdArray<double> kaiser(int32 m, double beta)
    {
        if (m < 1)
        {
            return {};
        }

        const auto mDouble        = static_cast<double>(m);
        const auto mMinus1        = mDouble - 1.;
        const auto mMinus1Over2   = mMinus1 / 2.;
        const auto mMinus1Squared = utils::sqr(mMinus1);
        const auto i0Beta         = special::bessel_in(0, beta);

        NdArray<double> result(1, m);
        int32           i = 0;
        for (auto n : linspace(-mMinus1Over2, mMinus1Over2, m, EndPoint::YES))
        {
            auto value  = beta * std::sqrt(1. - (4. * utils::sqr(n)) / mMinus1Squared);
            result[i++] = special::bessel_in(0, value) / i0Beta;
        }

        return result;
    }
} // namespace nc

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: kaiser.hpp ***/


/*** Start of inlined file: lcm.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <numeric>

#if defined(__cpp_lib_gcd_lcm) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef NUMCPP_NO_USE_BOOST
#include "boost/integer/common_factor_rt.hpp"
#endif

namespace nc
{

    // Method Description:
    /// Returns the least common multiple of |x1| and |x2|.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.lcm.html
    ///
    /// @param inValue1
    /// @param inValue2
    /// @return dtype
    ///
    template<typename dtype>
    dtype lcm(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_INTEGER(dtype);

#ifdef __cpp_lib_gcd_lcm
        return std::lcm(inValue1, inValue2);
#else
        return boost::integer::lcm(inValue1, inValue2);
#endif
    }

#ifndef NUMCPP_NO_USE_BOOST

    // Method Description:
    /// Returns the least common multiple of the values of the input array.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.lcm.html
    ///
    /// @param inArray
    /// @return NdArray<double>
    ///
    template<typename dtype>
    dtype lcm(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_INTEGER(dtype);

        return boost::integer::lcm_range(inArray.cbegin(), inArray.cend()).first;
    }
#endif // #ifndef NUMCPP_NO_USE_BOOST
} // namespace nc

#endif // #if defined(__cpp_lib_gcd_lcm) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: lcm.hpp ***/


/*** Start of inlined file: ldexp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Returns x1 * 2^x2.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ldexp.html
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return value
    ///
    template<typename dtype>
    dtype ldexp(dtype inValue1, uint8 inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return static_cast<dtype>(std::ldexp(static_cast<double>(inValue1), inValue2));
    }

    // Method Description:
    /// Returns x1 * 2^x2, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ldexp.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ldexp(const NdArray<dtype>& inArray1, const NdArray<uint8>& inArray2)
    {
        if (inArray1.shape() != inArray2.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array shapes are not consistant.");
        }

        NdArray<dtype> returnArray(inArray1.shape());
        stl_algorithms::transform(inArray1.cbegin(),
                                  inArray1.cend(),
                                  inArray2.cbegin(),
                                  returnArray.begin(),
                                  [](dtype inValue1, uint8 inValue2) noexcept -> dtype
                                  { return ldexp(inValue1, inValue2); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: ldexp.hpp ***/


/*** Start of inlined file: left_shift.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Shift the bits of an integer to the left.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.left_shift.html
    ///
    /// @param inArray
    /// @param inNumBits
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> left_shift(const NdArray<dtype>& inArray, uint8 inNumBits)
    {
        return inArray << inNumBits;
    }
} // namespace nc

/*** End of inlined file: left_shift.hpp ***/


/*** Start of inlined file: less.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the truth value of (x1 < x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.less.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> less(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 < inArray2;
    }
} // namespace nc

/*** End of inlined file: less.hpp ***/


/*** Start of inlined file: less_equal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the truth value of (x1 <= x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.less_equal.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> less_equal(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 <= inArray2;
    }
} // namespace nc

/*** End of inlined file: less_equal.hpp ***/


/*** Start of inlined file: load.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// loads a .bin file from the dump() method into an NdArray
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.load.html
    ///
    /// @param inFilename
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> load(const std::string& inFilename)
    {
        return fromfile<dtype>(inFilename);
    }
} // namespace nc

/*** End of inlined file: load.hpp ***/


/*** Start of inlined file: log.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Natural logarithm.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    auto log(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::log(inValue);
    }

    // Method Description:
    /// Natural logarithm, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto log(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(log(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return log(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: log.hpp ***/


/*** Start of inlined file: log10.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Return the base 10 logarithm of the input array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log10.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    auto log10(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::log10(inValue);
    }

    // Method Description:
    /// Return the base 10 logarithm of the input array, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log10.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto log10(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(log10(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return log10(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: log10.hpp ***/


/*** Start of inlined file: log1p.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the natural logarithm of one plus the input array.
    ///
    /// Calculates log(1 + x).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log1p.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    auto log1p(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::log1p(inValue);
    }

    // Method Description:
    /// Return the natural logarithm of one plus the input array, element-wise.
    ///
    /// Calculates log(1 + x).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log1p.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto log1p(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(log1p(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return log1p(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: log1p.hpp ***/


/*** Start of inlined file: log2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Base-2 logarithm of x.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log2.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    auto log2(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::log2(inValue);
    }

    // Method Description:
    /// Base-2 logarithm of x.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.log2.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto log2(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(log2(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return log2(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: log2.hpp ***/


/*** Start of inlined file: logaddexp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Logarithm of the sum of exponentiations of the inputs.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.logaddexp.html
    ///
    /// @param x1
    /// @param x2
    ///
    /// @return value
    ///
    template<typename dtype>
    auto logaddexp(dtype x1, dtype x2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::log(std::exp(x1) + std::exp(x2));
    }

    // Method Description:
    /// Logarithm of the sum of exponentiations of the inputs, element-wise.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.logaddexp.html
    ///
    /// @param x1
    /// @param x2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto logaddexp(const NdArray<dtype>& x1, const NdArray<dtype>& x2)
    {
        if (x1.size() != x2.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Inputs 'x1', and 'x2' must be the same size");
        }

        NdArray<decltype(logaddexp(dtype{ 0 }, dtype{ 0 }))> returnArray(x1.shape());
        stl_algorithms::transform(x1.cbegin(),
                                  x1.cend(),
                                  x2.cbegin(),
                                  returnArray.begin(),
                                  [](dtype inX1, dtype inX2) noexcept -> auto { return logaddexp(inX1, inX2); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: logaddexp.hpp ***/


/*** Start of inlined file: logaddexp2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Logarithm of the sum of exponentiations of the inputs.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.logaddexp.html
    ///
    /// @param x1
    /// @param x2
    ///
    /// @return value
    ///
    template<typename dtype>
    auto logaddexp2(dtype x1, dtype x2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::log2(utils::powerf(2, x1) + utils::powerf(2, x2));
    }

    // Method Description:
    /// Logarithm of the sum of exponentiations of the inputs, element-wise.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.logaddexp.html
    ///
    /// @param x1
    /// @param x2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto logaddexp2(const NdArray<dtype>& x1, const NdArray<dtype>& x2)
    {
        if (x1.size() != x2.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Inputs 'x1', and 'x2' must be the same size");
        }

        NdArray<decltype(logaddexp(dtype{ 0 }, dtype{ 0 }))> returnArray(x1.shape());
        stl_algorithms::transform(x1.cbegin(),
                                  x1.cend(),
                                  x2.cbegin(),
                                  returnArray.begin(),
                                  [](dtype inX1, dtype inX2) noexcept -> auto { return logaddexp2(inX1, inX2); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: logaddexp2.hpp ***/


/*** Start of inlined file: logical_and.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Compute the truth value of x1 AND x2 element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.logical_and.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> logical_and(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 && inArray2;
    }
} // namespace nc

/*** End of inlined file: logical_and.hpp ***/


/*** Start of inlined file: logical_not.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the truth value of NOT x element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.logical_not.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> logical_not(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> bool { return utils::essentiallyEqual(inValue, dtype{ 0 }); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: logical_not.hpp ***/


/*** Start of inlined file: logical_or.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Compute the truth value of x1 OR x2 element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.logical_or.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> logical_or(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 || inArray2;
    }
} // namespace nc

/*** End of inlined file: logical_or.hpp ***/


/*** Start of inlined file: logical_xor.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Compute the truth value of x1 XOR x2 element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.logical_xor.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> logical_xor(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return broadcast::broadcaster<bool>(inArray1,
                                            inArray2,
                                            [](dtype inValue1, dtype inValue2) -> bool {
                                                return !utils::essentiallyEqual(inValue1, dtype{ 0 }) !=
                                                       !utils::essentiallyEqual(inValue2, dtype{ 0 });
                                            });
    }
} // namespace nc

/*** End of inlined file: logical_xor.hpp ***/


/*** Start of inlined file: matmul.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Matrix product of two arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.matmul.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> matmul(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return dot(inArray1, inArray2);
    }

    // Method Description:
    /// Matrix product of two arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.matmul.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> matmul(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        return dot(inArray1, inArray2);
    }

    // Method Description:
    /// Matrix product of two arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.matmul.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> matmul(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        return dot(inArray1, inArray2);
    }
} // namespace nc

/*** End of inlined file: matmul.hpp ***/


/*** Start of inlined file: max.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the maximum of an array or maximum along an axis.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> max(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.max(inAxis);
    }
} // namespace nc

/*** End of inlined file: max.hpp ***/


/*** Start of inlined file: maximum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.maximum.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> maximum(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto comparitor = [](const dtype& lhs, const dtype& rhs) noexcept -> bool { return lhs < rhs; };
        return broadcast::broadcaster<dtype>(inArray1,
                                             inArray2,
                                             [&comparitor](const dtype& value1, const dtype& value2)
                                             { return std::max(value1, value2, comparitor); });
    }

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.maximum.html
    ///
    ///
    /// @param inArray
    /// @param inScalar
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> maximum(const NdArray<dtype>& inArray, const dtype& inScalar)
    {
        const NdArray<dtype> inArray2 = { inScalar };
        return maximum(inArray, inArray2);
    }

    // Method Description:
    /// Element-wise maximum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.maximum.html
    ///
    ///
    /// @param inScalar
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> maximum(const dtype& inScalar, const NdArray<dtype>& inArray)
    {
        return maximum(inArray, inScalar);
    }
} // namespace nc

/*** End of inlined file: maximum.hpp ***/


/*** Start of inlined file: median.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the median along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.median.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> median(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.median(inAxis);
    }
} // namespace nc

/*** End of inlined file: median.hpp ***/


/*** Start of inlined file: meshgrid.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <utility>

namespace nc
{

    // Method Description:
    /// Return coordinate matrices from coordinate vectors.
    /// Make 2D coordinate arrays for vectorized evaluations of 2D scalar
    /// vector fields over 2D grids, given one - dimensional coordinate arrays x1, x2, ..., xn.
    /// If input arrays are not one dimensional they will be flattened.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.meshgrid.html
    ///
    /// @param inICoords
    /// @param inJCoords
    ///
    /// @return std::pair<NdArray<dtype>, NdArray<dtype> >, i and j matrices
    ///
    template<typename dtype>
    std::pair<NdArray<dtype>, NdArray<dtype>> meshgrid(const NdArray<dtype>& inICoords, const NdArray<dtype>& inJCoords)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const uint32 numRows      = inJCoords.size();
        const uint32 numCols      = inICoords.size();
        auto         returnArrayI = NdArray<dtype>(numRows, numCols);
        auto         returnArrayJ = NdArray<dtype>(numRows, numCols);

        // first the I array
        for (uint32 row = 0; row < numRows; ++row)
        {
            for (uint32 col = 0; col < numCols; ++col)
            {
                returnArrayI(row, col) = inICoords[col];
            }
        }

        // then the I array
        for (uint32 col = 0; col < numCols; ++col)
        {
            for (uint32 row = 0; row < numRows; ++row)
            {
                returnArrayJ(row, col) = inJCoords[row];
            }
        }

        return std::make_pair(returnArrayI, returnArrayJ);
    }

    // Method Description:
    /// Return coordinate matrices from coordinate vectors.
    /// Make 2D coordinate arrays for vectorized evaluations of 2D scalar
    /// vector fields over 2D grids, given one - dimensional coordinate arrays x1, x2, ..., xn.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.meshgrid.html
    ///
    /// @param inSlice1
    /// @param inSlice2
    ///
    /// @return std::pair<NdArray<dtype>, NdArray<dtype> >, i and j matrices
    ///
    template<typename dtype>
    std::pair<NdArray<dtype>, NdArray<dtype>> meshgrid(const Slice& inSlice1, const Slice& inSlice2)
    {
        return meshgrid(arange<dtype>(inSlice1), arange<dtype>(inSlice2));
    }

} // namespace nc

/*** End of inlined file: meshgrid.hpp ***/


/*** Start of inlined file: min.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the minimum of an array or minimum along an axis.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> min(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.min(inAxis);
    }
} // namespace nc

/*** End of inlined file: min.hpp ***/


/*** Start of inlined file: minimum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>
#include <string>

namespace nc
{

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.minimum.html
    ///
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> minimum(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto comparitor = [](const dtype& lhs, const dtype& rhs) noexcept -> bool { return lhs < rhs; };
        return broadcast::broadcaster<dtype>(inArray1,
                                             inArray2,
                                             [&comparitor](const dtype& value1, const dtype& value2)
                                             { return std::min(value1, value2, comparitor); });
    }

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.minimum.html
    ///
    ///
    /// @param inArray
    /// @param inScalar
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> minimum(const NdArray<dtype>& inArray, const dtype& inScalar)
    {
        const NdArray<dtype> inArray2 = { inScalar };
        return minimum(inArray, inArray2);
    }

    // Method Description:
    /// Element-wise minimum of array elements.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.minimum.html
    ///
    ///
    /// @param inScalar
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> minimum(const dtype& inScalar, const NdArray<dtype>& inArray)
    {
        return minimum(inArray, inScalar);
    }
} // namespace nc

/*** End of inlined file: minimum.hpp ***/


/*** Start of inlined file: mod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return element-wise remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.mod.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> mod(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 % inArray2;
    }
} // namespace nc

/*** End of inlined file: mod.hpp ***/


/*** Start of inlined file: multiply.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> multiply(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 * inArray2;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> multiply(const NdArray<dtype>& inArray, dtype value)
    {
        return inArray * value;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> multiply(dtype value, const NdArray<dtype>& inArray)
    {
        return value * inArray;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        return inArray1 * inArray2;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 * inArray2;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(const NdArray<dtype>& inArray, const std::complex<dtype>& value)
    {
        return inArray * value;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(const std::complex<dtype>& value, const NdArray<dtype>& inArray)
    {
        return value * inArray;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(const NdArray<std::complex<dtype>>& inArray, dtype value)
    {
        return inArray * value;
    }

    // Method Description:
    /// multiply arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.multiply.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> multiply(dtype value, const NdArray<std::complex<dtype>>& inArray)
    {
        return value * inArray;
    }
} // namespace nc

/*** End of inlined file: multiply.hpp ***/


/*** Start of inlined file: nan_to_num.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <utility>

namespace nc
{

    // Method Description:
    /// Replace NaN with zero and infinity with large finite numbers (default behaviour)
    /// or with the numbers defined by the user using the nan, posinf and/or neginf keywords.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.nan_to_num.html
    ///
    /// @param inArray
    /// @param nan: value to be used to fill NaN values, default 0
    /// @param posInf: value to be used to fill positive infinity values, default a very large number
    /// @param negInf: value to be used to fill negative infinity values, default a very large negative number
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nan_to_num(NdArray<dtype> inArray,
                              dtype          nan    = static_cast<dtype>(0.),
                              dtype          posInf = DtypeInfo<dtype>::max(),
                              dtype          negInf = DtypeInfo<dtype>::min())
    {
        STATIC_ASSERT_FLOAT(dtype);

        stl_algorithms::for_each(inArray.begin(),
                                 inArray.end(),
                                 [nan, posInf, negInf](dtype& value)
                                 {
                                     if (isnan(value))
                                     {
                                         value = nan;
                                     }
                                     else if (isinf(value))
                                     {
                                         if (value > static_cast<dtype>(0.))
                                         {
                                             value = posInf;
                                         }
                                         else
                                         {
                                             value = negInf;
                                         }
                                     }
                                 });

        return inArray;
    }
} // namespace nc

/*** End of inlined file: nan_to_num.hpp ***/


/*** Start of inlined file: nanargmax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Returns the indices of the maximum values along an axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanargmax.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> nanargmax(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = DtypeInfo<dtype>::min();
                                     };
                                 });

        return argmax(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nanargmax.hpp ***/


/*** Start of inlined file: nanargmin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Returns the indices of the minimum values along an axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanargmin.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<uint32> nanargmin(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = DtypeInfo<dtype>::max();
                                     };
                                 });

        return argmin(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nanargmin.hpp ***/


/*** Start of inlined file: nancumprod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the cumulative product of elements along a given axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nancumprod.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nancumprod(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = dtype{ 1 };
                                     };
                                 });

        return cumprod(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nancumprod.hpp ***/


/*** Start of inlined file: nancumsum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the cumulative sum of the elements along a given axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nancumsum.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nancumsum(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = dtype{ 0 };
                                     };
                                 });

        return cumsum(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nancumsum.hpp ***/


/*** Start of inlined file: nanmax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the maximum of an array or maximum along an axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanmax.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nanmax(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = DtypeInfo<dtype>::min();
                                     };
                                 });

        return max(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nanmax.hpp ***/


/*** Start of inlined file: nanmean.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>

namespace nc
{

    // Method Description:
    /// Compute the mean along the specified axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanmean.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> nanmean(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                auto sum = static_cast<double>(std::accumulate(inArray.cbegin(),
                                                               inArray.cend(),
                                                               0.,
                                                               [](dtype inValue1, dtype inValue2) -> dtype {
                                                                   return std::isnan(inValue2) ? inValue1
                                                                                               : inValue1 + inValue2;
                                                               }));

                const auto numberNonNan =
                    static_cast<double>(std::accumulate(inArray.cbegin(),
                                                        inArray.cend(),
                                                        0.,
                                                        [](dtype inValue1, dtype inValue2) -> dtype
                                                        { return std::isnan(inValue2) ? inValue1 : inValue1 + 1; }));

                NdArray<double> returnArray = { sum /= numberNonNan };

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape     inShape = inArray.shape();
                NdArray<double> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    auto sum = static_cast<double>(
                        std::accumulate(inArray.cbegin(row),
                                        inArray.cend(row),
                                        0.,
                                        [](dtype inValue1, dtype inValue2) -> dtype
                                        { return std::isnan(inValue2) ? inValue1 : inValue1 + inValue2; }));

                    auto numberNonNan =
                        static_cast<double>(std::accumulate(inArray.cbegin(row),
                                                            inArray.cend(row),
                                                            0.,
                                                            [](dtype inValue1, dtype inValue2) -> dtype {
                                                                return std::isnan(inValue2) ? inValue1 : inValue1 + 1;
                                                            }));

                    returnArray(0, row) = sum / numberNonNan;
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return nanmean(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: nanmean.hpp ***/


/*** Start of inlined file: nanmedian.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <vector>

namespace nc
{

    // Method Description:
    /// Compute the median along the specified axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanmedian.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nanmedian(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::vector<dtype> values;
                for (auto value : inArray)
                {
                    if (!std::isnan(value))
                    {
                        values.push_back(value);
                    }
                }

                const uint32 middle = static_cast<uint32>(values.size()) / 2;
                stl_algorithms::nth_element(values.begin(), values.begin() + middle, values.end());
                NdArray<dtype> returnArray = { values[middle] };

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape    inShape = inArray.shape();
                NdArray<dtype> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    std::vector<dtype> values;
                    for (uint32 col = 0; col < inShape.cols; ++col)
                    {
                        if (!std::isnan(inArray(row, col)))
                        {
                            values.push_back(inArray(row, col));
                        }
                    }

                    const uint32 middle = static_cast<uint32>(values.size()) / 2;
                    stl_algorithms::nth_element(values.begin(), values.begin() + middle, values.end());
                    returnArray(0, row) = values[middle];
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return nanmedian(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: nanmedian.hpp ***/


/*** Start of inlined file: nanmin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the minimum of an array or maximum along an axis ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanmin.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nanmin(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = DtypeInfo<dtype>::max();
                                     };
                                 });

        return min(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nanmin.hpp ***/


/*** Start of inlined file: nanpercentile.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <string>
#include <vector>

namespace nc
{

    // Method Description:
    /// Compute the qth percentile of the data along the specified axis, while ignoring nan values.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanpercentile.html
    ///
    /// @param inArray
    /// @param inPercentile
    /// @param inAxis (Optional, default NONE)
    /// @param inInterpMethod (default linear) choices = ['linear','lower','higher','nearest','midpoint']
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> nanpercentile(const NdArray<dtype>& inArray,
                                  double                inPercentile,
                                  Axis                  inAxis         = Axis::NONE,
                                  InterpolationMethod   inInterpMethod = InterpolationMethod::LINEAR)
    {
        STATIC_ASSERT_FLOAT(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::vector<double> arrayCopy;
                arrayCopy.reserve(inArray.size());
                for (auto value : inArray)
                {
                    if (!isnan(value))
                    {
                        arrayCopy.push_back(static_cast<double>(value));
                    }
                }

                if (arrayCopy.empty())
                {
                    NdArray<double> returnArray = { constants::nan };
                    return returnArray;
                }

                return percentile(NdArray<double>(arrayCopy.data(),
                                                  static_cast<typename NdArray<dtype>::size_type>(arrayCopy.size()),
                                                  PointerPolicy::SHELL),
                                  inPercentile,
                                  Axis::NONE,
                                  inInterpMethod);
            }
            case Axis::COL:
            {
                const Shape inShape = inArray.shape();

                NdArray<double> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    NdArray<double> outValue = nanpercentile(NdArray<dtype>(&inArray.front(row), inShape.cols),
                                                             inPercentile,
                                                             Axis::NONE,
                                                             inInterpMethod);

                    if (outValue.isscalar())
                    {
                        returnArray[row] = outValue.item();
                    }
                    else
                    {
                        returnArray[row] = constants::nan;
                    }
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return nanpercentile(inArray.transpose(), inPercentile, Axis::COL, inInterpMethod);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }

        return {}; // get rid of compiler warning
    }
} // namespace nc

/*** End of inlined file: nanpercentile.hpp ***/


/*** Start of inlined file: nanprod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>


/*** Start of inlined file: prod.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the product of array elements over a given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.prod.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> prod(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.prod(inAxis);
    }
} // namespace nc

/*** End of inlined file: prod.hpp ***/

namespace nc
{

    // Method Description:
    /// Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanprod.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nanprod(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = static_cast<dtype>(1);
                                     };
                                 });

        return prod(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nanprod.hpp ***/


/*** Start of inlined file: nans.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with nans.
    /// Only really works for dtype = float/double
    ///
    /// @param inSquareSize
    /// @return NdArray
    ///
    inline NdArray<double> nans(uint32 inSquareSize)
    {
        return full(inSquareSize, constants::nan);
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with nans.
    /// Only really works for dtype = float/double
    ///
    /// @param inNumRows
    /// @param inNumCols
    /// @return NdArray
    ///
    inline NdArray<double> nans(uint32 inNumRows, uint32 inNumCols)
    {
        return full(inNumRows, inNumCols, constants::nan);
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with nans.
    /// Only really works for dtype = float/double
    ///
    /// @param inShape
    /// @return NdArray
    ///
    inline NdArray<double> nans(const Shape& inShape)
    {
        return full(inShape, constants::nan);
    }
} // namespace nc

/*** End of inlined file: nans.hpp ***/


/*** Start of inlined file: nans_like.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with nans.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> nans_like(const NdArray<dtype>& inArray)
    {
        NdArray<double> returnArray(inArray.shape());
        returnArray.nans();
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: nans_like.hpp ***/


/*** Start of inlined file: nanstdev.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>

namespace nc
{

    // Method Description:
    /// Compute the standard deviation along the specified axis, while ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanstd.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> nanstdev(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                double meanValue = nanmean(inArray, inAxis).item();
                double sum       = 0;
                double counter   = 0;
                for (auto value : inArray)
                {
                    if (std::isnan(value))
                    {
                        continue;
                    }

                    sum += utils::sqr(static_cast<double>(value) - meanValue);
                    ++counter;
                }
                NdArray<double> returnArray = { std::sqrt(sum / counter) };
                return returnArray;
            }
            case Axis::COL:
            {
                const Shape     inShape   = inArray.shape();
                NdArray<double> meanValue = nanmean(inArray, inAxis);
                NdArray<double> returnArray(1, inShape.rows);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    double sum     = 0;
                    double counter = 0;
                    for (uint32 col = 0; col < inShape.cols; ++col)
                    {
                        if (std::isnan(inArray(row, col)))
                        {
                            continue;
                        }

                        sum += utils::sqr(static_cast<double>(inArray(row, col)) - meanValue[row]);
                        ++counter;
                    }
                    returnArray(0, row) = std::sqrt(sum / counter);
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return nanstdev(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

} // namespace nc

/*** End of inlined file: nanstdev.hpp ***/


/*** Start of inlined file: nansum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>


/*** Start of inlined file: sum.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Sum of array elements over a given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sum.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> sum(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.sum(inAxis);
    }
} // namespace nc

/*** End of inlined file: sum.hpp ***/

namespace nc
{

    // Method Description:
    /// Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nansum.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nansum(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        NdArray<dtype> arrayCopy(inArray);
        stl_algorithms::for_each(arrayCopy.begin(),
                                 arrayCopy.end(),
                                 [](dtype& value) noexcept -> void
                                 {
                                     if (std::isnan(value))
                                     {
                                         value = static_cast<dtype>(0);
                                     };
                                 });

        return sum(arrayCopy, inAxis);
    }
} // namespace nc

/*** End of inlined file: nansum.hpp ***/


/*** Start of inlined file: nanvar.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Compute the variance along the specified axis, while ignoring NaNs.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nanvar.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> nanvar(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_FLOAT(dtype);

        return square(nanstdev(inArray, inAxis));
    }
} // namespace nc

/*** End of inlined file: nanvar.hpp ***/


/*** Start of inlined file: nbytes.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns the number of bytes held by the array
    ///
    /// @param inArray
    /// @return number of bytes
    ///
    template<typename dtype>
    uint64 nbytes(const NdArray<dtype>& inArray) noexcept
    {
        return inArray.nbytes();
    }
} // namespace nc

/*** End of inlined file: nbytes.hpp ***/


/*** Start of inlined file: negative.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Numerical negative, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.negative.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> negative(const NdArray<dtype>& inArray)
    {
        return -inArray;
    }
} // namespace nc

/*** End of inlined file: negative.hpp ***/


/*** Start of inlined file: newbyteorder.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the array with the same data viewed with a
    /// different byte order. only works for integer types,
    /// floating point types will not compile and you will
    /// be confused as to why...
    ///
    ///
    /// @param inValue
    /// @param inEndianess
    ///
    /// @return inValue
    ///
    template<typename dtype>
    dtype newbyteorder(dtype inValue, Endian inEndianess)
    {
        NdArray<dtype> valueArray = { inValue };
        return valueArray.newbyteorder(inEndianess).item();
    }

    // Method Description:
    /// Return the array with the same data viewed with a
    /// different byte order. only works for integer types,
    /// floating point types will not compile and you will
    /// be confused as to why...
    ///
    ///
    /// @param inArray
    /// @param inEndianess
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> newbyteorder(const NdArray<dtype>& inArray, Endian inEndianess)
    {
        return inArray.newbyteorder(inEndianess);
    }
} // namespace nc

/*** End of inlined file: newbyteorder.hpp ***/


/*** Start of inlined file: none.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Test whether no array elements along a given axis evaluate to True.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.all.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return bool
    ///
    template<typename dtype>
    NdArray<bool> none(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.none(inAxis);
    }
} // namespace nc

/*** End of inlined file: none.hpp ***/


/*** Start of inlined file: nonzero.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <utility>

namespace nc
{

    // Method Description:
    /// Return the indices of the flattened array of the
    /// elements that are non-zero.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.nonzero.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    std::pair<NdArray<uint32>, NdArray<uint32>> nonzero(const NdArray<dtype>& inArray)
    {
        return inArray.nonzero();
    }
} // namespace nc

/*** End of inlined file: nonzero.hpp ***/


/*** Start of inlined file: normalize.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Matrix or vector norm.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> normalize(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                return inArray / norm(inArray, Axis::NONE);
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(inArray.shape());
                const auto      cSlice = returnArray.cSlice();
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    returnArray.put(row, cSlice, normalize(inArray.row(row), Axis::NONE));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return normalize(inArray.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Matrix or vector norm.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> normalize(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                return inArray / norm(inArray, Axis::NONE);
            }
            case Axis::COL:
            {
                NdArray<std::complex<double>> returnArray(inArray.shape());
                const auto                    cSlice = returnArray.cSlice();
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    returnArray.put(row, cSlice, normalize(inArray.row(row), Axis::NONE));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return normalize(inArray.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: normalize.hpp ***/


/*** Start of inlined file: not_equal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return (x1 != x2) element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.not_equal.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> not_equal(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 != inArray2;
    }
} // namespace nc

/*** End of inlined file: not_equal.hpp ***/


/*** Start of inlined file: ones.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with ones.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ones.html
    ///
    /// @param inSquareSize
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ones(uint32 inSquareSize)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inSquareSize, inSquareSize, dtype{ 1 });
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with ones.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ones.html
    ///
    /// @param inNumRows
    /// @param inNumCols
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ones(uint32 inNumRows, uint32 inNumCols)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inNumRows, inNumCols, dtype{ 1 });
    }

    // Method Description:
    /// Return a new array of given shape and type, filled with ones.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ones.html
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ones(const Shape& inShape)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return full(inShape, dtype{ 1 });
    }
} // namespace nc

/*** End of inlined file: ones.hpp ***/


/*** Start of inlined file: outer.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>

namespace nc
{

    // Method Description:
    /// The outer product of two vectors.  Inputs are flattened if not already 1-dimensional.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.outer.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> outer(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto size = inArray1.size();

        if (size != inArray2.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Input arrays must be the same length");
        }

        auto returnArray = NdArray<dtype>(size);
        for (uint32 row = 0; row < size; ++row)
        {
            const auto array1Value = inArray1[row];

            std::transform(inArray2.begin(),
                           inArray2.end(),
                           returnArray.begin(row),
                           [array1Value](dtype value) -> dtype { return array1Value * value; });
        }

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: outer.hpp ***/


/*** Start of inlined file: packbits.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <type_traits>

namespace nc
{

    // Method Description:
    /// Packs the elements of a binary-valued array into bits in a uint8 array.
    ///
    /// Numpy Reference: https://numpy.org/doc/stable/reference/generated/numpy.packbits.html
    ///
    /// @param a: An array of integers or booleans whose elements should be packed to bits.
    /// @param axis: The dimension over which bit-packing is done. None implies packing the flattened array.
    /// @return NdArray<uint8>
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype> || std::is_same_v<dtype, bool>, int> = 0>
    NdArray<uint8> packbitsLittleEndian(const NdArray<dtype>& a, Axis axis = Axis::NONE)
    {
        switch (axis)
        {
            case Axis::NONE:
            {
                const auto numFullValues = a.size() / 8;
                const auto leftOvers     = a.size() % 8;
                const auto resultSize    = leftOvers == 0 ? numFullValues : numFullValues + 1;

                NdArray<uint8> result(1, resultSize);
                result.fill(0);

                for (typename NdArray<dtype>::size_type i = 0; i < numFullValues; ++i)
                {
                    const auto startIdx = i * 8;
                    for (auto bit = 0; bit < 8; ++bit)
                    {
                        auto value = static_cast<uint8>(a[startIdx + bit]);
                        value      = value == 0 ? 0 : 1;
                        result[i] |= (value << bit);
                    }
                }

                if (leftOvers != 0)
                {
                    const auto startIdx = numFullValues * 8;
                    for (std::remove_const_t<decltype(leftOvers)> bit = 0; bit < leftOvers; ++bit)
                    {
                        auto value = static_cast<uint8>(a[startIdx + bit]);
                        value      = value == 0 ? 0 : 1;
                        result.back() |= (value << bit);
                    }
                }

                return result;
            }
            case Axis::COL:
            {
                const auto aShape        = a.shape();
                const auto numFullValues = aShape.cols / 8;
                const auto leftOvers     = aShape.cols % 8;
                const auto resultSize    = leftOvers == 0 ? numFullValues : numFullValues + 1;

                NdArray<uint8> result(aShape.rows, resultSize);
                const auto     resultCSlice = result.cSlice();
                const auto     aCSlice      = a.cSlice();

                for (typename NdArray<dtype>::size_type row = 0; row < aShape.rows; ++row)
                {
                    result.put(row, resultCSlice, packbitsLittleEndian(a(row, aCSlice)));
                }

                return result;
            }
            case Axis::ROW:
            {
                return packbitsLittleEndian(a.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Packs the elements of a binary-valued array into bits in a uint8 array.
    ///
    /// Numpy Reference: https://numpy.org/doc/stable/reference/generated/numpy.packbits.html
    ///
    /// @param a: An array of integers or booleans whose elements should be packed to bits.
    /// @param axis: The dimension over which bit-packing is done. None implies packing the flattened array.
    /// @return NdArray<uint8>
    ///
    template<typename dtype, std::enable_if_t<std::is_integral_v<dtype> || std::is_same_v<dtype, bool>, int> = 0>
    NdArray<uint8> packbitsBigEndian(const NdArray<dtype>& a, Axis axis = Axis::NONE)
    {
        switch (axis)
        {
            case Axis::NONE:
            {
                const auto numFullValues = a.size() / 8;
                const auto leftOvers     = a.size() % 8;
                const auto resultSize    = leftOvers == 0 ? numFullValues : numFullValues + 1;

                NdArray<uint8> result(1, resultSize);
                result.fill(0);

                for (typename NdArray<dtype>::size_type i = 0; i < numFullValues; ++i)
                {
                    const auto startIdx = i * 8;
                    for (auto bit = 0; bit < 8; ++bit)
                    {
                        auto value = static_cast<uint8>(a[startIdx + bit]);
                        value      = value == 0 ? 0 : 1;
                        result[i] |= (value << (7 - bit));
                    }
                }

                if (leftOvers != 0)
                {
                    const auto startIdx = numFullValues * 8;
                    for (std::remove_const_t<decltype(leftOvers)> bit = 0; bit < leftOvers; ++bit)
                    {
                        auto value = static_cast<uint8>(a[startIdx + bit]);
                        value      = value == 0 ? 0 : 1;
                        result.back() |= (value << (7 - bit));
                    }
                }

                return result;
            }
            case Axis::COL:
            {
                const auto aShape        = a.shape();
                const auto numFullValues = aShape.cols / 8;
                const auto leftOvers     = aShape.cols % 8;
                const auto resultSize    = leftOvers == 0 ? numFullValues : numFullValues + 1;

                NdArray<uint8> result(aShape.rows, resultSize);
                const auto     resultCSlice = result.cSlice();
                const auto     aCSlice      = a.cSlice();

                for (typename NdArray<dtype>::size_type row = 0; row < aShape.rows; ++row)
                {
                    result.put(row, resultCSlice, packbitsBigEndian(a(row, aCSlice)));
                }

                return result;
            }
            case Axis::ROW:
            {
                return packbitsBigEndian(a.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

} // namespace nc

/*** End of inlined file: packbits.hpp ***/


/*** Start of inlined file: pad.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Pads an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.pad.html
    ///
    /// @param inArray
    /// @param inPadWidth
    /// @param inPadValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> pad(const NdArray<dtype>& inArray, uint16 inPadWidth, dtype inPadValue)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape = inArray.shape();
        Shape       outShape(inShape);
        outShape.rows += 2 * inPadWidth;
        outShape.cols += 2 * inPadWidth;

        NdArray<dtype> returnArray(outShape);
        returnArray.fill(inPadValue);
        returnArray.put(Slice(inPadWidth, inPadWidth + inShape.rows),
                        Slice(inPadWidth, inPadWidth + inShape.cols),
                        inArray);

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: pad.hpp ***/


/*** Start of inlined file: partition.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Rearranges the elements in the array in such a way that
    /// value of the element in kth position is in the position it
    /// would be in a sorted array. All elements smaller than the kth
    /// element are moved before this element and all equal or greater
    /// are moved behind it. The ordering of the elements in the two
    /// partitions is undefined.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.partition.html
    ///
    /// @param inArray
    /// @param inKth: kth element
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> partition(const NdArray<dtype>& inArray, uint32 inKth, Axis inAxis = Axis::NONE)
    {
        NdArray<dtype> returnArray(inArray);
        returnArray.partition(inKth, inAxis);
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: partition.hpp ***/


/*** Start of inlined file: place.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Change elements of an array based on conditional and input values.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.place.html
    ///
    /// @param arr: Array to put data into.
    /// @param mask: Boolean mask array. Must have the same size as arr
    /// @param vals: Values to put into a. Only the first N elements are used, where N is the
    ///              number of True values in mask. If vals is smaller than N, it will be repeated.
    ///
    template<typename dtype>
    void place(NdArray<dtype>& arr, const NdArray<bool>& mask, const NdArray<dtype>& vals)
    {
        if (mask.size() != arr.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Input arguments 'arr' and 'mask' must have the same size.");
        }

        if (vals.isempty())
        {
            return;
        }

        auto valIdx = 0;
        for (decltype(arr.size()) i = 0; i < arr.size(); ++i)
        {
            if (mask[i])
            {
                arr[i] = vals[valIdx++ % vals.size()];
            }
        }
    }
} // namespace nc

/*** End of inlined file: place.hpp ***/


/*** Start of inlined file: polar.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns a complex number with magnitude r and phase angle theta.
    ///
    /// @param magnitude
    /// @param phaseAngle
    ///
    /// @return std::complex
    ///
    template<typename dtype>
    auto polar(dtype magnitude, dtype phaseAngle)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::polar(magnitude, phaseAngle);
    }

    // Method Description:
    /// Returns a complex number with magnitude r and phase angle theta.
    ///
    /// @param magnitude
    /// @param phaseAngle
    /// @return NdArray<std::complex>
    ///
    template<typename dtype>
    auto polar(const NdArray<dtype>& magnitude, const NdArray<dtype>& phaseAngle)
    {
        if (magnitude.shape() != phaseAngle.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("Input magnitude and phaseAngle arrays must be the same shape");
        }

        NdArray<decltype(nc::polar(dtype{ 0 }, dtype{ 0 }))> returnArray(magnitude.shape());
        stl_algorithms::transform(magnitude.cbegin(),
                                  magnitude.cend(),
                                  phaseAngle.begin(),
                                  returnArray.begin(),
                                  [](dtype mag, dtype angle) -> auto { return nc::polar(mag, angle); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: polar.hpp ***/


/*** Start of inlined file: power.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Raises the elements of the array to the input integer power
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inValue
    /// @param inExponent
    /// @return value raised to the power
    ///
    template<typename dtype>
    constexpr dtype power(dtype inValue, uint8 inExponent) noexcept
    {
        return utils::power(inValue, inExponent);
    }

    // Method Description:
    /// Raises the elements of the array to the input integer power
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inArray
    /// @param inExponent
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> power(const NdArray<dtype>& inArray, uint8 inExponent)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inExponent](dtype inValue) noexcept -> dtype
                                  { return nc::power(inValue, inExponent); });

        return returnArray;
    }

    // Method Description:
    /// Raises the elements of the array to the input integer powers
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inArray
    /// @param inExponents
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> power(const NdArray<dtype>& inArray, const NdArray<uint8>& inExponents)
    {
        if (inArray.shape() != inExponents.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array shapes are not consistant.");
        }

        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  inExponents.cbegin(),
                                  returnArray.begin(),
                                  [](dtype inValue, uint8 inExponent) -> dtype
                                  { return nc::power(inValue, inExponent); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: power.hpp ***/


/*** Start of inlined file: powerf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Raises the elements of the array to the input floating point power
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inValue
    /// @param inExponent
    /// @return value raised to the power
    ///
    template<typename dtype1, typename dtype2>
    auto powerf(dtype1 inValue, dtype2 inExponent) noexcept
    {
        return utils::powerf(inValue, inExponent);
    }

    // Method Description:
    /// Raises the elements of the array to the input floating point power
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inArray
    /// @param inExponent
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto powerf(const NdArray<dtype1>& inArray, dtype2 inExponent)
    {
        NdArray<decltype(powerf(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inExponent](dtype1 inValue) noexcept -> auto
                                  { return nc::powerf(inValue, inExponent); });

        return returnArray;
    }

    // Method Description:
    /// Raises the elements of the array to the input floating point powers
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.power.html
    ///
    /// @param inArray
    /// @param inExponents
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto powerf(const NdArray<dtype1>& inArray, const NdArray<dtype2>& inExponents)
    {
        if (inArray.shape() != inExponents.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array shapes are not consistant.");
        }

        NdArray<decltype(powerf(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  inExponents.cbegin(),
                                  returnArray.begin(),
                                  [](dtype1 inValue, dtype2 inExponent) noexcept -> auto
                                  { return nc::powerf(inValue, inExponent); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: powerf.hpp ***/


/*** Start of inlined file: print.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <iostream>

namespace nc
{

    // Method Description:
    /// Prints the array to the console.
    ///
    /// @param inArray
    ///
    template<typename dtype>
    void print(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        std::cout << inArray;
    }
} // namespace nc

/*** End of inlined file: print.hpp ***/


/*** Start of inlined file: proj.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Returns the projection of the complex number z onto the Riemann sphere.
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto proj(const std::complex<dtype>& inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::proj(inValue);
    }

    // Method Description:
    /// Returns the projection of the complex number z onto the Riemann sphere.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto proj(const NdArray<std::complex<dtype>>& inArray)
    {
        NdArray<decltype(nc::proj(std::complex<dtype>{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](auto& inValue) -> auto { return nc::proj(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: proj.hpp ***/


/*** Start of inlined file: ptp.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Range of values (maximum - minimum) along an axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ptp.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> ptp(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        return inArray.ptp(inAxis);
    }
} // namespace nc

/*** End of inlined file: ptp.hpp ***/


/*** Start of inlined file: put.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// set the flat index element to the value
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inIndex
    /// @param inValue
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, int32 inIndex, const dtype& inValue)
    {
        inArray.put(inIndex, inValue);
        return inArray;
    }

    // Method Description:
    /// set the 2D row/col index element to the value
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRow
    /// @param inCol
    /// @param inValue
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, int32 inRow, int32 inCol, const dtype& inValue)
    {
        inArray.put(inRow, inCol, inValue);
        return inArray;
    }

    // Method Description:
    /// Set a.flat[n] = values for all n in indices.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inIndices
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Indices& inIndices, const dtype& inValue)
    {
        inArray.put(inIndices, inValue);
        return inArray;
    }

    // Method Description:
    /// Set a.flat[n] = values[n] for all n in indices.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inIndices
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Indices& inIndices, const NdArray<dtype>& inValues)
    {
        inArray.put(inIndices, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inSlice
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Slice& inSlice, const dtype& inValue)
    {
        inArray.put(inSlice, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inSlice
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Slice& inSlice, const NdArray<dtype>& inValues)
    {
        inArray.put(inSlice, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColIndices
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype,
             typename RowIndices,
             typename ColIndices,
             type_traits::ndarray_int_concept<RowIndices> = 0,
             type_traits::ndarray_int_concept<ColIndices> = 0>
    NdArray<dtype>& put(NdArray<dtype>&   inArray,
                        const RowIndices& inRowIndices,
                        const ColIndices& inColIndices,
                        const dtype&      inValue)
    {
        inArray.put(inRowIndices, inColIndices, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColSlice
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype, typename RowIndices, type_traits::ndarray_int_concept<RowIndices> = 0>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, const RowIndices& inRowIndices, const Slice& inColSlice, const dtype& inValue)
    {
        inArray.put(inRowIndices, inColSlice, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColIndices
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype, typename ColIndices, type_traits::ndarray_int_concept<ColIndices> = 0>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, const Slice& inRowSlice, const ColIndices& inColIndices, const dtype& inValue)
    {
        inArray.put(inRowSlice, inColIndices, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColSlice
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Slice& inRowSlice, const Slice& inColSlice, const dtype& inValue)
    {
        inArray.put(inRowSlice, inColSlice, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColIndex
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Indices& inRowIndices, int32 inColIndex, const dtype& inValue)
    {
        inArray.put(inRowIndices, inColIndex, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColIndex
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, const Slice& inRowSlice, int32 inColIndex, const dtype& inValue)
    {
        inArray.put(inRowSlice, inColIndex, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndex
    /// @param inColIndices
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>& put(NdArray<dtype>& inArray, int32 inRowIndex, const Indices& inColIndices, const dtype& inValue)
    {
        inArray.put(inRowIndex, inColIndices, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input value.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndex
    /// @param inColSlice
    /// @param inValue
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>& put(NdArray<dtype>& inArray, int32 inRowIndex, const Slice& inColSlice, const dtype& inValue)
    {
        inArray.put(inRowIndex, inColSlice, inValue);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColIndices
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype,
             typename RowIndices,
             typename ColIndices,
             type_traits::ndarray_int_concept<RowIndices> = 0,
             type_traits::ndarray_int_concept<ColIndices> = 0>
    NdArray<dtype>& put(NdArray<dtype>&       inArray,
                        const RowIndices&     inRowIndices,
                        const ColIndices&     inColIndices,
                        const NdArray<dtype>& inValues)
    {
        inArray.put(inRowIndices, inColIndices, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColSlice
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype, typename RowIndices, type_traits::ndarray_int_concept<RowIndices> = 0>
    NdArray<dtype>& put(NdArray<dtype>&       inArray,
                        const RowIndices&     inRowIndices,
                        const Slice&          inColSlice,
                        const NdArray<dtype>& inValues)
    {
        inArray.put(inRowIndices, inColSlice, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColIndices
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype, typename ColIndices, type_traits::ndarray_int_concept<ColIndices> = 0>
    NdArray<dtype>& put(NdArray<dtype>&       inArray,
                        const Slice&          inRowSlice,
                        const ColIndices&     inColIndices,
                        const NdArray<dtype>& inValues)
    {
        inArray.put(inRowSlice, inColIndices, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColSlice
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, const Slice& inRowSlice, const Slice& inColSlice, const NdArray<dtype>& inValues)
    {
        inArray.put(inRowSlice, inColSlice, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndices
    /// @param inColIndex
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, const Indices& inRowIndices, int32 inColIndex, const NdArray<dtype>& inValues)
    {
        inArray.put(inRowIndices, inColIndex, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowSlice
    /// @param inColIndex
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, const Slice& inRowSlice, int32 inColIndex, const NdArray<dtype>& inValues)
    {
        inArray.put(inRowSlice, inColIndex, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndex
    /// @param inColIndices
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, int32 inRowIndex, const Indices& inColIndices, const NdArray<dtype>& inValues)
    {
        inArray.put(inRowIndex, inColIndices, inValues);
        return inArray;
    }

    // Method Description:
    /// Set the slice indices to the input values.
    ///
    /// Numpy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.ndarray.put.html
    ///
    /// @param inArray
    /// @param inRowIndex
    /// @param inColSlice
    /// @param inValues
    /// @return reference to self
    ///
    template<typename dtype>
    NdArray<dtype>&
        put(NdArray<dtype>& inArray, int32 inRowIndex, const Slice& inColSlice, const NdArray<dtype>& inValues)
    {
        inArray.put(inRowIndex, inColSlice, inValues);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: put.hpp ***/


/*** Start of inlined file: putmask.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Changes elements of an array based on conditional and input values.
    ///
    /// Sets a.flat[n] = values[n] for each n where mask.flat[n] == True.
    ///
    /// If values is not the same size as a and mask then it will repeat.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.putmask.html
    ///
    /// @param inArray
    /// @param inMask
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& putmask(NdArray<dtype>& inArray, const NdArray<bool>& inMask, dtype inValue)
    {
        inArray.putMask(inMask, inValue);
        return inArray;
    }

    // Method Description:
    /// Changes elements of an array based on conditional and input values.
    ///
    /// Sets a.flat[n] = values[n] for each n where mask.flat[n] == True.
    ///
    /// If values is not the same size as a and mask then it will repeat.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.putmask.html
    ///
    /// @param inArray
    /// @param inMask
    /// @param inValues
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& putmask(NdArray<dtype>& inArray, const NdArray<bool>& inMask, const NdArray<dtype>& inValues)
    {
        inArray.putMask(inMask, inValues);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: putmask.hpp ***/


/*** Start of inlined file: radians.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.radians.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    constexpr auto radians(dtype inValue) noexcept
    {
        return deg2rad(inValue);
    }

    // Method Description:
    /// Convert angles from degrees to radians.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.radians.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto radians(const NdArray<dtype>& inArray)
    {
        return deg2rad(inArray);
    }
} // namespace nc

/*** End of inlined file: radians.hpp ***/


/*** Start of inlined file: ravel.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Flattens the array but does not make a copy.
    ///
    /// Numpy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& ravel(NdArray<dtype>& inArray) noexcept
    {
        inArray.ravel();
        return inArray;
    }
} // namespace nc

/*** End of inlined file: ravel.hpp ***/


/*** Start of inlined file: real.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Return the real part of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.real.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto real(const std::complex<dtype>& inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::real(inValue);
    }

    // Method Description:
    /// Return the real part of the complex argument.
    ///
    /// NumPy Reference: https://numpy.org/devdocs/reference/generated/numpy.real.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto real(const NdArray<std::complex<dtype>>& inArray)
    {
        NdArray<decltype(nc::real(std::complex<dtype>{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](auto& inValue) -> auto { return nc::real(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: real.hpp ***/


/*** Start of inlined file: reciprocal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// Return the reciprocal of the argument, element-wise.
    ///
    /// Calculates 1 / x.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.reciprocal.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> reciprocal(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<double> returnArray(inArray.shape());

        uint32 counter = 0;
        std::for_each(inArray.cbegin(),
                      inArray.cend(),
                      [&returnArray, &counter](dtype value) noexcept -> void
                      { returnArray[counter++] = 1. / static_cast<double>(value); });

        return returnArray;
    }

    // Method Description:
    /// Return the reciprocal of the argument, element-wise.
    ///
    /// Calculates 1 / x.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.reciprocal.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> reciprocal(const NdArray<std::complex<dtype>>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<std::complex<double>> returnArray(inArray.shape());

        uint32 counter = 0;
        std::for_each(inArray.cbegin(),
                      inArray.cend(),
                      [&returnArray, &counter](std::complex<dtype> value) -> void
                      { returnArray[counter++] = std::complex<double>(1.) / complex_cast<double>(value); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: reciprocal.hpp ***/


/*** Start of inlined file: remainder.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <string>

namespace nc
{

    // Method Description:
    /// Return remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.remainder.html
    ///
    /// @param inValue1
    /// @param inValue2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    double remainder(dtype inValue1, dtype inValue2) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return static_cast<double>(std::remainder(inValue1, inValue2));
    }

    // Method Description:
    /// Return element-wise remainder of division.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.remainder.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> remainder(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return broadcast::broadcaster<double>(inArray1,
                                              inArray2,
                                              [](dtype inValue1, dtype inValue2) noexcept -> double
                                              { return remainder(inValue1, inValue2); });
    }
} // namespace nc

/*** End of inlined file: remainder.hpp ***/


/*** Start of inlined file: repeat.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Repeat elements of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.repeat.html
    ///
    /// @param inArray
    /// @param inNumRows
    /// @param inNumCols
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> repeat(const NdArray<dtype>& inArray, uint32 inNumRows, uint32 inNumCols)
    {
        return inArray.repeat(inNumRows, inNumCols);
    }

    // Method Description:
    /// Repeat elements of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.repeat.html
    ///
    /// @param inArray
    /// @param inRepeatShape
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> repeat(const NdArray<dtype>& inArray, const Shape& inRepeatShape)
    {
        return inArray.repeat(inRepeatShape);
    }
} // namespace nc

/*** End of inlined file: repeat.hpp ***/


/*** Start of inlined file: replace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Replaces the matching elements of an array with the new value
    ///
    /// @param inArray
    /// @param oldValue: the value to replace
    /// @param newValue: the value to replace with
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> replace(const NdArray<dtype>& inArray, dtype oldValue, dtype newValue)
    {
        auto returnArray = inArray.copy();
        returnArray.replace(oldValue, newValue);
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: replace.hpp ***/


/*** Start of inlined file: reshape.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Gives a new shape to an array without changing its data.
    ///
    /// The new shape should be compatible with the original shape. If an single integer,
    /// then the result will be a 1-D array of that length. One shape dimension
    /// can be -1. In this case, the value is inferred from the length of the
    /// array and remaining dimensions.
    ///
    /// @param inArray
    /// @param inSize
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& reshape(NdArray<dtype>& inArray, uint32 inSize)
    {
        inArray.reshape(inSize);
        return inArray;
    }

    // Method Description:
    /// Gives a new shape to an array without changing its data.
    ///
    /// The new shape should be compatible with the original shape. If an single integer,
    /// then the result will be a 1-D array of that length. One shape dimension
    /// can be -1. In this case, the value is inferred from the length of the
    /// array and remaining dimensions.
    ///
    /// @param inArray
    /// @param inNumRows
    /// @param inNumCols
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& reshape(NdArray<dtype>& inArray, int32 inNumRows, int32 inNumCols)
    {
        inArray.reshape(inNumRows, inNumCols);
        return inArray;
    }

    // Method Description:
    /// Gives a new shape to an array without changing its data.
    ///
    /// The new shape should be compatible with the original shape. If an single integer,
    /// then the result will be a 1-D array of that length. One shape dimension
    /// can be -1. In this case, the value is inferred from the length of the
    /// array and remaining dimensions.
    ///
    /// @param inArray
    /// @param inNewShape
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& reshape(NdArray<dtype>& inArray, const Shape& inNewShape)
    {
        inArray.reshape(inNewShape);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: reshape.hpp ***/


/*** Start of inlined file: resizeFast.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Change shape and size of array in-place. All previous
    /// data of the array is lost.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.resize.html
    ///
    /// @param inArray
    /// @param inNumRows
    /// @param inNumCols
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& resizeFast(NdArray<dtype>& inArray, uint32 inNumRows, uint32 inNumCols)
    {
        inArray.resizeFast(inNumRows, inNumCols);
        return inArray;
    }

    // Method Description:
    /// Change shape and size of array in-place. All previous
    /// data of the array is lost.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.resize.html
    ///
    /// @param inArray
    /// @param inNewShape
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& resizeFast(NdArray<dtype>& inArray, const Shape& inNewShape)
    {
        inArray.resizeFast(inNewShape);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: resizeFast.hpp ***/


/*** Start of inlined file: resizeSlow.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array with the specified shape. If new shape
    /// is larger than old shape then array will be padded with zeros.
    /// If new shape is smaller than the old shape then the data will
    /// be discarded.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.resize.html
    ///
    /// @param inArray
    /// @param inNumRows
    /// @param inNumCols
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& resizeSlow(NdArray<dtype>& inArray, uint32 inNumRows, uint32 inNumCols)
    {
        inArray.resizeSlow(inNumRows, inNumCols);
        return inArray;
    }

    // Method Description:
    /// Return a new array with the specified shape. If new shape
    /// is larger than old shape then array will be padded with zeros.
    /// If new shape is smaller than the old shape then the data will
    /// be discarded.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.resize.html
    ///
    /// @param inArray
    /// @param inNewShape
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype>& resizeSlow(NdArray<dtype>& inArray, const Shape& inNewShape)
    {
        inArray.resizeSlow(inNewShape);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: resizeSlow.hpp ***/


/*** Start of inlined file: right_shift.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Shift the bits of an integer to the right.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.right_shift.html
    ///
    /// @param inArray
    /// @param inNumBits
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> right_shift(const NdArray<dtype>& inArray, uint8 inNumBits)
    {
        return inArray >> inNumBits;
    }
} // namespace nc

/*** End of inlined file: right_shift.hpp ***/


/*** Start of inlined file: rint.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Round value to the nearest integer.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.rint.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    dtype rint(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::rint(inValue);
    }

    // Method Description:
    /// Round elements of the array to the nearest integer.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.rint.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> rint(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return rint(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: rint.hpp ***/


/*** Start of inlined file: rms.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Compute the root mean square (RMS) along the specified axis.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> rms(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        double     squareSum = 0.;
        const auto function  = [&squareSum](dtype value) -> void
        { squareSum += utils::sqr(static_cast<double>(value)); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::for_each(inArray.cbegin(), inArray.cend(), function);
                NdArray<double> returnArray = { std::sqrt(squareSum / static_cast<double>(inArray.size())) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    squareSum = 0.;
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);
                    returnArray(0, row) = std::sqrt(squareSum / static_cast<double>(inArray.numCols()));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return rms(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Compute the root mean square (RMS) along the specified axis.
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> rms(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::complex<double> squareSum = 0.;
        const auto           function  = [&squareSum](std::complex<dtype> value) -> void
        { squareSum += utils::sqr(complex_cast<double>(value)); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                std::for_each(inArray.cbegin(), inArray.cend(), function);
                NdArray<std::complex<double>> returnArray = { std::sqrt(squareSum /
                                                                        static_cast<double>(inArray.size())) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<std::complex<double>> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    squareSum = std::complex<double>(0., 0.);
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);
                    returnArray(0, row) = std::sqrt(squareSum / static_cast<double>(inArray.numCols()));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return rms(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: rms.hpp ***/


/*** Start of inlined file: roll.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Roll array elements along a given axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.roll.html
    ///
    /// @param inArray
    /// @param inShift: (elements to shift, positive means forward, negative means backwards)
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> roll(const NdArray<dtype>& inArray, int32 inShift, Axis inAxis = Axis::NONE)
    {
        switch (inAxis)
        {
            case Axis::NONE:
            {
                uint32 shift = std::abs(inShift) % inArray.size();
                if (inShift > 0)
                {
                    shift = inArray.size() - shift;
                }

                NdArray<dtype> returnArray(inArray);
                stl_algorithms::rotate(returnArray.begin(), returnArray.begin() + shift, returnArray.end());

                return returnArray;
            }
            case Axis::COL:
            {
                const Shape inShape = inArray.shape();

                uint32 shift = std::abs(inShift) % inShape.cols;
                if (inShift > 0)
                {
                    shift = inShape.cols - shift;
                }

                NdArray<dtype> returnArray(inArray);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    stl_algorithms::rotate(returnArray.begin(row),
                                           returnArray.begin(row) + shift,
                                           returnArray.end(row));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return roll(inArray.transpose(), inShift, Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: roll.hpp ***/


/*** Start of inlined file: round.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Round value to the given number of decimals.
    ///
    /// @param inValue
    /// @param inDecimals
    ///
    /// @return value
    ///
    template<typename dtype>
    dtype round(dtype inValue, uint8 inDecimals = 0)
    {
        NdArray<dtype> input = { inValue };
        return input.round(inDecimals).item();
    }

    // Method Description:
    /// Round an array to the given number of decimals.
    ///
    /// @param inArray
    /// @param inDecimals
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> round(const NdArray<dtype>& inArray, uint8 inDecimals = 0)
    {
        return inArray.round(inDecimals);
    }
} // namespace nc

/*** End of inlined file: round.hpp ***/


/*** Start of inlined file: searchsorted.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <iterator>

namespace nc
{

    // Method Description:
    /// Find indices where elements should be inserted to maintain order.
    /// Find the indices into a sorted array a such that, if the corresponding elements in v were
    /// inserted before the indices, the order of a would be preserved.
    /// Assuming that a is sorted :
    ///    side     returned index i satisfies
    ///    left     a[i - 1] < v <= a[i]
    ///    right    a[i - 1] <= v < a[i]
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html
    ///
    /// @param inArray: the input array
    /// @param inValue: values to insert into a
    /// @param side: If ‘left’, the index of the first suitable location found is given. If ‘right’, return the
    ///              last such index. If there is no suitable index, return either 0 or N (where N is the length of a).
    /// @return Array of insertion points with the same shape as v, or an integer if v is a scalar.
    ///
    template<typename dtype>
    typename NdArray<dtype>::index_type
        searchsorted(const NdArray<dtype>& inArray, dtype inValue, Side side = Side::LEFT)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        switch (side)
        {
            case Side::LEFT:
            {
                return std::distance(inArray.begin(), std::lower_bound(inArray.begin(), inArray.end(), inValue));
            }
            case Side::RIGHT:
            {
                return std::distance(inArray.begin(), std::upper_bound(inArray.begin(), inArray.end(), inValue));
            }
        }

        // get rid of compiler warning
        return {};
    }

    // Method Description:
    /// Find indices where elements should be inserted to maintain order.
    /// Find the indices into a sorted array a such that, if the corresponding elements in v were
    /// inserted before the indices, the order of a would be preserved.
    /// Assuming that a is sorted :
    ///    side     returned index i satisfies
    ///    left     a[i - 1] < v <= a[i]
    ///    right    a[i - 1] <= v < a[i]
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html
    ///
    /// @param inArray: the input array
    /// @param inValues: values to insert into a
    /// @param side: If ‘left’, the index of the first suitable location found is given. If ‘right’, return the
    ///              last such index. If there is no suitable index, return either 0 or N (where N is the length of a).
    /// @return Array of insertion points with the same shape as v, or an integer if v is a scalar.
    ///
    template<typename dtype>
    NdArray<typename NdArray<dtype>::index_type>
        searchsorted(const NdArray<dtype>& inArray, const NdArray<dtype>& inValues, Side side = Side::LEFT)
    {
        NdArray<typename NdArray<dtype>::index_type> indices(1, inValues.size());
        std::transform(inValues.begin(),
                       inValues.end(),
                       indices.begin(),
                       [&inArray, side](const auto& value) { return searchsorted(inArray, value, side); });
        return indices;
    }
} // namespace nc

/*** End of inlined file: searchsorted.hpp ***/


/*** Start of inlined file: select.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cstdlib>
#include <initializer_list>
#include <limits>
#include <vector>

namespace nc
{

    // Method Description:
    /// Return an array drawn from elements in choiceVec, depending on conditions.
    ///
    /// NumPy Reference:
    /// https://numpy.org/doc/stable/reference/generated/numpy.select.html?highlight=select#numpy.select
    ///
    /// @param condVec The vector of conditions which determine from which array in choiceVec
    /// the output elements are taken. When multiple conditions are satisfied,
    /// the first one encountered in choiceVec is used.
    /// @param choiceVec The vector of array pointers from which the output elements are taken.
    /// It has to be of the same length as condVec.
    /// @param defaultValue The element inserted in output when all conditions evaluate to False
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> select(const std::vector<const NdArray<bool>*>&  condVec,
                          const std::vector<const NdArray<dtype>*>& choiceVec,
                          dtype                                     defaultValue = dtype{ 0 })
    {
        if (choiceVec.size() != condVec.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("condVec and choiceVec need to be the same size");
        }

        if (choiceVec.size() == 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("choiceVec is size 0");
        }

        auto theShape = condVec.front()->shape();
        for (const auto cond : condVec)
        {
            const auto& theCond = *cond;
            if (theCond.shape() != theShape)
            {
                THROW_INVALID_ARGUMENT_ERROR("all NdArrays of the condVec must be the same shape");
            }
        }

        for (const auto choice : choiceVec)
        {
            const auto& theChoice = *choice;
            if (theChoice.shape() != theShape)
            {
                THROW_INVALID_ARGUMENT_ERROR(
                    "all NdArrays of the choiceVec must be the same shape, and the same as condVec");
            }
        }

        using size_type           = typename NdArray<dtype>::size_type;
        constexpr auto nullChoice = std::numeric_limits<size_type>::max();

        NdArray<size_type> choiceIndices(theShape);
        choiceIndices.fill(nullChoice);
        for (size_type condIdx = 0; condIdx < condVec.size(); ++condIdx)
        {
            const auto& theCond = *condVec[condIdx];
            for (size_type i = 0; i < theCond.size(); ++i)
            {
                if (theCond[i] && choiceIndices[i] == nullChoice)
                {
                    choiceIndices[i] = condIdx;
                }
            }
        }

        NdArray<dtype> result(theShape);
        result.fill(defaultValue);
        for (size_type i = 0; i < choiceIndices.size(); ++i)
        {
            const auto choiceIndex = choiceIndices[i];
            if (choiceIndex != nullChoice)
            {
                const auto& theChoice = *choiceVec[choiceIndex];
                result[i]             = theChoice[i];
            }
        }

        return result;
    }

    // Method Description:
    /// Return an array drawn from elements in choiceList, depending on conditions.
    ///
    /// NumPy Reference:
    /// https://numpy.org/doc/stable/reference/generated/numpy.select.html?highlight=select#numpy.select
    ///
    /// @param condList The list of conditions which determine from which array in choiceList
    /// the output elements are taken. When multiple conditions are satisfied,
    /// the first one encountered in choiceList is used.
    /// @param choiceList The list of array pointers from which the output elements are taken.
    /// It has to be of the same length as condVec.
    /// @param defaultValue The element inserted in output when all conditions evaluate to False
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> select(const std::vector<NdArray<bool>>&  condList,
                          const std::vector<NdArray<dtype>>& choiceList,
                          dtype                              defaultValue = dtype{ 0 })
    {
        std::vector<const NdArray<bool>*> condVec(condList.size());
        stl_algorithms::transform(condList.begin(),
                                  condList.end(),
                                  condVec.begin(),
                                  [](auto& cond) noexcept -> const NdArray<bool>* { return &cond; });

        std::vector<const NdArray<dtype>*> choiceVec(choiceList.size());
        stl_algorithms::transform(choiceList.begin(),
                                  choiceList.end(),
                                  choiceVec.begin(),
                                  [](auto& choice) noexcept -> const NdArray<dtype>* { return &choice; });

        return select(condVec, choiceVec, defaultValue);
    }
} // namespace nc

/*** End of inlined file: select.hpp ***/


/*** Start of inlined file: setdiff1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>
#include <vector>

namespace nc
{

    // Method Description:
    /// Find the set difference of two arrays.
    ///
    /// Return the sorted, unique values in ar1 that are not in ar2.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.setdiff1d.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> setdiff1d(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto comp = [](const dtype lhs, const dtype rhs) noexcept -> bool { return lhs < rhs; };

        const auto set1 = unique(inArray1);
        const auto set2 = unique(inArray2);

        std::vector<dtype> res(set1.size());
        const auto         last =
            stl_algorithms::set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), res.begin(), comp);

        return NdArray<dtype>(res.begin(), last);
    }
} // namespace nc

/*** End of inlined file: setdiff1d.hpp ***/


/*** Start of inlined file: shape.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the shape of the array
    ///
    /// @param inArray
    /// @return Shape
    ///
    template<typename dtype>
    Shape shape(const NdArray<dtype>& inArray) noexcept
    {
        return inArray.shape();
    }
} // namespace nc

/*** End of inlined file: shape.hpp ***/


/*** Start of inlined file: signbit.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Returns element-wise True where signbit is set (less than zero).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.signbit.html
    ///
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    bool signbit(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return inValue < dtype{ 0 } ? true : false;
    }

    // Method Description:
    /// Returns element-wise True where signbit is set (less than zero).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.signbit.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<bool> signbit(const NdArray<dtype>& inArray)
    {
        NdArray<bool> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> bool { return signbit(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: signbit.hpp ***/


/*** Start of inlined file: sin.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Trigonometric sine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sin.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto sin(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::sin(inValue);
    }

    // Method Description:
    /// Trigonometric sine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sin.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto sin(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(sin(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return sin(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sin.hpp ***/


/*** Start of inlined file: sinc.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the sinc function.
    ///
    /// The sinc function is sin(pi*x) / (pi*x).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sinc.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto sinc(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::sin(constants::pi * inValue) / (constants::pi * inValue);
    }

    // Method Description:
    /// Return the sinc function.
    ///
    /// The sinc function is sin(pi*x) / (pi*x).
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sinc.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto sinc(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(sinc(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return sinc(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sinc.hpp ***/


/*** Start of inlined file: sinh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Hyperbolic sine.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sinh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto sinh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::sinh(inValue);
    }

    // Method Description:
    /// Hyperbolic sine, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.sinh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto sinh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(sinh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return sinh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: sinh.hpp ***/


/*** Start of inlined file: size.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the number of elements.
    ///
    /// @param inArray
    /// @return uint32 size
    ///
    template<typename dtype>
    uint32 size(const NdArray<dtype>& inArray) noexcept
    {
        return inArray.size();
    }
} // namespace nc

/*** End of inlined file: size.hpp ***/


/*** Start of inlined file: split.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <vector>


/*** Start of inlined file: vsplit.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <vector>

namespace nc
{

    // Method Description:
    /// Split an array into multiple sub-arrays vertically (row-wise).
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.vsplit.html
    ///
    /// @param inArray
    /// @param indices: the indices to split
    ///
    /// @return NdArray
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    std::vector<NdArray<dtype>> vsplit(const NdArray<dtype>& inArray, const Indices& indices)
    {
        const auto     numRows = static_cast<int32>(inArray.numRows());
        NdArray<int32> uniqueIndices(1, indices.size());
        stl_algorithms::transform(indices.begin(),
                                  indices.end(),
                                  uniqueIndices.begin(),
                                  [numRows](auto index) noexcept -> int32
                                  {
                                      if constexpr (type_traits::is_ndarray_signed_int_v<Indices>)
                                      {
                                          if (index < 0)
                                          {
                                              index = std::max(index + numRows, int32{ 0 });
                                          }
                                      }
                                      if (index > numRows - 1)
                                      {
                                          index = numRows - 1;
                                      }

                                      return static_cast<int32>(index);
                                  });
        uniqueIndices = unique(uniqueIndices);

        std::vector<NdArray<dtype>> splits{};
        splits.reserve(uniqueIndices.size() + 1);

        const auto cSlice   = inArray.cSlice();
        int32      lowerIdx = 0;
        for (const auto index : uniqueIndices)
        {
            if (index == 0)
            {
                splits.push_back(NdArray<dtype>(Shape(0, inArray.numCols())));
                continue;
            }
            else
            {
                splits.push_back(inArray(Slice(lowerIdx, index), cSlice));
            }

            lowerIdx = index;
        }

        if (lowerIdx < numRows - 1)
        {
            splits.push_back(inArray(Slice(lowerIdx, numRows), cSlice));
        }
        else
        {
            splits.push_back(inArray(-1, cSlice));
        }

        return splits;
    }
} // namespace nc

/*** End of inlined file: vsplit.hpp ***/

namespace nc
{

    // Method Description:
    /// Split an array into multiple sub-arrays as views into array.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.split.html
    ///
    /// @param inArray
    /// @param indices: the indices to split
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    std::vector<NdArray<dtype>> split(const NdArray<dtype>& inArray, const Indices& indices, Axis inAxis = Axis::ROW)
    {
        switch (inAxis)
        {
            case Axis::ROW:
            {
                return vsplit(inArray, indices);
            }
            case Axis::COL:
            {
                return hsplit(inArray, indices);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("input inAxis must be either Axis::ROW or Axis::COL");
            }
        }

        return {}; // get rid of compiler warning
    }
} // namespace nc

/*** End of inlined file: split.hpp ***/


/*** Start of inlined file: stack.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <string>
#include <vector>

namespace nc
{
    namespace detail
    {

        // Method Description:
        /// Compute the variance along the specified axis.
        ///
        /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.stack.html
        ///
        /// @param begin: iterator to the beginning of the span
        /// @param end: iterator to one past the end of the span
        /// @param inAxis: the axis to stack
        /// @return NdArray
        ///
        template<typename dtype, typename Iterator>
        NdArray<dtype> stack(Iterator begin, Iterator end, Axis inAxis)
        {
            switch (inAxis)
            {
                case Axis::ROW:
                {
                    return row_stack<dtype>(begin, end);
                }
                case Axis::COL:
                {
                    return column_stack<dtype>(begin, end);
                }
                default:
                {
                    THROW_INVALID_ARGUMENT_ERROR("inAxis must be either ROW or COL.");
                    return {}; // getting rid of compiler warning
                }
            }
        }
    } // namespace detail

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.stack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    /// @param inAxis: axis to stack the input NdArrays
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> stack(std::initializer_list<NdArray<dtype>> inArrayList, Axis inAxis = Axis::NONE)
    {
        return detail::stack<dtype>(inArrayList.begin(), inArrayList.end(), inAxis);
    }

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.stack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    /// @param inAxis: axis to stack the input NdArrays
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> stack(std::vector<NdArray<dtype>> inArrayList, Axis inAxis = Axis::NONE)
    {
        return detail::stack<dtype>(inArrayList.begin(), inArrayList.end(), inAxis);
    }
} // namespace nc

/*** End of inlined file: stack.hpp ***/


/*** Start of inlined file: stdev.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Compute the standard deviation along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.std.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> stdev(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        double meanValue = 0.;
        double sum       = 0.;

        const auto function = [&sum, &meanValue](dtype value) -> void
        { sum += utils::sqr(static_cast<double>(value) - meanValue); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                meanValue = mean(inArray, inAxis).item();
                std::for_each(inArray.cbegin(), inArray.cend(), function);

                NdArray<double> returnArray = { std::sqrt(sum / inArray.size()) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> meanValueArray = mean(inArray, inAxis);
                NdArray<double> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    meanValue = meanValueArray[row];
                    sum       = 0.;
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);

                    returnArray(0, row) = std::sqrt(sum / inArray.numCols());
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return stdev(inArray.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Compute the standard deviation along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.std.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> stdev(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::complex<double> meanValue(0., 0.);
        std::complex<double> sum(0., 0.);

        const auto function = [&sum, &meanValue](std::complex<dtype> value) -> void
        { sum += utils::sqr(complex_cast<double>(value) - meanValue); };

        switch (inAxis)
        {
            case Axis::NONE:
            {
                meanValue = mean(inArray, inAxis).item();
                std::for_each(inArray.cbegin(), inArray.cend(), function);

                NdArray<std::complex<double>> returnArray = { std::sqrt(sum / static_cast<double>(inArray.size())) };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<std::complex<double>> meanValueArray = mean(inArray, inAxis);
                NdArray<std::complex<double>> returnArray(1, inArray.numRows());
                for (uint32 row = 0; row < inArray.numRows(); ++row)
                {
                    meanValue = meanValueArray[row];
                    sum       = std::complex<double>(0., 0.);
                    std::for_each(inArray.cbegin(row), inArray.cend(row), function);

                    returnArray(0, row) = std::sqrt(sum / static_cast<double>(inArray.numCols()));
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                NdArray<std::complex<double>> meanValueArray  = mean(inArray, inAxis);
                NdArray<std::complex<dtype>>  transposedArray = inArray.transpose();
                NdArray<std::complex<double>> returnArray(1, transposedArray.numRows());
                for (uint32 row = 0; row < transposedArray.numRows(); ++row)
                {
                    meanValue = meanValueArray[row];
                    sum       = std::complex<double>(0., 0.);
                    std::for_each(transposedArray.cbegin(row), transposedArray.cend(row), function);

                    returnArray(0, row) = std::sqrt(sum / static_cast<double>(transposedArray.numCols()));
                }

                return returnArray;
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: stdev.hpp ***/


/*** Start of inlined file: subtract.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <complex>

namespace nc
{

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> subtract(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 - inArray2;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> subtract(const NdArray<dtype>& inArray, dtype value)
    {
        return inArray - value;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> subtract(dtype value, const NdArray<dtype>& inArray)
    {
        return value - inArray;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(const NdArray<dtype>& inArray1, const NdArray<std::complex<dtype>>& inArray2)
    {
        return inArray1 - inArray2;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray1
    /// @param inArray2
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(const NdArray<std::complex<dtype>>& inArray1, const NdArray<dtype>& inArray2)
    {
        return inArray1 - inArray2;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(const NdArray<dtype>& inArray, const std::complex<dtype>& value)
    {
        return inArray - value;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(const std::complex<dtype>& value, const NdArray<dtype>& inArray)
    {
        return value - inArray;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param inArray
    /// @param value
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(const NdArray<std::complex<dtype>>& inArray, dtype value)
    {
        return inArray - value;
    }

    // Method Description:
    /// subtract arguments element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.subtract.html
    ///
    /// @param value
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<dtype>> subtract(dtype value, const NdArray<std::complex<dtype>>& inArray)
    {
        return value - inArray;
    }
} // namespace nc

/*** End of inlined file: subtract.hpp ***/


/*** Start of inlined file: swap.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Swaps the contents of two arrays
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    template<typename dtype>
    void swap(NdArray<dtype>& inArray1, NdArray<dtype>& inArray2) noexcept
    {
        NdArray<dtype> tmp(std::move(inArray1));
        inArray1 = std::move(inArray2);
        inArray2 = std::move(tmp);
    }
} // namespace nc

/*** End of inlined file: swap.hpp ***/


/*** Start of inlined file: swapCols.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Swaps cols of the array
    ///
    /// @param inArray
    /// @param colIdx1
    /// @param colIdx2
    ///
    template<typename dtype>
    NdArray<dtype>& swapCols(NdArray<dtype>& inArray, int32 colIdx1, int32 colIdx2) noexcept
    {
        inArray.swapCols(colIdx1, colIdx2);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: swapCols.hpp ***/


/*** Start of inlined file: swapRows.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Swaps rows of the array
    ///
    /// @param inArray
    /// @param rowIdx1
    /// @param rowIdx2
    ///
    template<typename dtype>
    NdArray<dtype>& swapRows(NdArray<dtype>& inArray, int32 rowIdx1, int32 rowIdx2) noexcept
    {
        inArray.swapRows(rowIdx1, rowIdx2);
        return inArray;
    }
} // namespace nc

/*** End of inlined file: swapRows.hpp ***/


/*** Start of inlined file: swapaxes.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Interchange two axes of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.swapaxes.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> swapaxes(const NdArray<dtype>& inArray)
    {
        return inArray.swapaxes();
    }
} // namespace nc

/*** End of inlined file: swapaxes.hpp ***/


/*** Start of inlined file: take.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Evenly round to the given number of decimals.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.take.html
    ///
    /// @param inArray
    /// @param inIndices
    /// @param inAxis
    /// @return NdArray
    ///
    template<typename dtype, typename Indices, type_traits::ndarray_int_concept<Indices> = 0>
    NdArray<dtype> take(const NdArray<dtype>& inArray, const Indices& inIndices, Axis inAxis = Axis::NONE)
    {
        switch (inAxis)
        {
            case Axis::NONE:
            {
                return inArray[inIndices];
            }
            case Axis::ROW:
            {
                return inArray(inIndices, inArray.cSlice());
            }
            case Axis::COL:
            {
                return inArray(inArray.rSlice(), inIndices);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

} // namespace nc

/*** End of inlined file: take.hpp ***/


/*** Start of inlined file: tan.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Compute tangent.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tan.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto tan(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::tan(inValue);
    }

    // Method Description:
    /// Compute tangent element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tan.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto tan(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(tan(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return tan(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: tan.hpp ***/


/*** Start of inlined file: tanh.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <complex>

namespace nc
{

    // Method Description:
    /// Compute hyperbolic tangent.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tanh.html
    ///
    /// @param inValue
    /// @return value
    ///
    template<typename dtype>
    auto tanh(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return std::tanh(inValue);
    }

    // Method Description:
    /// Compute hyperbolic tangent element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tanh.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto tanh(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(tanh(dtype{ 0 }))> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> auto { return tanh(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: tanh.hpp ***/


/*** Start of inlined file: tile.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Construct an array by repeating A the number of times given by reps.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tile.html
    ///
    /// @param inArray
    /// @param inNumRows
    /// @param inNumCols
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> tile(const NdArray<dtype>& inArray, uint32 inNumRows, uint32 inNumCols)
    {
        return inArray.repeat(inNumRows, inNumCols);
    }

    // Method Description:
    /// Construct an array by repeating A the number of times given by reps.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tile.html
    ///
    /// @param inArray
    /// @param inReps
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> tile(const NdArray<dtype>& inArray, const Shape& inReps)
    {
        return inArray.repeat(inReps);
    }
} // namespace nc

/*** End of inlined file: tile.hpp ***/


/*** Start of inlined file: toStlVector.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Write flattened array to an STL vector
    ///
    /// @param inArray
    /// @return std::vector
    ///
    template<typename dtype>
    std::vector<dtype> toStlVector(const NdArray<dtype>& inArray)
    {
        return inArray.toStlVector();
    }
} // namespace nc

/*** End of inlined file: toStlVector.hpp ***/


/*** Start of inlined file: tofile.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Write array to a file as binary.
    /// The data produced by this method can be recovered
    /// using the function fromfile().
    ///
    /// @param inArray
    /// @param inFilename
    ///
    template<typename dtype>
    void tofile(const NdArray<dtype>& inArray, const std::string& inFilename)
    {
        return inArray.tofile(inFilename);
    }

    // Method Description:
    /// Write array to a file as text.
    /// The data produced by this method can be recovered
    /// using the function fromfile().
    ///
    /// @param inArray
    /// @param inFilename
    /// @param inSep: Separator between array items for text output.
    ///
    template<typename dtype>
    void tofile(const NdArray<dtype>& inArray, const std::string& inFilename, const char inSep)
    {
        return inArray.tofile(inFilename, inSep);
    }
} // namespace nc

/*** End of inlined file: tofile.hpp ***/


/*** Start of inlined file: trace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return the sum along diagonals of the array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trace.html
    ///
    /// @param inArray
    /// @param inOffset: (Offset from main diaganol, default = 0, negative=above, positve=below)
    /// @param inAxis (Optional, default ROW)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype trace(const NdArray<dtype>& inArray, int16 inOffset = 0, Axis inAxis = Axis::ROW) noexcept
    {
        return inArray.trace(inOffset, inAxis);
    }
} // namespace nc

/*** End of inlined file: trace.hpp ***/


/*** Start of inlined file: transpose.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Permute the dimensions of an array.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.transpose.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> transpose(const NdArray<dtype>& inArray)
    {
        return inArray.transpose();
    }
} // namespace nc

/*** End of inlined file: transpose.hpp ***/


/*** Start of inlined file: trapz.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Integrate along the given axis using the composite trapezoidal rule.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trapz.html
    ///
    /// @param inArray
    /// @param dx: (Optional defaults to 1.)
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> trapz(const NdArray<dtype>& inArray, double dx = 1., Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const Shape inShape = inArray.shape();
        switch (inAxis)
        {
            case Axis::NONE:
            {
                double sum = 0.;
                for (uint32 i = 0; i < inArray.size() - 1; ++i)
                {
                    sum += static_cast<double>(inArray[i + 1] - inArray[i]) / 2. + static_cast<double>(inArray[i]);
                }

                NdArray<double> returnArray = { sum * dx };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(inShape.rows, 1);
                for (uint32 row = 0; row < inShape.rows; ++row)
                {
                    double sum = 0;
                    for (uint32 col = 0; col < inShape.cols - 1; ++col)
                    {
                        sum += static_cast<double>(inArray(row, col + 1) - inArray(row, col)) / 2. +
                               static_cast<double>(inArray(row, col));
                    }

                    returnArray[row] = sum * dx;
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return trapz(inArray.transpose(), dx, Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Integrate along the given axis using the composite trapezoidal rule.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trapz.html
    ///
    /// @param inArrayY
    /// @param inArrayX
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> trapz(const NdArray<dtype>& inArrayY, const NdArray<dtype>& inArrayX, Axis inAxis = Axis::NONE)
    {
        const Shape inShapeY = inArrayY.shape();
        const Shape inShapeX = inArrayX.shape();

        if (inShapeY != inShapeX)
        {
            THROW_INVALID_ARGUMENT_ERROR("input x and y arrays should be the same shape.");
        }

        switch (inAxis)
        {
            case Axis::NONE:
            {
                double sum = 0.;
                for (uint32 i = 0; i < inArrayY.size() - 1; ++i)
                {
                    const auto dx = static_cast<double>(inArrayX[i + 1] - inArrayX[i]);
                    sum += dx *
                           (static_cast<double>(inArrayY[i + 1] - inArrayY[i]) / 2. + static_cast<double>(inArrayY[i]));
                }

                NdArray<double> returnArray = { sum };
                return returnArray;
            }
            case Axis::COL:
            {
                NdArray<double> returnArray(inShapeY.rows, 1);
                for (uint32 row = 0; row < inShapeY.rows; ++row)
                {
                    double sum = 0;
                    for (uint32 col = 0; col < inShapeY.cols - 1; ++col)
                    {
                        const auto dx = static_cast<double>(inArrayX(row, col + 1) - inArrayX(row, col));
                        sum += dx * (static_cast<double>(inArrayY(row, col + 1) - inArrayY(row, col)) / 2. +
                                     static_cast<double>(inArrayY(row, col)));
                    }

                    returnArray[row] = sum;
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                return trapz(inArrayY.transpose(), inArrayX.transpose(), Axis::COL);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc

/*** End of inlined file: trapz.hpp ***/


/*** Start of inlined file: tri.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// An array with ones at and below the given diagonal and zeros elsewhere.
    ///
    /// @param inN: number of rows and cols
    /// @param inOffset: (the sub-diagonal at and below which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> tril(uint32 inN, int32 inOffset = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        uint32 rowStart = 0;
        uint32 colStart = 0;
        if (inOffset > 0)
        {
            colStart = inOffset;
        }
        else
        {
            rowStart = inOffset * -1;
        }

        NdArray<dtype> returnArray(inN);
        returnArray.zeros();
        for (uint32 row = rowStart; row < inN; ++row)
        {
            for (uint32 col = 0; col < row + colStart + 1 - rowStart; ++col)
            {
                if (col == inN)
                {
                    break;
                }

                returnArray(row, col) = dtype{ 1 };
            }
        }

        return returnArray;
    }

    // Method Description:
    /// An array with ones at and below the given diagonal and zeros elsewhere.
    ///
    /// @param inN: number of rows
    /// @param inM: number of columns
    /// @param inOffset: (the sub-diagonal at and below which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> tril(uint32 inN, uint32 inM, int32 inOffset = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        uint32 rowStart = 0;
        uint32 colStart = 0;
        if (inOffset > 0)
        {
            colStart = inOffset;
        }
        else if (inOffset < 0)
        {
            rowStart = inOffset * -1;
        }

        NdArray<dtype> returnArray(inN, inM);
        returnArray.zeros();
        for (uint32 row = rowStart; row < inN; ++row)
        {
            for (uint32 col = 0; col < row + colStart + 1 - rowStart; ++col)
            {
                if (col == inM)
                {
                    break;
                }

                returnArray(row, col) = dtype{ 1 };
            }
        }

        return returnArray;
    }

    // forward declare
    template<typename dtype>
    NdArray<dtype> triu(uint32 inN, uint32 inM, int32 inOffset = 0);

    // Method Description:
    /// Lower triangle of an array.
    ///
    /// Return a copy of an array with elements above the k - th diagonal zeroed.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.tril.html
    ///
    /// @param inArray: number of rows and cols
    /// @param inOffset: (the sub-diagonal at and below which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> tril(const NdArray<dtype>& inArray, int32 inOffset = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape  = inArray.shape();
        auto        outArray = inArray.copy();
        outArray.putMask(triu<bool>(inShape.rows, inShape.cols, inOffset + 1), 0);
        return outArray;
    }

    // Method Description:
    /// An array with ones at and above the given diagonal and zeros elsewhere.
    ///
    /// @param inN: number of rows
    /// @param inM: number of columns
    /// @param inOffset: (the sub-diagonal at and above which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> triu(uint32 inN, uint32 inM, int32 inOffset)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        // because i'm stealing the lines of code from tril and reversing it, this is necessary
        inOffset -= 1;

        uint32 rowStart = 0;
        uint32 colStart = 0;
        if (inOffset > 0)
        {
            colStart = inOffset;
        }
        else if (inOffset < 0)
        {
            rowStart = inOffset * -1;
        }

        NdArray<dtype> returnArray(inN, inM);
        returnArray.ones();
        for (uint32 row = rowStart; row < inN; ++row)
        {
            for (uint32 col = 0; col < row + colStart + 1 - rowStart; ++col)
            {
                if (col == inM)
                {
                    break;
                }

                returnArray(row, col) = dtype{ 0 };
            }
        }

        return returnArray;
    }

    // Method Description:
    /// An array with ones at and above the given diagonal and zeros elsewhere.
    ///
    /// @param inN: number of rows and cols
    /// @param inOffset: (the sub-diagonal at and above which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> triu(uint32 inN, int32 inOffset = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        return tril<dtype>(inN, -inOffset).transpose();
    }

    // Method Description:
    /// Upper triangle of an array.
    ///
    /// Return a copy of an array with elements below the k - th diagonal zeroed.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.triu.html
    ///
    /// @param inArray: number of rows and cols
    /// @param inOffset: (the sub-diagonal at and below which the array is filled.
    /// k = 0 is the main diagonal, while k < 0 is below it,
    /// and k > 0 is above. The default is 0.)
    ///
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> triu(const NdArray<dtype>& inArray, int32 inOffset = 0)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape  = inArray.shape();
        auto        outArray = inArray.copy();
        outArray.putMask(tril<bool>(inShape.rows, inShape.cols, inOffset - 1), 0);
        return outArray;
    }
} // namespace nc

/*** End of inlined file: tri.hpp ***/


/*** Start of inlined file: trim_zeros.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Trim the leading and/or trailing zeros from a 1-D array or sequence.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trim_zeros.html
    ///
    /// @param inArray
    /// @param inTrim: ("f" = front, "b" = back, "fb" = front and back)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> trim_zeros(const NdArray<dtype>& inArray, const std::string& inTrim = "fb")
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        if (inTrim == "f")
        {
            uint32 place = 0;
            for (auto value : inArray)
            {
                if (!utils::essentiallyEqual(value, dtype{ 0 }))
                {
                    break;
                }

                ++place;
            }

            if (place == inArray.size())
            {
                return NdArray<dtype>(0);
            }

            NdArray<dtype> returnArray(1, inArray.size() - place);
            stl_algorithms::copy(inArray.cbegin() + place, inArray.cend(), returnArray.begin());

            return returnArray;
        }

        if (inTrim == "b")
        {
            uint32 place = inArray.size();
            for (uint32 i = inArray.size() - 1; i > 0; --i)
            {
                if (!utils::essentiallyEqual(inArray[i], dtype{ 0 }))
                {
                    break;
                }

                --place;
            }

            if (place == 0 || (place == 1 && utils::essentiallyEqual(inArray[0], dtype{ 0 })))
            {
                return NdArray<dtype>(0);
            }

            NdArray<dtype> returnArray(1, place);
            stl_algorithms::copy(inArray.cbegin(), inArray.cbegin() + place, returnArray.begin());

            return returnArray;
        }

        if (inTrim == "fb")
        {
            uint32 placeBegin = 0;
            for (auto value : inArray)
            {
                if (!utils::essentiallyEqual(value, dtype{ 0 }))
                {
                    break;
                }

                ++placeBegin;
            }

            if (placeBegin == inArray.size())
            {
                return NdArray<dtype>(0);
            }

            uint32 placeEnd = inArray.size();
            for (uint32 i = inArray.size() - 1; i > 0; --i)
            {
                if (!utils::essentiallyEqual(inArray[i], dtype{ 0 }))
                {
                    break;
                }

                --placeEnd;
            }

            if (placeEnd == 0 || (placeEnd == 1 && utils::essentiallyEqual(inArray[0], dtype{ 0 })))
            {
                return NdArray<dtype>(0);
            }

            NdArray<dtype> returnArray(1, placeEnd - placeBegin);
            stl_algorithms::copy(inArray.cbegin() + placeBegin, inArray.cbegin() + placeEnd, returnArray.begin());

            return returnArray;
        }

        THROW_INVALID_ARGUMENT_ERROR("trim options are 'f' = front, 'b' = back, 'fb' = front and back.");
        return {};
    }
} // namespace nc

/*** End of inlined file: trim_zeros.hpp ***/


/*** Start of inlined file: trunc.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Return the truncated value of the input.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trunc.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    dtype trunc(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return std::trunc(inValue);
    }

    // Method Description:
    /// Return the truncated value of the input, element-wise.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.trunc.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> trunc(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return trunc(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: trunc.hpp ***/


/*** Start of inlined file: union1d.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Find the union of two arrays.
    ///
    /// Return the unique, sorted array of values that are in
    /// either of the two input arrays.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.union1d.html
    ///
    /// @param inArray1
    /// @param inArray2
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> union1d(const NdArray<dtype>& inArray1, const NdArray<dtype>& inArray2)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const auto comp = [](const dtype lhs, const dtype rhs) noexcept -> bool { return lhs < rhs; };

        const auto set1 = unique(inArray1);
        const auto set2 = unique(inArray2);

        std::vector<dtype> res(set1.size() + set2.size());
        const auto         last =
            stl_algorithms::set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), res.begin(), comp);

        return NdArray<dtype>(res.begin(), last);
    }
} // namespace nc

/*** End of inlined file: union1d.hpp ***/


/*** Start of inlined file: unpackbits.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <type_traits>

namespace nc
{

    // Method Description:
    /// Unpacks elements of a uint8 array into a binary-valued output array.
    ///
    /// Each element of a represents a bit - field that should be unpacked into a binary -
    /// valued output array.The shape of the output array is either 1 - D(if axis is None) or
    /// the same shape as the input array with unpacking done along the axis specified.
    ///
    /// Numpy Reference: https://numpy.org/doc/stable/reference/generated/numpy.unpackbits.html
    ///
    /// @param a: An array of uint8 whose elements should be unpacked to bits.
    /// @param axis: The dimension over which bit-unpacking is done. None implies unpacking the flattened array.
    /// @return NdArray<uint8>
    ///
    inline NdArray<uint8> unpackbitsLittleEndian(const NdArray<uint8>& a, Axis axis = Axis::NONE)
    {
        switch (axis)
        {
            case Axis::NONE:
            {
                NdArray<uint8> result(1, a.size() * 8);

                for (NdArray<uint8>::size_type byte = 0; byte < a.size(); ++byte)
                {
                    const auto startIdx  = byte * 8;
                    const auto byteValue = a[byte];

                    for (uint8 bit = 0; bit < 8; ++bit)
                    {
                        result[startIdx + bit] = static_cast<uint8>((byteValue & (uint8{ 1 } << bit)) >> bit);
                    }
                }

                return result;
            }
            case Axis::COL:
            {
                const auto     aShape = a.shape();
                NdArray<uint8> result(aShape.rows, aShape.cols * 8);
                const auto     resultCSlice = result.cSlice();
                const auto     aCSlice      = a.cSlice();

                for (NdArray<uint8>::size_type row = 0; row < aShape.rows; ++row)
                {
                    result.put(row, resultCSlice, unpackbitsLittleEndian(a(row, aCSlice)));
                }

                return result;
            }
            case Axis::ROW:
            {
                return unpackbitsLittleEndian(a.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

    // Method Description:
    /// Unpacks elements of a uint8 array into a binary-valued output array.
    ///
    /// Each element of a represents a bit - field that should be unpacked into a binary -
    /// valued output array.The shape of the output array is either 1 - D(if axis is None) or
    /// the same shape as the input array with unpacking done along the axis specified.
    ///
    /// Numpy Reference: https://numpy.org/doc/stable/reference/generated/numpy.unpackbits.html
    ///
    /// @param a: An array of uint8 whose elements should be unpacked to bits.
    /// @param axis: The dimension over which bit-unpacking is done. None implies unpacking the flattened array.
    /// @return NdArray<uint8>
    ///
    inline NdArray<uint8> unpackbitsBigEndian(const NdArray<uint8>& a, Axis axis = Axis::NONE)
    {
        switch (axis)
        {
            case Axis::NONE:
            {
                NdArray<uint8> result(1, a.size() * 8);

                for (NdArray<uint8>::size_type byte = 0; byte < a.size(); ++byte)
                {
                    const auto startIdx  = byte * 8;
                    const auto byteValue = a[byte];

                    for (uint8 bit = 0; bit < 8; ++bit)
                    {
                        const auto bitToMask = static_cast<uint8>(7 - bit);
                        result[startIdx + bit] =
                            static_cast<uint8>((byteValue & (uint8{ 1 } << bitToMask)) >> bitToMask);
                    }
                }

                return result;
            }
            case Axis::COL:
            {
                const auto     aShape = a.shape();
                NdArray<uint8> result(aShape.rows, aShape.cols * 8);
                const auto     resultCSlice = result.cSlice();
                const auto     aCSlice      = a.cSlice();

                for (NdArray<uint8>::size_type row = 0; row < aShape.rows; ++row)
                {
                    result.put(row, resultCSlice, unpackbitsBigEndian(a(row, aCSlice)));
                }

                return result;
            }
            case Axis::ROW:
            {
                return unpackbitsBigEndian(a.transpose(), Axis::COL).transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }

} // namespace nc

/*** End of inlined file: unpackbits.hpp ***/


/*** Start of inlined file: unwrap.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>

namespace nc
{

    // Method Description:
    /// Unwrap by changing deltas between values to 2*pi complement.
    /// Unwraps to [-pi, pi].
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.unwrap.html
    ///
    /// @param inValue
    ///
    /// @return value
    ///
    template<typename dtype>
    dtype unwrap(dtype inValue) noexcept
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return static_cast<dtype>(std::atan2(std::sin(inValue), std::cos(inValue)));
    }

    // Method Description:
    /// Unwrap by changing deltas between values to 2*pi complement.
    /// Unwraps to [-pi, pi].
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.unwrap.html
    ///
    /// @param inArray
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> unwrap(const NdArray<dtype>& inArray)
    {
        NdArray<dtype> returnArray(inArray.shape());
        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) noexcept -> dtype { return unwrap(inValue); });

        return returnArray;
    }
} // namespace nc

/*** End of inlined file: unwrap.hpp ***/


/*** Start of inlined file: vander.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <cmath>
#include <utility>

namespace nc
{

    // Method Description:
    /// Generate a Vandermonde matrix.
    /// The columns of the output matrix are powers of the input vector. The order of the powers is determined by the
    /// increasing boolean argument. Specifically, when increasing is False, the i-th output column is the input vector
    /// raised element-wise to the power of N - i - 1. Such a matrix with a geometric progression in each row is named
    /// for Alexandre- Theophile Vandermonde.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.vander.html
    ///
    /// @param x: 1-D input array, otherwise the array will be flattened
    /// @param n: Number of columns in the output. If N is not specified, a square array is returned (N = len(x)).
    /// @param increasing: Order of the powers of the columns. If True, the powers increase from left to right, if False
    /// (the default) they are reversed.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto vander(const NdArray<dtype>& x, uint32 n, Increasing increasing = Increasing::YES)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<decltype(std::pow(std::declval<dtype>(), uint32{ 0 }))> result(x.size(), n);
        for (uint32 row = 0; row < x.size(); ++row)
        {
            for (uint32 col = 0; col < n; ++col)
            {
                result(row, col) = std::pow(x[row], col);
            }
        }

        if (increasing == Increasing::NO)
        {
            return fliplr(result);
        }

        return result;
    }

    // Method Description:
    /// Generate a Vandermonde matrix.
    /// The columns of the output matrix are powers of the input vector. The order of the powers is determined by the
    /// increasing boolean argument. Specifically, when increasing is False, the i-th output column is the input vector
    /// raised element-wise to the power of N - i - 1. Such a matrix with a geometric progression in each row is named
    /// for Alexandre- Theophile Vandermonde.
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.vander.html
    ///
    /// @param x: 1-D input array, otherwise the array will be flattened
    /// @param increasing: Order of the powers of the columns. If True, the powers increase from left to right, if False
    /// (the default) they are reversed.
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    auto vander(const NdArray<dtype>& x, Increasing increasing = Increasing::YES)
    {
        return vander(x, x.size(), increasing);
    }
} // namespace nc

/*** End of inlined file: vander.hpp ***/


/*** Start of inlined file: var.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <algorithm>
#include <complex>

namespace nc
{

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.var.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> var(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<double> stdValues = stdev(inArray, inAxis);
        const auto      function  = [](double& value) -> void { value *= value; };

        stl_algorithms::for_each(stdValues.begin(), stdValues.end(), function);
        return stdValues;
    }

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.var.html
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<std::complex<double>> var(const NdArray<std::complex<dtype>>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        NdArray<std::complex<double>> stdValues = stdev(inArray, inAxis);
        const auto                    function  = [](std::complex<double>& value) -> void { value *= value; };

        stl_algorithms::for_each(stdValues.begin(), stdValues.end(), function);
        return stdValues;
    }
} // namespace nc

/*** End of inlined file: var.hpp ***/


/*** Start of inlined file: vstack.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <initializer_list>
#include <vector>

namespace nc
{

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.vstack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> vstack(std::initializer_list<NdArray<dtype>> inArrayList)
    {
        return detail::row_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }

    // Method Description:
    /// Compute the variance along the specified axis.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.vstack.html
    ///
    /// @param inArrayList: {list} of arrays to stack
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> vstack(std::vector<NdArray<dtype>> inArrayList)
    {
        return detail::row_stack<dtype>(inArrayList.begin(), inArrayList.end());
    }
} // namespace nc

/*** End of inlined file: vstack.hpp ***/


/*** Start of inlined file: where.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

#include <string>

namespace nc
{

    // Method Description:
    /// Return elements, either from x or y, depending on the input mask.
    /// The output array contains elements of x where mask is True, and
    /// elements from y elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.where.html
    ///
    /// @param inMask
    /// @param inA
    /// @param inB
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> where(const NdArray<bool>& inMask, const NdArray<dtype>& inA, const NdArray<dtype>& inB)
    {
        const auto shapeMask = inMask.shape();
        const auto shapeA    = inA.shape();
        if (shapeA != inB.shape())
        {
            THROW_INVALID_ARGUMENT_ERROR("input inA and inB must be the same shapes.");
        }

        if (shapeMask != shapeA)
        {
            THROW_INVALID_ARGUMENT_ERROR("input inMask must be the same shape as the input arrays.");
        }

        auto outArray = NdArray<dtype>(shapeMask);

        uint32 idx = 0;
        for (auto maskValue : inMask)
        {
            if (maskValue)
            {
                outArray[idx] = inA[idx];
            }
            else
            {
                outArray[idx] = inB[idx];
            }
            ++idx;
        }

        return outArray;
    }

    // Method Description:
    /// Return elements, either from x or y, depending on the input mask.
    /// The output array contains elements of x where mask is True, and
    /// elements from y elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.where.html
    ///
    /// @param inMask
    /// @param inA
    /// @param inB
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> where(const NdArray<bool>& inMask, const NdArray<dtype>& inA, dtype inB)
    {
        const auto shapeMask = inMask.shape();
        const auto shapeA    = inA.shape();
        if (shapeMask != shapeA)
        {
            THROW_INVALID_ARGUMENT_ERROR("input inMask must be the same shape as the input arrays.");
        }

        auto outArray = NdArray<dtype>(shapeMask);

        uint32 idx = 0;
        for (auto maskValue : inMask)
        {
            if (maskValue)
            {
                outArray[idx] = inA[idx];
            }
            else
            {
                outArray[idx] = inB;
            }
            ++idx;
        }

        return outArray;
    }

    // Method Description:
    /// Return elements, either from x or y, depending on the input mask.
    /// The output array contains elements of x where mask is True, and
    /// elements from y elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.where.html
    ///
    /// @param inMask
    /// @param inA
    /// @param inB
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> where(const NdArray<bool>& inMask, dtype inA, const NdArray<dtype>& inB)
    {
        const auto shapeMask = inMask.shape();
        const auto shapeB    = inB.shape();
        if (shapeMask != shapeB)
        {
            THROW_INVALID_ARGUMENT_ERROR("input inMask must be the same shape as the input arrays.");
        }

        auto outArray = NdArray<dtype>(shapeMask);

        uint32 idx = 0;
        for (auto maskValue : inMask)
        {
            if (maskValue)
            {
                outArray[idx] = inA;
            }
            else
            {
                outArray[idx] = inB[idx];
            }
            ++idx;
        }

        return outArray;
    }

    // Method Description:
    /// Return elements, either from x or y, depending on the input mask.
    /// The output array contains elements of x where mask is True, and
    /// elements from y elsewhere.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.where.html
    ///
    /// @param inMask
    /// @param inA
    /// @param inB
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> where(const NdArray<bool>& inMask, dtype inA, dtype inB)
    {
        auto outArray = NdArray<dtype>(inMask.shape());

        uint32 idx = 0;
        for (auto maskValue : inMask)
        {
            if (maskValue)
            {
                outArray[idx] = inA;
            }
            else
            {
                outArray[idx] = inB;
            }
            ++idx;
        }

        return outArray;
    }
} // namespace nc

/*** End of inlined file: where.hpp ***/


/*** Start of inlined file: zeros_like.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Functions for working with NdArrays
///
#pragma once

namespace nc
{

    // Method Description:
    /// Return a new array of given shape and type, filled with zeros.
    ///
    /// NumPy Reference: https://www.numpy.org/devdocs/reference/generated/numpy.zeros_like.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtypeOut, typename dtype>
    NdArray<dtypeOut> zeros_like(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<dtypeOut> returnArray(inArray.shape());
        returnArray.zeros();
        return returnArray;
    }
} // namespace nc

/*** End of inlined file: zeros_like.hpp ***/

/*** End of inlined file: Functions.hpp ***/


/*** Start of inlined file: ImageProcessing.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A module for basic image processing
///
#pragma once


/*** Start of inlined file: Centroid.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// holds the information for a centroid
///
#pragma once

#include <cmath>
#include <iostream>
#include <string>
#include <type_traits>


/*** Start of inlined file: Cluster.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds the information for a cluster of pixels
///

#pragma once

#include <algorithm>
#include <iostream>
#include <limits>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>


/*** Start of inlined file: Pixel.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Holds the information for a single pixel
///

#pragma once

#include <iostream>
#include <string>

namespace nc::imageProcessing
{

    // Class Description:
    /// Holds the information for a single pixel
    template<typename dtype>
    class Pixel
    {
    private:
        STATIC_ASSERT_ARITHMETIC(dtype);

    public:
        //==================================Attributes================================
        mutable int32 clusterId{ -1 };
        uint32        row{ 0 };
        uint32        col{ 0 };
        dtype         intensity{ 0 };

        // Description:
        /// defualt constructor needed by containers
        ///
        constexpr Pixel() = default;

        // Description:
        /// constructor
        ///
        /// @param inRow: pixel row
        /// @param inCol: pixel column
        /// @param inIntensity: pixel intensity
        ///
        constexpr Pixel(uint32 inRow, uint32 inCol, dtype inIntensity) noexcept :
            row(inRow),
            col(inCol),
            intensity(inIntensity)
        {
        }

        // Description:
        /// equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        constexpr bool operator==(const Pixel<dtype>& rhs) const noexcept
        {
            return utils::essentiallyEqual(row, rhs.row) && utils::essentiallyEqual(col, rhs.col) &&
                   utils::essentiallyEqual(intensity, rhs.intensity);
        }

        // Description:
        /// not equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        constexpr bool operator!=(const Pixel<dtype>& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Description:
        /// less than operator for std::sort algorithm and std::set<>;
        /// NOTE: std::sort sorts in ascending order. Since I want to sort
        /// the centroids in descensing order, I am purposefully defining
        /// this operator backwards!
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator<(const Pixel<dtype>& rhs) const noexcept
        {
            if (row < rhs.row)
            {
                return true;
            }
            if (row == rhs.row)
            {
                return static_cast<bool>(col < rhs.col);
            }

            return false;
        }

        // Description:
        /// returns the pixel information as a string
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out = "row = " + utils::num2str(row) + " col = " + utils::num2str(col);
            out += " intensity = " + utils::num2str(intensity) + '\n';
            return out;
        }

        /// Method Description:
        /// prints the Pixel object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        // Description:
        /// osstream operator
        ///
        /// @param inStream
        /// @param inPixel
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const Pixel<dtype>& inPixel)
        {
            inStream << inPixel.str();
            return inStream;
        }
    };
} // namespace nc::imageProcessing

/*** End of inlined file: Pixel.hpp ***/

namespace nc::imageProcessing
{

    // Class Description:
    /// Holds the information for a cluster of pixels
    template<typename dtype>
    class Cluster
    {
    private:
        STATIC_ASSERT_ARITHMETIC(dtype);

    public:
        //================================Typedefs===============================
        using const_iterator = typename std::vector<Pixel<dtype>>::const_iterator;
        using accumulator_t  = typename std::conditional<std::is_integral<dtype>::value, int64, double>::type;

        // Description:
        /// default constructor needed by containers
        ///
        Cluster() = default;

        // Description:
        /// constructor
        ///
        /// @param inClusterId
        ///
        explicit Cluster(uint32 inClusterId) noexcept :
            clusterId_(inClusterId)
        {
        }

        // Description:
        /// equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator==(const Cluster<dtype>& rhs) const noexcept
        {
            if (pixels_.size() != rhs.pixels_.size())
            {
                return false;
            }

            return stl_algorithms::equal(begin(), end(), rhs.begin());
        }

        // Description:
        /// not equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator!=(const Cluster<dtype>& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Description:
        /// access operator, no bounds checking
        ///
        /// @param inIndex
        ///
        /// @return Pixel
        ///
        const Pixel<dtype>& operator[](uint32 inIndex) const noexcept
        {
            return pixels_[inIndex];
        }

        // Description:
        /// access method with bounds checking
        ///
        /// @param inIndex
        ///
        /// @return Pixel
        ///
        [[nodiscard]] const Pixel<dtype>& at(uint32 inIndex) const
        {
            if (inIndex >= pixels_.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("index exceeds cluster size.");
            }
            return pixels_[inIndex];
        }

        // Description:
        /// returns in iterator to the beginning pixel of the cluster
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator begin() const noexcept
        {
            return pixels_.cbegin();
        }

        // Description:
        /// returns in iterator to the 1 past the end pixel of the cluster
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator end() const noexcept
        {
            return pixels_.cend();
        }

        // Description:
        /// returns the number of pixels in the cluster
        ///
        /// @return number of pixels in the cluster
        ///
        [[nodiscard]] uint32 size() const noexcept
        {
            return static_cast<uint32>(pixels_.size());
        }

        // Description:
        /// returns the minimum row number of the cluster
        ///
        /// @return minimum row number of the cluster
        ///
        [[nodiscard]] uint32 clusterId() const noexcept
        {
            return clusterId_;
        }

        // Description:
        /// returns the minimum row number of the cluster
        ///
        /// @return minimum row number of the cluster
        ///
        [[nodiscard]] uint32 rowMin() const noexcept
        {
            return rowMin_;
        }

        // Description:
        /// returns the maximum row number of the cluster
        ///
        /// @return maximum row number of the cluster
        ///
        [[nodiscard]] uint32 rowMax() const noexcept
        {
            return rowMax_;
        }

        // Description:
        /// returns the minimum column number of the cluster
        ///
        /// @return minimum column number of the cluster
        ///
        [[nodiscard]] uint32 colMin() const noexcept
        {
            return colMin_;
        }

        // Description:
        /// returns the maximum column number of the cluster
        ///
        /// @return maximum column number of the cluster
        ///
        [[nodiscard]] uint32 colMax() const noexcept
        {
            return colMax_;
        }

        // Description:
        /// returns the number of rows the cluster spans
        ///
        /// @return number of rows
        ///
        [[nodiscard]] uint32 height() const noexcept
        {
            return rowMax_ - rowMin_ + 1;
        }

        // Description:
        /// returns the number of columns the cluster spans
        ///
        /// @return number of columns
        ///
        [[nodiscard]] uint32 width() const noexcept
        {
            return colMax_ - colMin_ + 1;
        }

        // Description:
        /// returns the summed intensity of the cluster
        ///
        /// @return summed cluster intensity
        ///
        [[nodiscard]] accumulator_t intensity() const noexcept
        {
            return intensity_;
        }

        // Description:
        /// returns the intensity of the peak pixel in the cluster
        ///
        /// @return peak pixel intensity
        ///
        [[nodiscard]] dtype peakPixelIntensity() const noexcept
        {
            return peakPixelIntensity_;
        }

        // Description:
        /// returns the cluster estimated energy on detector (EOD)
        ///
        /// @return eod
        ///
        [[nodiscard]] double eod() const noexcept
        {
            return eod_;
        }

        // Description:
        /// adds a pixel to the cluster
        ///
        /// @param inPixel
        ///
        void addPixel(const Pixel<dtype>& inPixel)
        {
            pixels_.push_back(inPixel);
            intensity_ += static_cast<accumulator_t>(inPixel.intensity);

            // adjust the cluster bounds
            rowMin_             = std::min(rowMin_, inPixel.row);
            rowMax_             = std::max(rowMax_, inPixel.row);
            colMin_             = std::min(colMin_, inPixel.col);
            colMax_             = std::max(colMax_, inPixel.col);
            peakPixelIntensity_ = std::max(peakPixelIntensity_, inPixel.intensity);

            // calculate the energy on detector estimate
            eod_ = static_cast<double>(peakPixelIntensity_) / static_cast<double>(intensity_);
        }

        // Description:
        /// returns a string representation of the cluster
        ///
        /// @return string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out;
            uint32      counter = 0;
            std::for_each(begin(),
                          end(),
                          [&](const Pixel<dtype>& pixel)
                          { out += "Pixel " + utils::num2str(counter++) + ":" + pixel.str(); });

            return out;
        }

        /// Method Description:
        /// prints the Cluster object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        // Description:
        /// osstream operator
        ///
        /// @param inStream
        /// @param inCluster
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const Cluster<dtype>& inCluster)
        {
            inStream << inCluster.str();
            return inStream;
        }

    private:
        //================================Attributes===============================
        /// The cluster id
        int32 clusterId_{ -1 };
        /// The pixels that make up the cluster
        std::vector<Pixel<dtype>> pixels_{};
        /// The bounding box minimum row of the cluster.
        uint32 rowMin_{ std::numeric_limits<uint32>::max() }; // largest possible number
        /// The bounding box maximum row of the cluster.
        uint32 rowMax_{ 0 };
        /// The bounding box minimum col of the cluster.
        uint32 colMin_{ std::numeric_limits<uint32>::max() }; // largest possible number
        /// The bounding box maximum row of the cluster.
        uint32 colMax_{ 0 };
        /// The total summed intensity of the pixels in the cluster.
        accumulator_t intensity_{ 0 };
        /// The peak pixel intensity of the cluster
        dtype peakPixelIntensity_{ 0 };
        /// The minimum pixel count value of the cluster
        dtype minPixel{};
        /// The maximum pixel count value of the cluster
        dtype maxPixel{};
        /// The cluster energy on detector
        double eod_{ 1. };
    };
} // namespace nc::imageProcessing

/*** End of inlined file: Cluster.hpp ***/

namespace nc::imageProcessing
{

    // Class Description:
    /// holds the information for a centroid
    template<typename dtype>
    class Centroid
    {
    private:
        STATIC_ASSERT_ARITHMETIC(dtype);

    public:
        using accumulator_t = typename std::conditional<std::is_integral<dtype>::value, int64, double>::type;

        // Description:
        /// defualt constructor needed by containers
        ///
        Centroid() = default;

        // Description:
        /// constructor
        ///
        /// @param inCluster
        ///
        explicit Centroid(const Cluster<dtype>& inCluster) :
            intensity_(inCluster.intensity()),
            eod_(inCluster.eod())
        {
            centerOfMass(inCluster);
            setEllipseProperties(inCluster);
        }

        // Description:
        /// gets the centroid row
        ///
        /// @return centroid row
        ///
        [[nodiscard]] double row() const noexcept
        {
            return row_;
        }

        // Description:
        /// gets the centroid col
        ///
        /// @return centroid col
        ///
        [[nodiscard]] double col() const noexcept
        {
            return col_;
        }

        // Description:
        /// gets the centroid intensity
        ///
        /// @return centroid intensity
        ///
        [[nodiscard]] accumulator_t intensity() const noexcept
        {
            return intensity_;
        }

        // Description:
        /// returns the estimated eod of the centroid
        ///
        /// @return star id
        ///
        [[nodiscard]] double eod() const noexcept
        {
            return eod_;
        }

        // Description:
        /// returns the ellipse semi-major axis a
        ///
        /// @return a
        ///
        [[nodiscard]] double a() const noexcept
        {
            return a_;
        }

        // Description:
        /// returns the ellipse semi-minor axis b
        ///
        /// @return b
        ///
        [[nodiscard]] double b() const noexcept
        {
            return b_;
        }

        // Description:
        /// returns the ellipse eccentricity
        ///
        /// @return eccentricity
        ///
        [[nodiscard]] double eccentricity() const noexcept
        {
            return eccentricity_;
        }

        // Description:
        /// returns the ellipse semi-minor axis orientation
        ///
        /// @return orientation
        ///
        [[nodiscard]] double orientation() const noexcept
        {
            return orientation_;
        }

        // Description:
        /// returns the centroid as a string representation
        ///
        /// @return std::string
        ///
        [[nodiscard]] std::string str() const
        {
            std::string out = "row = " + utils::num2str(row_) + " col = " + utils::num2str(col_) +
                              " intensity = " + utils::num2str(intensity_) + " eod = " + utils::num2str(eod_) +
                              " a = " + utils::num2str(a_) + " b = " + utils::num2str(b_) +
                              " eccentricity = " + utils::num2str(eccentricity_) +
                              " orientation = " + utils::num2str(orientation_) + '\n';

            return out;
        }

        /// Method Description:
        /// prints the Centroid object to the console
        ///
        void print() const
        {
            std::cout << *this;
        }

        // Description:
        /// equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator==(const Centroid<dtype>& rhs) const noexcept
        {
            return (utils::essentiallyEqual(row_, rhs.row_) && utils::essentiallyEqual(col_, rhs.col_) &&
                    utils::essentiallyEqual(intensity_, rhs.intensity_) && utils::essentiallyEqual(eod_, rhs.eod_) &&
                    utils::essentiallyEqual(a_, rhs.a_) && utils::essentiallyEqual(b_, rhs.b_) &&
                    utils::essentiallyEqual(eccentricity_, rhs.eccentricity_) &&
                    utils::essentiallyEqual(orientation_, rhs.orientation_));
        }

        // Description:
        /// not equality operator
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator!=(const Centroid<dtype>& rhs) const noexcept
        {
            return !(*this == rhs);
        }

        // Description:
        /// less than operator for std::sort algorithm;
        /// NOTE: std::sort sorts in ascending order. Since I want to sort
        /// the centroids in descensing order, I am purposefully defining
        /// this operator backwards!
        ///
        /// @param rhs
        ///
        /// @return bool
        ///
        bool operator<(const Centroid<dtype>& rhs) const noexcept
        {
            return intensity_ < rhs.intensity_ ? false : true;
        }

        // Description:
        /// ostream operator
        ///
        /// @param inStream
        /// @param inCentriod
        /// @return std::ostream
        ///
        friend std::ostream& operator<<(std::ostream& inStream, const Centroid<dtype>& inCentriod)
        {
            inStream << inCentriod.str();
            return inStream;
        }

    private:
        //==================================Attributes================================///
        double        row_{ 0. };
        double        col_{ 0. };
        accumulator_t intensity_{ 0 };
        double        eod_{ 0. };
        /// The ellipse semi-major axis a
        double a_{};
        /// The ellipse semi-minor axis b
        double b_{};
        /// The centriod eccentricity
        double eccentricity_{};
        /// The centriod ellipse orientation in radians.  Measured counter-clockwise from +x axis
        double orientation_{};

        // Description:
        /// center of mass algorithm;
        /// WARNING: if both positive and negative values are present in the cluster,
        /// it can lead to an undefined COM.
        ///
        /// @param inCluster
        ///
        void centerOfMass(const Cluster<dtype>& inCluster)
        {
            const Shape    clusterShape(inCluster.height(), inCluster.width());
            NdArray<dtype> clusterArray(clusterShape);
            clusterArray.zeros();

            const uint32 rowMin = inCluster.rowMin();
            const uint32 colMin = inCluster.colMin();

            for (auto& pixel : inCluster)
            {
                clusterArray(pixel.row - rowMin, pixel.col - colMin) = pixel.intensity;
            }

            const auto rowCol = nc::centerOfMass(clusterArray);
            row_              = rowCol.front() + rowMin;
            col_              = rowCol.back() + colMin;
        }

        // Description:
        /// Sets the cluster ellipse properties
        ///
        /// @param inCluster
        ///
        void setEllipseProperties(const Cluster<dtype>& inCluster) noexcept
        {
            constexpr auto two = static_cast<double>(2.);

            auto m20 = static_cast<double>(0.);
            auto m02 = static_cast<double>(0.);
            auto m11 = static_cast<double>(0.);

            for (typename Cluster<dtype>::const_iterator iter = inCluster.begin(); iter != inCluster.end(); ++iter)
            {
                const auto&  pixel  = *iter;
                const double deltaX = pixel.col - col_;
                const double deltaY = pixel.row - row_;

                m11 += deltaX * deltaY;
                m20 += utils::sqr(deltaX);
                m02 += utils::sqr(deltaY);
            }

            const auto numPixels = static_cast<double>(inCluster.size());
            m11 /= numPixels;
            m20 /= numPixels;
            m02 /= numPixels;

            double piece1 = m20 + m02;
            piece1 /= two;

            double piece2 = std::sqrt(static_cast<double>(4.) * utils::sqr(m11) + utils::sqr(m20 - m02));
            piece2 /= two;

            const double lambda1 = piece1 - piece2;
            const double lambda2 = piece1 + piece2;

            eccentricity_ = std::sqrt(static_cast<double>(1.) - lambda1 / lambda2);
            orientation_  = static_cast<double>(-0.5) * std::atan2(two * m11, m20 - m02);
            a_            = two * std::sqrt(lambda2);
            b_            = two * std::sqrt(lambda1);
        }
    };
} // namespace nc::imageProcessing

/*** End of inlined file: Centroid.hpp ***/


/*** Start of inlined file: ClusterMaker.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Clusters exceedance data into contiguous groups
///

#pragma once

#include <algorithm>
#include <cmath>
#include <set>
#include <string>
#include <utility>
#include <vector>

namespace nc::imageProcessing
{

    // Class Description:
    /// Clusters exceedance data into contiguous groups
    template<typename dtype>
    class ClusterMaker
    {
    private:
        STATIC_ASSERT_ARITHMETIC(dtype);

    public:
        //================================Typedefs=====================================
        using const_iterator = typename std::vector<Cluster<dtype>>::const_iterator;

        // Description:
        /// constructor
        ///
        /// @param inXcdArrayPtr: pointer to exceedance array
        /// @param inIntensityArrayPtr: pointer to intensity array
        /// @param inBorderWidth: border to apply around exceedance pixels post clustering (default 0)
        ///
        ClusterMaker(const NdArray<bool>* const  inXcdArrayPtr,
                     const NdArray<dtype>* const inIntensityArrayPtr,
                     uint8                       inBorderWidth = 0) :
            xcds_(inXcdArrayPtr),
            intensities_(inIntensityArrayPtr)
        {
            if (xcds_->shape() != intensities_->shape())
            {
                THROW_INVALID_ARGUMENT_ERROR("input xcd and intensity arrays must be the same shape.");
            }

            shape_ = xcds_->shape();

            // convert the NdArray of booleans to a vector of exceedances
            for (uint32 row = 0; row < shape_.rows; ++row)
            {
                for (uint32 col = 0; col < shape_.cols; ++col)
                {
                    if (xcds_->operator()(row, col))
                    {
                        const Pixel<dtype> thePixel(row, col, intensities_->operator()(row, col));
                        xcdsVec_.push_back(thePixel);
                    }
                }
            }

            runClusterMaker();

            for (uint8 i = 0; i < inBorderWidth; ++i)
            {
                expandClusters();
            }
        }

        // Description:
        /// returns the number of clusters in the frame
        ///
        /// @return number of clusters
        ///
        uint32 size() noexcept
        {
            return static_cast<uint32>(clusters_.size());
        }

        // Description:
        /// access operator, no bounds checking
        ///
        /// @param inIndex
        ///
        /// @return Cluster
        ///
        const Cluster<dtype>& operator[](uint32 inIndex) const noexcept
        {
            return clusters_[inIndex];
        }

        // Description:
        /// access method with bounds checking
        ///
        /// @param inIndex
        ///
        /// @return Cluster
        ///
        [[nodiscard]] const Cluster<dtype>& at(uint32 inIndex) const
        {
            if (inIndex >= clusters_.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("index exceeds cluster size.");
            }
            return clusters_[inIndex];
        }

        // Description:
        /// returns in iterator to the beginning cluster of the container
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator begin() const noexcept
        {
            return clusters_.cbegin();
        }

        // Description:
        /// returns in iterator to the 1 past the end cluster of the container
        ///
        /// @return const_iterator
        ///
        [[nodiscard]] const_iterator end() const noexcept
        {
            return clusters_.cend();
        }

    private:
        //==================================Attributes=================================
        const NdArray<bool>* const  xcds_{};
        const NdArray<dtype>* const intensities_{};
        std::vector<Pixel<dtype>>   xcdsVec_{};

        Shape shape_{};

        std::vector<Cluster<dtype>> clusters_{};

        // Description:
        /// checks that the input row and column have not fallen off of the edge
        ///
        /// @param inRow
        /// @param inCol
        ///
        /// @return returns a pixel object clipped to the image boundaries
        ///
        Pixel<dtype> makePixel(int32 inRow, int32 inCol) noexcept
        {
            // Make sure that on the edges after i've added or subtracted 1 from the row and col that
            // i haven't gone over the edge
            const uint32 row       = std::min(static_cast<uint32>(std::max<int32>(inRow, 0)), shape_.rows - 1);
            const uint32 col       = std::min(static_cast<uint32>(std::max<int32>(inCol, 0)), shape_.cols - 1);
            const dtype  intensity = intensities_->operator()(row, col);

            return Pixel<dtype>(row, col, intensity);
        }

        // Description:
        /// finds all of the neighboring pixels to the input pixel
        ///
        /// @param inPixel
        /// @param outNeighbors
        /// @return None
        ///
        void findNeighbors(const Pixel<dtype>& inPixel, std::set<Pixel<dtype>>& outNeighbors)
        {
            // using a set will auto take care of adding duplicate pixels on the edges

            // the 8 surrounding neighbors
            const auto row = static_cast<int32>(inPixel.row);
            const auto col = static_cast<int32>(inPixel.col);

            outNeighbors.insert(outNeighbors.end(), makePixel(row - 1, col - 1));
            outNeighbors.insert(outNeighbors.end(), makePixel(row - 1, col));
            outNeighbors.insert(outNeighbors.end(), makePixel(row - 1, col + 1));
            outNeighbors.insert(outNeighbors.end(), makePixel(row, col - 1));
            outNeighbors.insert(outNeighbors.end(), makePixel(row, col + 1));
            outNeighbors.insert(outNeighbors.end(), makePixel(row + 1, col - 1));
            outNeighbors.insert(outNeighbors.end(), makePixel(row + 1, col));
            outNeighbors.insert(outNeighbors.end(), makePixel(row + 1, col + 1));
        }

        // Description:
        /// finds all of the neighboring pixels to the input pixel that are NOT exceedances
        ///
        /// @param inPixel
        /// @param outNeighbors
        ///
        /// @return vector of non exceedance neighboring pixels
        ///
        void findNeighborNotXcds(const Pixel<dtype>& inPixel, std::vector<Pixel<dtype>>& outNeighbors)
        {
            std::set<Pixel<dtype>> neighbors;
            findNeighbors(inPixel, neighbors);

            // check if the neighboring pixels are exceedances and insert into the xcd vector
            for (auto& pixel : neighbors)
            {
                if (!xcds_->operator()(pixel.row, pixel.col))
                {
                    outNeighbors.push_back(pixel);
                }
            }
        }

        // Description:
        /// finds the pixel index of neighboring pixels
        ///
        /// @param inPixel
        /// @param outNeighbors
        ///
        /// @return vector of neighboring pixel indices
        ///
        void findNeighborXcds(const Pixel<dtype>& inPixel, std::vector<uint32>& outNeighbors)
        {
            std::set<Pixel<dtype>> neighbors;
            findNeighbors(inPixel, neighbors);
            std::vector<Pixel<dtype>> neighborXcds;

            // check if the neighboring pixels are exceedances and insert into the xcd vector
            for (auto& pixel : neighbors)
            {
                if (xcds_->operator()(pixel.row, pixel.col))
                {
                    neighborXcds.push_back(pixel);
                }
            }

            // loop through the neighbors and find the cooresponding index into exceedances_
            for (auto& pixel : neighborXcds)
            {
                auto theExceedanceIter = std::find(xcdsVec_.begin(), xcdsVec_.end(), pixel);
                outNeighbors.push_back(static_cast<uint32>(theExceedanceIter - xcdsVec_.begin()));
            }
        }

        // Description:
        /// workhorse method that performs the clustering algorithm
        ///
        void runClusterMaker()
        {
            uint32 clusterId = 0;

            for (auto& currentPixel : xcdsVec_)
            {
                // not already visited
                if (currentPixel.clusterId == -1)
                {
                    Cluster<dtype> newCluster(clusterId); // a new cluster
                    currentPixel.clusterId = clusterId;
                    newCluster.addPixel(currentPixel); // assign pixel to cluster

                    // get the neighbors
                    std::vector<uint32> neighborIds;
                    findNeighborXcds(currentPixel, neighborIds);
                    if (neighborIds.empty())
                    {
                        clusters_.push_back(newCluster);
                        ++clusterId;
                        continue;
                    }

                    // loop through the neighbors
                    for (uint32 neighborsIdx = 0; neighborsIdx < neighborIds.size(); ++neighborsIdx)
                    {
                        Pixel<dtype>& currentNeighborPixel = xcdsVec_[neighborIds[neighborsIdx]];

                        // go to neighbors
                        std::vector<uint32> newNeighborIds;
                        findNeighborXcds(currentNeighborPixel, newNeighborIds);

                        // loop through the new neighbors and add them to neighbors
                        for (auto newNeighborId : newNeighborIds)
                        {
                            // not already in neighbors
                            if (std::find(neighborIds.begin(), neighborIds.end(), newNeighborId) == neighborIds.end())
                            {
                                neighborIds.push_back(newNeighborId);
                            }
                        }

                        // not already assigned to a cluster
                        if (currentNeighborPixel.clusterId == -1)
                        {
                            currentNeighborPixel.clusterId = clusterId;
                            newCluster.addPixel(currentNeighborPixel);
                        }
                    }

                    clusters_.push_back(std::move(newCluster));
                    ++clusterId;
                }
            }
        }

        // Description:
        /// 3x3 dialates the clusters
        ///
        void expandClusters()
        {
            // loop through the clusters
            for (auto& theCluster : clusters_)
            {
                // loop through the pixels of the cluster
                for (auto& thePixel : theCluster)
                {
                    std::vector<Pixel<dtype>> neighborsNotXcds;
                    findNeighborNotXcds(thePixel, neighborsNotXcds);

                    // loop through the neighbors and if they haven't already been added to the cluster, add them
                    for (auto& newPixel : neighborsNotXcds)
                    {
                        if (std::find(theCluster.begin(), theCluster.end(), newPixel) == theCluster.end())
                        {
                            theCluster.addPixel(newPixel);
                        }
                    }
                }
            }
        }
    };
} // namespace nc::imageProcessing

/*** End of inlined file: ClusterMaker.hpp ***/


/*** Start of inlined file: applyThreshold.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Applies a threshold to an image
///
#pragma once

namespace nc::imageProcessing
{

    // Method Description:
    /// Applies a threshold to an image
    ///
    /// @param inImageArray
    /// @param inThreshold
    /// @return NdArray of booleans of pixels that exceeded the threshold
    ///
    template<typename dtype>
    NdArray<bool> applyThreshold(const NdArray<dtype>& inImageArray, dtype inThreshold)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return inImageArray > inThreshold;
    }
} // namespace nc::imageProcessing

/*** End of inlined file: applyThreshold.hpp ***/


/*** Start of inlined file: centroidClusters.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Center of Mass centroids clusters
///

#pragma once

#include <utility>
#include <vector>

namespace nc::imageProcessing
{

    // Method Description:
    /// Center of Mass centroids clusters
    ///
    /// @param inClusters
    /// @return std::vector<Centroid>
    ///
    template<typename dtype>
    std::vector<Centroid<dtype>> centroidClusters(const std::vector<Cluster<dtype>>& inClusters)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        std::vector<Centroid<dtype>> centroids(inClusters.size());
        stl_algorithms::transform(inClusters.begin(),
                                  inClusters.end(),
                                  centroids.begin(),
                                  [](const auto& cluster) -> Centroid<dtype> { return Centroid<dtype>(cluster); });
        return centroids;
    }
} // namespace nc::imageProcessing

/*** End of inlined file: centroidClusters.hpp ***/


/*** Start of inlined file: clusterPixels.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Clusters exceedance pixels from an image
///

#pragma once

#include <vector>

namespace nc::imageProcessing
{

    // Method Description:
    /// Clusters exceedance pixels from an image
    ///
    /// @param inImageArray
    /// @param inExceedances
    /// @param inBorderWidth: border to apply around exceedance pixels post clustering (default 0)
    /// @return std::vector<Cluster>
    ///
    template<typename dtype>
    std::vector<Cluster<dtype>>
        clusterPixels(const NdArray<dtype>& inImageArray, const NdArray<bool>& inExceedances, uint8 inBorderWidth = 0)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        ClusterMaker<dtype> clusterMaker(&inExceedances, &inImageArray, inBorderWidth);
        return std::vector<Cluster<dtype>>(clusterMaker.begin(), clusterMaker.end());
    }
} // namespace nc::imageProcessing

/*** End of inlined file: clusterPixels.hpp ***/


/*** Start of inlined file: generateCentroids.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Generates a list of centroids givin an input exceedance rate
///

#pragma once

#include <string>
#include <vector>


/*** Start of inlined file: generateThreshold.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Generates a threshold
///

#pragma once

#include <cmath>
#include <string>

namespace nc::imageProcessing
{

    // Method Description:
    /// Calculates a threshold such that the input rate of pixels
    /// exceeds the threshold. Really should only be used for integer
    /// input array values. If using floating point data, user beware...
    ///
    /// @param inImageArray
    /// @param inRate
    /// @return dtype
    ///
    template<typename dtype>
    dtype generateThreshold(const NdArray<dtype>& inImageArray, double inRate)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (inRate < 0. || inRate > 1.)
        {
            THROW_INVALID_ARGUMENT_ERROR("input rate must be of the range [0, 1]");
        }

        // first build a histogram
        auto minValue = static_cast<int32>(std::floor(inImageArray.min().item()));
        auto maxValue = static_cast<int32>(std::floor(inImageArray.max().item()));

        if (utils::essentiallyEqual(inRate, 0.))
        {
            return static_cast<dtype>(maxValue);
        }

        if (utils::essentiallyEqual(inRate, 1.))
        {
            if (DtypeInfo<dtype>::isSigned())
            {
                return static_cast<dtype>(minValue - 1);
            }

            return dtype{ 0 };
        }

        const auto histSize = static_cast<uint32>(maxValue - minValue + 1);

        NdArray<double> histogram(1, histSize);
        histogram.zeros();
        for (auto intensity : inImageArray)
        {
            const auto bin = static_cast<uint32>(static_cast<int32>(std::floor(intensity)) - minValue);
            ++histogram[bin];
        }

        // integrate the normalized histogram from right to left to make a survival function (1 - CDF)
        const auto      dNumPixels = static_cast<double>(inImageArray.size());
        NdArray<double> survivalFunction(1, histSize + 1);
        survivalFunction[-1] = 0.;
        for (int32 i = histSize - 1; i > -1; --i)
        {
            double histValue    = histogram[i] / dNumPixels;
            survivalFunction[i] = survivalFunction[i + 1] + histValue;
        }

        // binary search through the survival function to find the rate
        uint32 indexLow  = 0;
        uint32 indexHigh = histSize - 1;
        uint32 index     = indexHigh / 2; // integer division

        constexpr bool keepGoing = true;
        while (keepGoing)
        {
            const double value = survivalFunction[index];
            if (value < inRate)
            {
                indexHigh = index;
            }
            else if (value > inRate)
            {
                indexLow = index;
            }
            else
            {
                const int32 thresh = static_cast<int32>(index) + minValue - 1;
                if (DtypeInfo<dtype>::isSigned())
                {
                    return static_cast<dtype>(thresh);
                }

                return thresh < 0 ? 0 : static_cast<dtype>(thresh);
            }

            if (indexHigh - indexLow < 2)
            {
                return static_cast<dtype>(static_cast<int32>(indexHigh) + minValue - 1);
            }

            index = indexLow + (indexHigh - indexLow) / 2;
        }

        // shouldn't ever get here but stop the compiler from throwing a warning
        return static_cast<dtype>(histSize - 1);
    }

} // namespace nc::imageProcessing

/*** End of inlined file: generateThreshold.hpp ***/


/*** Start of inlined file: windowExceedances.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Window expand around exceedance pixels
///

#pragma once

#include <cmath>

namespace nc::imageProcessing
{

    // Method Description:
    /// Window expand around exceedance pixels
    ///
    /// @param inExceedances
    /// @param inBorderWidth
    /// @return NdArray<bool>
    ///
    inline NdArray<bool> windowExceedances(const NdArray<bool>& inExceedances, uint8 inBorderWidth) noexcept
    {
        // not the most efficient way to do things, but the easist...
        NdArray<bool> xcds(inExceedances);
        const Shape   inShape = xcds.shape();
        for (uint8 border = 0; border < inBorderWidth; ++border)
        {
            for (int32 row = 0; row < static_cast<int32>(inShape.rows); ++row)
            {
                for (int32 col = 0; col < static_cast<int32>(inShape.cols); ++col)
                {
                    if (inExceedances(row, col))
                    {
                        xcds(std::max(row - 1, 0), std::max(col - 1, 0))                       = true;
                        xcds(std::max(row - 1, 0), col)                                        = true;
                        xcds(std::max(row - 1, 0), std::min<int32>(col + 1, inShape.cols - 1)) = true;

                        xcds(row, std::max<int32>(col - 1, 0))                = true;
                        xcds(row, std::min<int32>(col + 1, inShape.cols - 1)) = true;

                        xcds(std::min<int32>(row + 1, inShape.rows - 1), std::max(col - 1, 0)) = true;
                        xcds(std::min<int32>(row + 1, inShape.rows - 1), col)                  = true;
                        xcds(std::min<int32>(row + 1, inShape.rows - 1), std::min<int32>(col + 1, inShape.cols - 1)) =
                            true;
                    }
                }
            }
        }

        return xcds;
    }
} // namespace nc::imageProcessing

/*** End of inlined file: windowExceedances.hpp ***/

namespace nc::imageProcessing
{

    // Method Description:
    /// Generates a list of centroids givin an input exceedance
    /// rate
    ///
    /// @param inImageArray
    /// @param inRate: exceedance rate
    /// @param inWindowType: (string "pre", or "post" for where to apply the exceedance windowing)
    /// @param inBorderWidth: border to apply (default 0)
    /// @return std::vector<Centroid>
    ///
    template<typename dtype>
    std::vector<Centroid<dtype>> generateCentroids(const NdArray<dtype>& inImageArray,
                                                   double                inRate,
                                                   const std::string&    inWindowType,
                                                   uint8                 inBorderWidth = 0)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        uint8 borderWidthPre  = 0;
        uint8 borderWidthPost = 0;
        if (inWindowType == "pre")
        {
            borderWidthPre = inBorderWidth;
        }
        else if (inWindowType == "post")
        {
            borderWidthPost = inBorderWidth;
        }
        else
        {
            THROW_INVALID_ARGUMENT_ERROR("input window type options are ['pre', 'post']");
        }

        // generate the threshold
        dtype threshold = generateThreshold(inImageArray, inRate);

        // apply the threshold to get xcds
        NdArray<bool> xcds = applyThreshold(inImageArray, threshold);

        // window around the xcds
        if (borderWidthPre > 0)
        {
            xcds = windowExceedances(xcds, borderWidthPre);
        }

        // cluster the exceedances
        std::vector<Cluster<dtype>> clusters = clusterPixels(inImageArray, xcds, borderWidthPost);

        // centroid the clusters
        return centroidClusters(clusters);
    }
} // namespace nc::imageProcessing

/*** End of inlined file: generateCentroids.hpp ***/

/*** End of inlined file: ImageProcessing.hpp ***/


/*** Start of inlined file: Integrate.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Numerical Integration routines
///
#pragma once


/*** Start of inlined file: gauss_legendre.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Numerical Integration
///
/// Code modified under MIT license from https://github.com/Ben1980/numericalIntegration
/// as posted in https://thoughts-on-coding.com/2019/04/25/numerical-methods-in-c-part-2-gauss-legendre-integration/
///
#pragma once

#include <cmath>
#include <functional>
#include <vector>

namespace nc::integrate
{

    // Class Description:
    /// Legendre Polynomial class
    ///
    class LegendrePolynomial
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param numIterations: the number of iterations to perform
        ///
        explicit LegendrePolynomial(const uint32 numIterations) noexcept :
            numIterations_(numIterations),
            weight_(numIterations + 1),
            root_(numIterations + 1)
        {
            calculateWeightAndRoot();
        }

        // Method Description:
        /// Returns the weights vector
        ///
        /// @return weights vector
        ///
        [[nodiscard]] const std::vector<double>& getWeight() const noexcept
        {
            return weight_;
        }

        // Method Description:
        /// Returns the roots vector
        ///
        /// @return roots vector
        ///
        [[nodiscard]] const std::vector<double>& getRoot() const noexcept
        {
            return root_;
        }

    private:

        // Class Description:
        /// Simple class to hold the results
        ///
        struct Result
        {
            double value{ 0. };
            double derivative{ 0. };

            // Method Description:
            /// Constructor
            ///
            /// @param val: the value
            /// @param deriv: the derivative
            ///
            Result(const double val, const double deriv) noexcept :
                value(val),
                derivative(deriv)
            {
            }
        };

        // Method Description:
        /// Calculates the weights and roots vectors
        ///
        void calculateWeightAndRoot() noexcept
        {
            const auto numIterationsDouble = static_cast<double>(numIterations_);
            for (uint32 step = 0; step <= numIterations_; ++step)
            {
                double root =
                    std::cos(constants::pi * (static_cast<double>(step) - 0.25) / (numIterationsDouble + 0.5));
                Result result = calculatePolynomialValueAndDerivative(root);

                double newtonRaphsonRatio;
                do
                {
                    newtonRaphsonRatio = result.value / result.derivative;
                    root -= newtonRaphsonRatio;
                    result = calculatePolynomialValueAndDerivative(root);
                } while (std::fabs(newtonRaphsonRatio) > EPSILON);

                root_[step]   = root;
                weight_[step] = 2. / ((1. - utils::sqr(root)) * result.derivative * result.derivative);
            }
        }

        // Method Description:
        /// Calculates the weights and roots vectors
        ///
        /// @param x
        /// @return Result
        ///
        Result calculatePolynomialValueAndDerivative(const double x) noexcept
        {
            Result result(x, 0.);

            double       value_minus_1 = 1.;
            const double f             = 1. / (utils::sqr(x) - 1.);
            for (uint32 step = 2; step <= numIterations_; ++step)
            {
                const auto   stepDouble = static_cast<double>(step);
                const double value =
                    ((2. * stepDouble - 1.) * x * result.value - (stepDouble - 1.) * value_minus_1) / stepDouble;
                result.derivative = stepDouble * f * (x * value - result.value);

                value_minus_1 = result.value;
                result.value  = value;
            }

            return result;
        }

        //===================================Attributes==============================
        const double EPSILON{ 1e-15 };

        const uint32        numIterations_{};
        std::vector<double> weight_{};
        std::vector<double> root_{};
    };

    // Method Description:
    /// Performs Gauss-Legendre integration of the input function
    ///
    /// @param low: the lower bound of the integration
    /// @param high: the upper bound of the integration
    /// @param n: the number of iterations to perform
    /// @param f: the function to integrate over
    ///
    /// @return double
    ///
    inline double
        gauss_legendre(const double low, const double high, const uint32 n, const std::function<double(double)>& f)
    {
        const LegendrePolynomial   legendrePolynomial(n);
        const std::vector<double>& weight = legendrePolynomial.getWeight();
        const std::vector<double>& root   = legendrePolynomial.getRoot();

        const double width = 0.5 * (high - low);
        const double mean  = 0.5 * (low + high);

        double gaussLegendre = 0.;
        for (uint32 step = 1; step <= n; ++step)
        {
            gaussLegendre += weight[step] * f(width * root[step] + mean);
        }

        return gaussLegendre * width;
    }
} // namespace nc::integrate

/*** End of inlined file: gauss_legendre.hpp ***/


/*** Start of inlined file: romberg.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Numerical Integration
///
/// Code modified under MIT license from https://github.com/Ben1980/numericalIntegration
/// as posted in https://thoughts-on-coding.com/2019/04/17/numerical-methods-in-c-part-1-newton-cotes-integration/
///
#pragma once

#include <functional>
#include <vector>


/*** Start of inlined file: trapazoidal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Numerical Integration
///
/// Code modified under MIT license from https://github.com/Ben1980/numericalIntegration
/// as posted in https://thoughts-on-coding.com/2019/04/17/numerical-methods-in-c-part-1-newton-cotes-integration/
///
#pragma once

#include <functional>

namespace nc::integrate
{

    // Method Description:
    /// Performs Newton-Cotes trapazoidal integration of the input function
    ///
    /// @param low: the lower bound of the integration
    /// @param high: the upper bound of the integration
    /// @param n: the number of subdivisions
    /// @param f: the function to integrate over
    ///
    /// @return double
    ///
    inline double trapazoidal(const double                         low,
                              const double                         high,
                              const uint32                         n,
                              const std::function<double(double)>& f) noexcept
    {
        const double width = (high - low) / static_cast<double>(n);

        double trapezoidal_integral = 0.;
        for (uint32 step = 0; step < n; ++step)
        {
            const double x1 = low + static_cast<double>(step) * width;
            const double x2 = low + static_cast<double>(step + 1) * width;

            trapezoidal_integral += 0.5 * (x2 - x1) * (f(x1) + f(x2));
        }

        return trapezoidal_integral;
    }
} // namespace nc::integrate

/*** End of inlined file: trapazoidal.hpp ***/

namespace nc::integrate
{

    // Method Description:
    /// Performs Newton-Cotes Romberg integration of the input function
    ///
    /// @param low: the lower bound of the integration
    /// @param high: the upper bound of the integration
    /// @param n: the number of iterations
    /// @param f: the function to integrate over
    ///
    /// @return double
    ///
    inline double romberg(const double low, const double high, const uint8 n, const std::function<double(double)>& f)
    {
        NdArray<double> rombergIntegral(n);

        // R(0,0) Start with trapezoidal integration with N = 1
        rombergIntegral(0, 0) = trapazoidal(low, high, 1, f);

        double h = high - low;
        for (uint8 step = 1; step < n; step++)
        {
            h *= 0.5;

            // R(step, 0) Improve trapezoidal integration with decreasing h
            double       trapezoidal_integration = 0.;
            const uint32 stepEnd                 = utils::power(2, step - 1);
            for (uint32 tzStep = 1; tzStep <= stepEnd; ++tzStep)
            {
                const double deltaX = (2. * static_cast<double>(tzStep - 1)) * h;
                trapezoidal_integration += f(low + deltaX);
            }

            rombergIntegral(step, 0) = 0.5 * rombergIntegral(step - 1, 0);
            rombergIntegral(step, 0) += trapezoidal_integration * h;

            // R(m,n) Romberg integration with R(m,1) -> Simpson rule, R(m,2) -> Boole's rule
            for (uint8 rbStep = 1; rbStep <= step; ++rbStep)
            {
                const double k                = utils::power(4, rbStep);
                rombergIntegral(step, rbStep) = k * rombergIntegral(step, rbStep - 1);
                rombergIntegral(step, rbStep) -= rombergIntegral(step - 1, rbStep - 1);
                rombergIntegral(step, rbStep) /= (k - 1.);
            }
        }

        return rombergIntegral.back();
    }
} // namespace nc::integrate

/*** End of inlined file: romberg.hpp ***/


/*** Start of inlined file: simpson.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Numerical Integration
///
/// Code modified under MIT license from https://github.com/Ben1980/numericalIntegration
/// as posted in https://thoughts-on-coding.com/2019/04/17/numerical-methods-in-c-part-1-newton-cotes-integration/
///
#pragma once

#include <functional>

namespace nc::integrate
{

    // Method Description:
    /// Performs Newton-Cotes Simpson integration of the input function
    ///
    /// @param low: the lower bound of the integration
    /// @param high: the upper bound of the integration
    /// @param n: the number of subdivisions
    /// @param f: the function to integrate over
    ///
    /// @return double
    ///
    inline double
        simpson(const double low, const double high, const uint32 n, const std::function<double(double)>& f) noexcept
    {
        const double width = (high - low) / static_cast<double>(n);

        double simpson_integral = 0.;
        for (uint32 step = 0; step < n; ++step)
        {
            const double x1 = low + static_cast<double>(step) * width;
            const double x2 = low + static_cast<double>(step + 1) * width;

            simpson_integral += (x2 - x1) / 6. * (f(x1) + 4. * f(0.5 * (x1 + x2)) + f(x2));
        }

        return simpson_integral;
    }
} // namespace nc::integrate

/*** End of inlined file: simpson.hpp ***/

/*** End of inlined file: Integrate.hpp ***/


/*** Start of inlined file: Linalg.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Module for doing linear algebra operations
///
#pragma once


/*** Start of inlined file: cholesky.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix cholesky decomposition
///
/// Code modified under MIT license from https://github.com/Ben1980/linAlg
/// as posted in
/// https://thoughts-on-coding.com/2019/06/12/numerical-methods-with-c-part-4-introduction-into-decomposition-methods-of-linear-equation-systems/
///
#pragma once

namespace nc::linalg
{

    // Method Description:
    /// matrix cholesky decomposition A = L * L.transpose()
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.cholesky.html#numpy.linalg.cholesky
    ///
    /// @param inMatrix: NdArray to be decomposed
    ///
    /// @return NdArray of the decomposed L matrix
    ///
    template<typename dtype>
    NdArray<double> cholesky(const NdArray<dtype>& inMatrix)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto shape = inMatrix.shape();
        if (!shape.issquare())
        {
            THROW_RUNTIME_ERROR("Input matrix should be square.");
        }

        auto lMatrix = inMatrix.template astype<double>();

        for (uint32 row = 0; row < shape.rows; ++row)
        {
            for (uint32 col = row + 1; col < shape.cols; ++col)
            {
                lMatrix(row, col) = 0.;
            }
        }

        for (uint32 k = 0; k < shape.cols; ++k)
        {
            const double& a_kk = lMatrix(k, k);

            if (a_kk > 0.)
            {
                lMatrix(k, k) = std::sqrt(a_kk);

                for (uint32 i = k + 1; i < shape.rows; ++i)
                {
                    lMatrix(i, k) /= lMatrix(k, k);

                    for (uint32 j = k + 1; j <= i; ++j)
                    {
                        lMatrix(i, j) -= lMatrix(i, k) * lMatrix(j, k);
                    }
                }
            }
            else
            {
                THROW_RUNTIME_ERROR("Matrix is not positive definite.");
            }
        }

        return lMatrix;
    }
} // namespace nc::linalg

/*** End of inlined file: cholesky.hpp ***/


/*** Start of inlined file: gaussNewtonNlls.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// The Gauss�Newton algorithm is used to solve non-linear least squares problems.
/// It is a modification of Newton's method for finding a minimum of a function.
///
/// https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm
#pragma once

#include <array>
#include <functional>
#include <type_traits>
#include <utility>

namespace nc::linalg
{

    // Method Description:
    /// The Gauss�Newton algorithm is used to solve non-linear least squares problems.
    /// It is a modification of Newton's method for finding a minimum of a function.
    /// https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm
    ///
    /// @param numIterations: the number of iterations to perform
    /// @param coordinates: the coordinate values.  The shape needs to be [n x d], where d is
    /// the number of diminsions of the fit function (f(x) is one dimensional,
    /// f(x, y) is two dimensions, etc), and n is the number of observations
    /// that are being fit to.
    /// @param measurements: the measured values that are being fit
    /// @param function: a std::function of the function that is being fit. The function takes as
    /// inputs an NdArray of a single set of the coordinate values, and an NdArray
    /// of the current values of the fit parameters
    /// @param derivatives: array of std::functions to calculate the function
    /// derivatives. The function that is being fit. The function takes as
    /// inputs an NdArray of a single set of the coordinate values, and an NdArray
    /// of the current values of the fit parameters
    /// @param initialGuess: the initial guess of the parameters to be solved for
    ///
    /// @return std::pair of NdArray of solved parameter values, and rms of the residuals value
    ///
    template<typename dtype,
             typename... Params,
             std::enable_if_t<std::is_arithmetic_v<dtype>, int>  = 0,
             std::enable_if_t<all_arithmetic_v<Params...>, int>  = 0,
             std::enable_if_t<all_same_v<dtype, Params...>, int> = 0>
    std::pair<NdArray<double>, double>
        gaussNewtonNlls(const uint32                                                              numIterations,
                        const NdArray<dtype>&                                                     coordinates,
                        const NdArray<dtype>&                                                     measurements,
                        const std::function<dtype(const NdArray<dtype>&, const NdArray<dtype>&)>& function,
                        const std::array<std::function<dtype(const NdArray<dtype>&, const NdArray<dtype>&)>,
                                         sizeof...(Params)>&                                      derivatives,
                        Params... initialGuess)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto coordinatesShape = coordinates.shape();

        if (coordinatesShape.rows != measurements.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("coordinates number of rows, and measurements size must be the same.");
        }

        NdArray<double> beta = NdArray<dtype>({ initialGuess... }).template astype<double>().transpose();
        NdArray<double> residuals(coordinatesShape.rows, 1);
        NdArray<double> jacobian(coordinatesShape.rows, sizeof...(Params));

        const auto colSlice = coordinates.cSlice();
        for (uint32 iteration = 1; iteration <= numIterations; ++iteration)
        {
            for (uint32 measIdx = 0; measIdx < coordinatesShape.rows; ++measIdx)
            {
                const auto coordinate = coordinates(measIdx, colSlice);

                residuals[measIdx] =
                    static_cast<double>(measurements[measIdx]) - static_cast<double>(function(coordinate, beta));

                for (uint32 paramIdx = 0; paramIdx < sizeof...(Params); ++paramIdx)
                {
                    const auto& derivative      = derivatives[paramIdx];
                    jacobian(measIdx, paramIdx) = static_cast<double>(derivative(coordinate, beta));
                }
            }

            // perform the gauss-newton linear algebra
            const auto jacobianT             = jacobian.transpose();
            const auto jacobianPsuedoInverse = linalg::inv(jacobianT.dot(jacobian));
            const auto intermediate          = jacobianPsuedoInverse.dot(jacobianT);
            const auto deltaBeta             = intermediate.dot(residuals);
            beta += deltaBeta;
        }

        // calculate the final rms of the residuals
        for (uint32 measIdx = 0; measIdx < coordinatesShape.rows; ++measIdx)
        {
            const auto coordinate = coordinates(measIdx, colSlice);

            residuals[measIdx] =
                static_cast<double>(measurements[measIdx]) - static_cast<double>(function(coordinate, beta));
        }

        return std::make_pair(beta.flatten(), rms(residuals).item());
    }
} // namespace nc::linalg

/*** End of inlined file: gaussNewtonNlls.hpp ***/


/*** Start of inlined file: lstsq.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// linear least squares
///
#pragma once


/*** Start of inlined file: SVDClass.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2020 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Performs the singular value decomposition of a general matrix,
/// taken and adapted from Numerical Recipes Third Edition svd.h
///
#pragma once

#include <cmath>
#include <limits>
#include <string>

namespace nc::linalg
{
    // =============================================================================
    // Class Description:
    /// performs the singular value decomposition of a general matrix,
    /// taken and adapted from Numerical Recipes Third Edition svd.h
    class SVD
    {
    public:
        // =============================================================================
        // Description:
        /// Constructor
        ///
        /// @param inMatrix: matrix to perform SVD on
        ///
        explicit SVD(const NdArray<double>& inMatrix) :
            m_(inMatrix.shape().rows),
            n_(inMatrix.shape().cols),
            u_(inMatrix),
            v_(n_, n_),
            s_(1, n_),
            eps_(std::numeric_limits<double>::epsilon())
        {
            decompose();
            reorder();
            tsh_ = 0.5 * std::sqrt(m_ + n_ + 1.) * s_.front() * eps_;
        }

        // =============================================================================
        // Description:
        /// the resultant u matrix
        ///
        /// @return u matrix
        ///
        const NdArray<double>& u() noexcept
        {
            return u_;
        }

        // =============================================================================
        // Description:
        /// the resultant v matrix
        ///
        /// @return v matrix
        ///
        const NdArray<double>& v() noexcept
        {
            return v_;
        }

        // =============================================================================
        // Description:
        /// the resultant w matrix
        ///
        /// @return s matrix
        ///
        const NdArray<double>& s() noexcept
        {
            return s_;
        }

        // =============================================================================
        // Description:
        /// solves the linear least squares problem
        ///
        /// @param inInput
        /// @param inThresh (default -1.)
        ///
        /// @return NdArray
        ///
        NdArray<double> solve(const NdArray<double>& inInput, double inThresh = -1.)
        {
            double ss{};

            if (inInput.size() != m_)
            {
                THROW_INVALID_ARGUMENT_ERROR("bad sizes.");
            }

            NdArray<double> returnArray(1, n_);

            NdArray<double> tmp(1, n_);

            tsh_ = (inThresh >= 0. ? inThresh : 0.5 * sqrt(m_ + n_ + 1.) * s_.front() * eps_);

            for (uint32 j = 0; j < n_; j++)
            {
                ss = 0.;
                if (s_[j] > tsh_)
                {
                    for (uint32 i = 0; i < m_; i++)
                    {
                        ss += u_(i, j) * inInput[i];
                    }
                    ss /= s_[j];
                }
                tmp[j] = ss;
            }

            for (uint32 j = 0; j < n_; j++)
            {
                ss = 0.;
                for (uint32 jj = 0; jj < n_; jj++)
                {
                    ss += v_(j, jj) * tmp[jj];
                }

                returnArray[j] = ss;
            }

            return returnArray;
        }

    private:
        // =============================================================================
        // Description:
        /// returns the SIGN of two values
        ///
        /// @param inA
        /// @param inB
        ///
        /// @return value
        ///
        static double SIGN(double inA, double inB) noexcept
        {
            return inB >= 0 ? (inA >= 0 ? inA : -inA) : (inA >= 0 ? -inA : inA);
        }

        // =============================================================================
        // Description:
        /// decomposes the input matrix
        ///
        void decompose()
        {
            bool   flag{};
            uint32 i{};
            uint32 its{};
            uint32 j{};
            uint32 jj{};
            uint32 k{};
            uint32 l{};
            uint32 nm{};

            double anorm{};
            double c{};
            double f{};
            double g{};
            double h{};
            double ss{};
            double scale{};
            double x{};
            double y{};
            double z{};

            NdArray<double> rv1(n_, 1);

            for (i = 0; i < n_; ++i)
            {
                l      = i + 2;
                rv1[i] = scale * g;
                g = ss = scale = 0.;

                if (i < m_)
                {
                    for (k = i; k < m_; ++k)
                    {
                        scale += std::abs(u_(k, i));
                    }

                    if (!utils::essentiallyEqual(scale, 0.))
                    {
                        for (k = i; k < m_; ++k)
                        {
                            u_(k, i) /= scale;
                            ss += u_(k, i) * u_(k, i);
                        }

                        f        = u_(i, i);
                        g        = -SIGN(std::sqrt(ss), f);
                        h        = f * g - ss;
                        u_(i, i) = f - g;

                        for (j = l - 1; j < n_; ++j)
                        {
                            for (ss = 0., k = i; k < m_; ++k)
                            {
                                ss += u_(k, i) * u_(k, j);
                            }

                            f = ss / h;

                            for (k = i; k < m_; ++k)
                            {
                                u_(k, j) += f * u_(k, i);
                            }
                        }

                        for (k = i; k < m_; ++k)
                        {
                            u_(k, i) *= scale;
                        }
                    }
                }

                s_[i] = scale * g;
                g = ss = scale = 0.;

                if (i + 1 <= m_ && i + 1 != n_)
                {
                    for (k = l - 1; k < n_; ++k)
                    {
                        scale += std::abs(u_(i, k));
                    }

                    if (!utils::essentiallyEqual(scale, 0.))
                    {
                        for (k = l - 1; k < n_; ++k)
                        {
                            u_(i, k) /= scale;
                            ss += u_(i, k) * u_(i, k);
                        }

                        f            = u_(i, l - 1);
                        g            = -SIGN(std::sqrt(ss), f);
                        h            = f * g - ss;
                        u_(i, l - 1) = f - g;

                        for (k = l - 1; k < n_; ++k)
                        {
                            rv1[k] = u_(i, k) / h;
                        }

                        for (j = l - 1; j < m_; ++j)
                        {
                            for (ss = 0., k = l - 1; k < n_; ++k)
                            {
                                ss += u_(j, k) * u_(i, k);
                            }

                            for (k = l - 1; k < n_; ++k)
                            {
                                u_(j, k) += ss * rv1[k];
                            }
                        }

                        for (k = l - 1; k < n_; ++k)
                        {
                            u_(i, k) *= scale;
                        }
                    }
                }

                anorm = std::max(anorm, (std::abs(s_[i]) + std::abs(rv1[i])));
            }

            for (i = n_ - 1; i != static_cast<uint32>(-1); --i)
            {
                if (i < n_ - 1)
                {
                    if (!utils::essentiallyEqual(g, 0.))
                    {
                        for (j = l; j < n_; ++j)
                        {
                            v_(j, i) = (u_(i, j) / u_(i, l)) / g;
                        }

                        for (j = l; j < n_; ++j)
                        {
                            for (ss = 0., k = l; k < n_; ++k)
                            {
                                ss += u_(i, k) * v_(k, j);
                            }

                            for (k = l; k < n_; ++k)
                            {
                                v_(k, j) += ss * v_(k, i);
                            }
                        }
                    }

                    for (j = l; j < n_; ++j)
                    {
                        v_(i, j) = v_(j, i) = 0.;
                    }
                }

                v_(i, i) = 1.;
                g        = rv1[i];
                l        = i;
            }

            for (i = std::min(m_, n_) - 1; i != static_cast<uint32>(-1); --i)
            {
                l = i + 1;
                g = s_[i];

                for (j = l; j < n_; ++j)
                {
                    u_(i, j) = 0.;
                }

                if (!utils::essentiallyEqual(g, 0.))
                {
                    g = 1. / g;

                    for (j = l; j < n_; ++j)
                    {
                        for (ss = 0., k = l; k < m_; ++k)
                        {
                            ss += u_(k, i) * u_(k, j);
                        }

                        f = (ss / u_(i, i)) * g;

                        for (k = i; k < m_; ++k)
                        {
                            u_(k, j) += f * u_(k, i);
                        }
                    }

                    for (j = i; j < m_; ++j)
                    {
                        u_(j, i) *= g;
                    }
                }
                else
                {
                    for (j = i; j < m_; ++j)
                    {
                        u_(j, i) = 0.;
                    }
                }

                ++u_(i, i);
            }

            for (k = n_ - 1; k != static_cast<uint32>(-1); --k)
            {
                for (its = 0; its < 30; ++its)
                {
                    flag = true;
                    for (l = k; l != static_cast<uint32>(-1); --l)
                    {
                        nm = l - 1;
                        if (l == 0 || std::abs(rv1[l]) <= eps_ * anorm)
                        {
                            flag = false;
                            break;
                        }

                        if (std::abs(s_[nm]) <= eps_ * anorm)
                        {
                            break;
                        }
                    }

                    if (flag)
                    {
                        c  = 0.;
                        ss = 1.;
                        for (i = l; i < k + 1; ++i)
                        {
                            f      = ss * rv1[i];
                            rv1[i] = c * rv1[i];

                            if (std::abs(f) <= eps_ * anorm)
                            {
                                break;
                            }

                            g     = s_[i];
                            h     = pythag(f, g);
                            s_[i] = h;
                            h     = 1. / h;
                            c     = g * h;
                            ss    = -f * h;

                            for (j = 0; j < m_; ++j)
                            {
                                y         = u_(j, nm);
                                z         = u_(j, i);
                                u_(j, nm) = y * c + z * ss;
                                u_(j, i)  = z * c - y * ss;
                            }
                        }
                    }

                    z = s_[k];
                    if (l == k)
                    {
                        if (z < 0.)
                        {
                            s_[k] = -z;
                            for (j = 0; j < n_; ++j)
                            {
                                v_(j, k) = -v_(j, k);
                            }
                        }
                        break;
                    }

                    if (its == 29)
                    {
                        THROW_INVALID_ARGUMENT_ERROR("no convergence in 30 svdcmp iterations");
                    }

                    x  = s_[l];
                    nm = k - 1;
                    y  = s_[nm];
                    g  = rv1[nm];
                    h  = rv1[k];
                    f  = ((y - z) * (y + z) + (g - h) * (g + h)) / (2. * h * y);
                    g  = pythag(f, 1.);
                    f  = ((x - z) * (x + z) + h * ((y / (f + SIGN(g, f))) - h)) / x;
                    c = ss = 1.;

                    for (j = l; j <= nm; j++)
                    {
                        i      = j + 1;
                        g      = rv1[i];
                        y      = s_[i];
                        h      = ss * g;
                        g      = c * g;
                        z      = pythag(f, h);
                        rv1[j] = z;
                        c      = f / z;
                        ss     = h / z;
                        f      = x * c + g * ss;
                        g      = g * c - x * ss;
                        h      = y * ss;
                        y *= c;

                        for (jj = 0; jj < n_; ++jj)
                        {
                            x         = v_(jj, j);
                            z         = v_(jj, i);
                            v_(jj, j) = x * c + z * ss;
                            v_(jj, i) = z * c - x * ss;
                        }

                        z     = pythag(f, h);
                        s_[j] = z;

                        if (!utils::essentiallyEqual(z, 0.))
                        {
                            z  = 1. / z;
                            c  = f * z;
                            ss = h * z;
                        }

                        f = c * g + ss * y;
                        x = c * y - ss * g;

                        for (jj = 0; jj < m_; ++jj)
                        {
                            y         = u_(jj, j);
                            z         = u_(jj, i);
                            u_(jj, j) = y * c + z * ss;
                            u_(jj, i) = z * c - y * ss;
                        }
                    }
                    rv1[l] = 0.;
                    rv1[k] = f;
                    s_[k]  = x;
                }
            }
        }

        // =============================================================================
        // Description:
        /// reorders the input matrix
        ///
        void reorder()
        {
            uint32 i   = 0;
            uint32 j   = 0;
            uint32 k   = 0;
            uint32 ss  = 0;
            uint32 inc = 1;

            double          sw{};
            NdArray<double> su(m_, 1);
            NdArray<double> sv(n_, 1);

            do
            {
                inc *= 3;
                ++inc;
            } while (inc <= n_);

            do
            {
                inc /= 3;
                for (i = inc; i < n_; ++i)
                {
                    sw = s_[i];
                    for (k = 0; k < m_; ++k)
                    {
                        su[k] = u_(k, i);
                    }

                    for (k = 0; k < n_; ++k)
                    {
                        sv[k] = v_(k, i);
                    }

                    j = i;
                    while (s_[j - inc] < sw)
                    {
                        s_[j] = s_[j - inc];

                        for (k = 0; k < m_; ++k)
                        {
                            u_(k, j) = u_(k, j - inc);
                        }

                        for (k = 0; k < n_; ++k)
                        {
                            v_(k, j) = v_(k, j - inc);
                        }

                        j -= inc;

                        if (j < inc)
                        {
                            break;
                        }
                    }

                    s_[j] = sw;

                    for (k = 0; k < m_; ++k)
                    {
                        u_(k, j) = su[k];
                    }

                    for (k = 0; k < n_; ++k)
                    {
                        v_(k, j) = sv[k];
                    }
                }
            } while (inc > 1);

            for (k = 0; k < n_; ++k)
            {
                ss = 0;

                for (i = 0; i < m_; i++)
                {
                    if (u_(i, k) < 0.)
                    {
                        ss++;
                    }
                }

                for (j = 0; j < n_; ++j)
                {
                    if (v_(j, k) < 0.)
                    {
                        ss++;
                    }
                }

                if (ss > (m_ + n_) / 2)
                {
                    for (i = 0; i < m_; ++i)
                    {
                        u_(i, k) = -u_(i, k);
                    }

                    for (j = 0; j < n_; ++j)
                    {
                        v_(j, k) = -v_(j, k);
                    }
                }
            }
        }

        // =============================================================================
        // Description:
        /// performs pythag of input values
        ///
        /// @param inA
        /// @param inB
        ///
        /// @return resultant value
        ///
        static double pythag(double inA, double inB) noexcept
        {
            const double absa = std::abs(inA);
            const double absb = std::abs(inB);
            return (absa > absb
                        ? absa * std::sqrt(1. + utils::sqr(absb / absa))
                        : (utils::essentiallyEqual(absb, 0.) ? 0. : absb * std::sqrt(1. + utils::sqr(absa / absb))));
        }

    private:
        // ===============================Attributes====================================
        const uint32    m_{};
        const uint32    n_{};
        NdArray<double> u_{};
        NdArray<double> v_{};
        NdArray<double> s_{};
        double          eps_{};
        double          tsh_{};
    };
} // namespace nc::linalg

/*** End of inlined file: SVDClass.hpp ***/

namespace nc::linalg
{

    // Method Description:
    /// Solves the equation a x = b by computing a vector x
    /// that minimizes the Euclidean 2-norm || b - a x ||^2.
    /// The equation may be under-, well-, or over- determined
    /// (i.e., the number of linearly independent rows of a can
    /// be less than, equal to, or greater than its number of
    /// linearly independent columns). If a is square and of
    /// full rank, then x (but for round-off error) is the
    /// "exact" solution of the equation.
    ///
    /// SciPy Reference:
    /// https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    ///
    /// @param inA: coefficient matrix
    /// @param inB: Ordinate or "dependent variable" values
    /// @param inTolerance (default 1e-12)
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> lstsq(const NdArray<dtype>& inA, const NdArray<dtype>& inB, double inTolerance = 1e-12)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        SVD          svdSolver(inA.template astype<double>());
        const double threshold = inTolerance * svdSolver.s().front();

        return svdSolver.solve(inB.template astype<double>(), threshold);
    }
} // namespace nc::linalg

/*** End of inlined file: lstsq.hpp ***/


/*** Start of inlined file: lu_decomposition.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix pivot LU decomposition
///
/// Code modified under MIT license from https://github.com/Ben1980/linAlg
/// as posted in
/// https://thoughts-on-coding.com/2019/06/12/numerical-methods-with-c-part-4-introduction-into-decomposition-methods-of-linear-equation-systems/
///
#pragma once

#include <cmath>
#include <utility>

namespace nc::linalg
{

    // Method Description:
    /// matrix LU decomposition A = LU
    ///
    /// @param inMatrix: NdArray to be decomposed
    ///
    /// @return std::pair<NdArray, NdArray> of the decomposed L and U matrices
    ///
    template<typename dtype>
    std::pair<NdArray<double>, NdArray<double>> lu_decomposition(const NdArray<dtype>& inMatrix)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto shape = inMatrix.shape();
        if (!shape.issquare())
        {
            THROW_RUNTIME_ERROR("Input matrix should be square.");
        }

        NdArray<double> lMatrix = zeros_like<double>(inMatrix);
        NdArray<double> uMatrix = inMatrix.template astype<double>();

        for (uint32 col = 0; col < shape.cols; ++col)
        {
            lMatrix(col, col) = 1;

            for (uint32 row = col + 1; row < shape.rows; ++row)
            {
                const double& divisor = uMatrix(col, col);
                if (utils::essentiallyEqual(divisor, double{ 0. }))
                {
                    THROW_RUNTIME_ERROR("Division by 0.");
                }

                lMatrix(row, col) = uMatrix(row, col) / divisor;

                for (uint32 col2 = col; col2 < shape.cols; ++col2)
                {
                    uMatrix(row, col2) -= lMatrix(row, col) * uMatrix(col, col2);
                }
            }
        }

        return std::make_pair(lMatrix, uMatrix);
    }
} // namespace nc::linalg

/*** End of inlined file: lu_decomposition.hpp ***/


/*** Start of inlined file: matrix_power.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Raise a square matrix to the (integer) power n.
///
#pragma once

#include <string>

namespace nc::linalg
{

    // Method Description:
    /// Raise a square matrix to the (integer) power n.
    ///
    /// For positive integers n, the power is computed by repeated
    /// matrix squarings and matrix multiplications.  If n == 0,
    /// the identity matrix of the same shape as M is returned.
    /// If n < 0, the inverse is computed and then raised to the abs(n).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html#numpy.linalg.matrix_power
    ///
    /// @param inArray
    /// @param inPower
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> matrix_power(const NdArray<dtype>& inArray, int16 inPower)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        const Shape inShape = inArray.shape();
        if (inShape.rows != inShape.cols)
        {
            THROW_INVALID_ARGUMENT_ERROR("input matrix must be square.");
        }

        if (inPower == 0)
        {
            return identity<double>(inShape.rows);
        }

        if (inPower == 1)
        {
            return inArray.template astype<double>();
        }

        if (inPower == -1)
        {
            return inv(inArray);
        }

        if (inPower > 1)
        {
            NdArray<double> inArrayDouble = inArray.template astype<double>();
            NdArray<double> returnArray   = dot(inArrayDouble, inArrayDouble);
            for (int16 i = 2; i < inPower; ++i)
            {
                returnArray = dot(returnArray, inArrayDouble);
            }
            return returnArray;
        }

        NdArray<double> inverse     = inv(inArray);
        NdArray<double> returnArray = dot(inverse, inverse);
        inPower *= -1;
        for (int16 i = 2; i < inPower; ++i)
        {
            returnArray = dot(returnArray, inverse);
        }
        return returnArray;
    }
} // namespace nc::linalg

/*** End of inlined file: matrix_power.hpp ***/


/*** Start of inlined file: multi_dot.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Compute the dot product of two or more arrays in a single function call.
///
#pragma once

#include <initializer_list>
#include <string>

namespace nc::linalg
{

    // Method Description:
    /// Compute the dot product of two or more arrays in a single
    /// function call.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.multi_dot.html#numpy.linalg.multi_dot
    ///
    /// @param inList: list of arrays
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> multi_dot(const std::initializer_list<NdArray<dtype>>& inList)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        typename std::initializer_list<NdArray<dtype>>::iterator iter = inList.begin();

        if (inList.size() == 0)
        {
            THROW_INVALID_ARGUMENT_ERROR("input empty list of arrays.");
        }
        else if (inList.size() == 1)
        {
            return iter->copy();
        }

        NdArray<dtype> returnArray = dot<dtype>(*iter, *(iter + 1));
        iter += 2;
        for (; iter < inList.end(); ++iter)
        {
            returnArray = dot(returnArray, *iter);
        }

        return returnArray;
    }
} // namespace nc::linalg

/*** End of inlined file: multi_dot.hpp ***/


/*** Start of inlined file: pinv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix psuedo-inverse
///
#pragma once

#include <string>


/*** Start of inlined file: svd.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix svd
///
#pragma once

#include <utility>

namespace nc::linalg
{

    // Method Description:
    /// matrix svd
    ///
    /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    ///
    /// @param inArray: NdArray to be SVDed
    /// @param outU: NdArray output U
    /// @param outS: NdArray output S
    /// @param outVt: NdArray output V transpose
    ///
    template<typename dtype>
    void svd(const NdArray<dtype>& inArray, NdArray<double>& outU, NdArray<double>& outS, NdArray<double>& outVt)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        SVD svdSolver(inArray.template astype<double>());
        outU = svdSolver.u();

        NdArray<double> vt = svdSolver.v().transpose();
        outVt              = std::move(vt);

        NdArray<double> s = diagflat(svdSolver.s(), 0);
        outS              = std::move(s);
    }
} // namespace nc::linalg

/*** End of inlined file: svd.hpp ***/

namespace nc::linalg
{

    // Method Description:
    /// matrix psuedo-inverse
    ///
    /// NumPy Reference: https://numpy.org/doc/stable/reference/generated/numpy.linalg.pinv.html
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<double> pinv(const NdArray<dtype>& inArray)
    {
        STATIC_ASSERT_ARITHMETIC_OR_COMPLEX(dtype);

        NdArray<double> u;
        NdArray<double> d;
        NdArray<double> v;
        svd(inArray, u, d, v);

        const auto inShape = inArray.shape();
        auto       dPlus   = nc::zeros<double>(inShape.cols, inShape.rows); // transpose

        for (uint32 i = 0; i < d.shape().rows; ++i)
        {
            dPlus(i, i) = 1. / d(i, i);
        }

        return v.transpose().dot(dPlus).dot(u.transpose());
    }
} // namespace nc::linalg
/*** End of inlined file: pinv.hpp ***/


/*** Start of inlined file: pivotLU_decomposition.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix pivot LU decomposition
///
/// Code modified under MIT license from https://github.com/Ben1980/linAlg
/// as posted in
/// https://thoughts-on-coding.com/2019/06/12/numerical-methods-with-c-part-4-introduction-into-decomposition-methods-of-linear-equation-systems/
///
#pragma once

#include <cmath>
#include <tuple>

namespace nc::linalg
{

    // Method Description:
    /// matrix pivot LU decomposition PA = LU
    ///
    /// @param inMatrix: NdArray to be decomposed
    ///
    /// @return std::tuple<NdArray, NdArray, NdArray> of the decomposed L, U, and P matrices
    ///
    template<typename dtype>
    std::tuple<NdArray<double>, NdArray<double>, NdArray<double>> pivotLU_decomposition(const NdArray<dtype>& inMatrix)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto shape = inMatrix.shape();

        if (!shape.issquare())
        {
            THROW_RUNTIME_ERROR("Input matrix should be square.");
        }

        NdArray<double> lMatrix = zeros_like<double>(inMatrix);
        NdArray<double> uMatrix = inMatrix.template astype<double>();
        NdArray<double> pMatrix = eye<double>(shape.rows);

        for (uint32 k = 0; k < shape.rows; ++k)
        {
            double max = 0.;
            uint32 pk  = 0;
            for (uint32 i = k; i < shape.rows; ++i)
            {
                double s = 0.;
                for (uint32 j = k; j < shape.cols; ++j)
                {
                    s += std::fabs(uMatrix(i, j));
                }

                const double q = std::fabs(uMatrix(i, k)) / s;
                if (q > max)
                {
                    max = q;
                    pk  = i;
                }
            }

            if (utils::essentiallyEqual(max, double{ 0. }))
            {
                THROW_RUNTIME_ERROR("Division by 0.");
            }

            if (pk != k)
            {
                for (uint32 j = 0; j < shape.cols; ++j)
                {
                    std::swap(pMatrix(k, j), pMatrix(pk, j));
                    std::swap(lMatrix(k, j), lMatrix(pk, j));
                    std::swap(uMatrix(k, j), uMatrix(pk, j));
                }
            }

            for (uint32 i = k + 1; i < shape.rows; ++i)
            {
                lMatrix(i, k) = uMatrix(i, k) / uMatrix(k, k);

                for (uint32 j = k; j < shape.cols; ++j)
                {
                    uMatrix(i, j) = uMatrix(i, j) - lMatrix(i, k) * uMatrix(k, j);
                }
            }
        }

        for (uint32 k = 0; k < shape.rows; ++k)
        {
            lMatrix(k, k) = 1.;
        }

        return std::make_tuple(lMatrix, uMatrix, pMatrix);
    }
} // namespace nc::linalg

/*** End of inlined file: pivotLU_decomposition.hpp ***/


/*** Start of inlined file: solve.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// matrix svd
///
#pragma once

namespace nc::linalg
{

    // Method Description:
    /// Solve a linear matrix equation, or system of linear scalar equations.
    /// Computes the “exact” solution, x, of the well-determined, i.e., full rank,
    /// linear matrix equation ax = b.
    ///
    /// https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html
    ///
    /// @param inA
    /// @param inB
    /// @return NdArray<double> Solution to the system a x = b. Returned shape is identical to b
    ///
    template<typename dtype>
    NdArray<double> solve(const NdArray<dtype>& inA, const NdArray<dtype>& inB)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (!inA.issquare())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array a must be square.");
        }

        if (!inB.isflat())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array b must be flat.");
        }

        if (inA.numCols() != inB.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("input array b size must be the same as the square size of a.");
        }

        return dot(inv(inA), inB.template astype<double>().reshape(inB.size(), 1)).reshape(inB.shape());
    }
} // namespace nc::linalg

/*** End of inlined file: solve.hpp ***/

/*** End of inlined file: Linalg.hpp ***/


/*** Start of inlined file: Logging.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Image and signal filtering module
///
#pragma once


/*** Start of inlined file: BinaryLogger.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Binary data logger
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <type_traits>
#include <typeinfo>

#include "boost/algorithm/string.hpp"
#include "boost/core/demangle.hpp"

namespace nc::logger
{
    namespace detail
    {
        namespace type_traits
        {
            /**
             * @brief type trait to check if a type has a serialize method with the correct signature
             */
            template<typename DataType>
            using serialize_t = decltype(std::declval<DataType>().serialize());

            /**
             * @brief type trait to check if a type has a serialize method with the correct signature
             */
            template<typename DataType, typename = std::void_t<>>
            class has_serialize : std::false_type
            {
            public:
                static constexpr bool value = false;
            };

            /**
             * @brief type trait to check if a type has a serialize method with the correct signature
             */
            template<typename DataType>
            class has_serialize<DataType,
                                std::void_t<std::enable_if_t<std::is_same_v<serialize_t<DataType>, std::string>, int>>>
            {
            public:
                static constexpr bool value = true;
            };

            /**
             * @brief type trait to check if a type has a serialize method with the correct signature
             */
            template<typename DataType>
            inline constexpr bool has_serialize_v = has_serialize<DataType>::value;
        } // namespace type_traits

        /**
         * @brief Binary Logger
         */
        template<typename DataType>
        class BinaryDataLogger
        {
        public:
            using value_type      = DataType;
            using const_pointer   = const DataType* const;
            using const_reference = const DataType&;

            // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, hicpp-avoid-c-arrays, modernize-avoid-c-arrays)
            static constexpr char LOG_EXT[]                      = ".log";
            static constexpr auto DATA_ELEMENT_SIZE              = sizeof(value_type);
            static constexpr auto DATE_TYPE_HAS_SERIALIZE_METHOD = type_traits::has_serialize_v<value_type>;

            /**
             * @brief Default constructor
             */
            BinaryDataLogger() { }

            /**
             * @brief Constructor
             * @param outputDir: the directory to place the output log
             */
            explicit BinaryDataLogger(std::filesystem::path outputDir)
            {
                setOutputDir(outputDir);
            }

            /**
             * @brief Constructor
             * @param outputDir: the directory to place the output log
             */
            explicit BinaryDataLogger(std::string_view outputDir) :
                BinaryDataLogger(std::filesystem::path(outputDir))
            {
            }

            /**
             * @brief Destructor
             */
            ~BinaryDataLogger()
            {
                ofile_.close();
            }

            // explicitly delete
            BinaryDataLogger(const BinaryDataLogger&)            = delete;
            BinaryDataLogger(BinaryDataLogger&&)                 = delete;
            BinaryDataLogger& operator=(const BinaryDataLogger&) = delete;
            BinaryDataLogger& operator=(BinaryDataLogger&&)      = delete;

            /**
             * @brief The log file path
             */
            const std::filesystem::path& filepath() const noexcept
            {
                return filepath_;
            }

            /**
             * @brief Sets the output log directory.
             *
             * @param outputDir: the output directory
             */
            void setOutputDir(std::filesystem::path outputDir)
            {
                if (std::filesystem::is_directory(outputDir))
                {
                    auto dataTypeName = boost::core::demangle(typeid(DataType).name());
                    boost::algorithm::replace_all(dataTypeName, "::", "_");
                    boost::algorithm::replace_all(dataTypeName, "<", "_");
                    boost::algorithm::replace_all(dataTypeName, ">", "_");
                    const auto filename = std::filesystem::path(dataTypeName).replace_extension(LOG_EXT);
                    filepath_           = std::filesystem::canonical(outputDir) / filename;

                    ofile_ = std::ofstream(filepath_.c_str(), std::ios::out | std::ios::binary);
                    if (!ofile_.good())
                    {
                        throw std::runtime_error("Unable to open the log file:\n\t" + filepath_.string());
                    }
                }
                else
                {
                    throw std::runtime_error("The provided output log directory is not valid:\n\t" +
                                             outputDir.string());
                }
            }

            /**
             * @brief Sets the output log directory.
             *
             * @param outputDir: the output directory
             */
            void setOutputDir(std::string_view outputDir)
            {
                setOutputDir(std::filesystem::path(outputDir));
            }

            /**
             * @brief Enable the logger
             */
            void enable() noexcept
            {
                enabled_ = true;
            }

            /**
             * @brief Disable the logger
             */
            void disable() noexcept
            {
                enabled_ = false;
            }

            /**
             * @brief Checks whether logger is enabled
             */
            bool isEnabled() noexcept
            {
                return enabled_;
            }

            /**
             * @brief Force a flush of the output stream
             */
            void flush()
            {
                ofile_.flush();
            }

            /**
             * @brief Logs the data element
             * @param dataElement: the data element
             */
            void log(const_reference dataElement)
            {
                if (!enabled_)
                {
                    return;
                }

                if (filepath_.empty())
                {
                    throw std::runtime_error("The output log directory does not exist");
                }

                if constexpr (DATE_TYPE_HAS_SERIALIZE_METHOD)
                {
                    const auto serializedData = dataElement.serialize();
                    ofile_.write(serializedData.data(), serializedData.size());
                }
                else
                {
                    ofile_.write(reinterpret_cast<const char*>(&dataElement), DATA_ELEMENT_SIZE);
                }
            }

            /**
             * @brief Logs the data elements
             * @param dataElements: the data element pointer
             * @param numElements: the number of data elements to log
             */
            void log(const_pointer dataElements, std::size_t numElements)
            {
                if (!enabled_)
                {
                    return;
                }

                if (filepath_.empty())
                {
                    throw std::runtime_error("The output log directory does not exist");
                }

                std::for_each(dataElements,
                              dataElements + numElements,
                              [this](const_reference dataElement) { log(dataElement); });
            }

        private:
            std::filesystem::path filepath_{};
            std::ofstream         ofile_;
            bool                  enabled_{ true };
        };
    } // namespace detail

    /**
     * @brief Binary Logger Singleton
     */
    class BinaryLogger
    {
    public:
        // explicitly delete
        BinaryLogger(const BinaryLogger&)            = delete;
        BinaryLogger(BinaryLogger&&)                 = delete;
        BinaryLogger& operator=(const BinaryLogger&) = delete;
        BinaryLogger& operator=(BinaryLogger&&)      = delete;

        /**
         * @brief Singleton instance getter
         *
         * @returns: singleton instance of BinaryLogger
         */
        static BinaryLogger& getInstance() noexcept
        {
            static BinaryLogger binaryLogger;
            return binaryLogger;
        }

        /**
         * @brief Sets the output directory. This should be called BEFORE any type loggers
         *        have been created, and will NOT reset the output directory afterwards!
         *
         * @param outputDir: the output directory
         */
        void setOutputDir(const std::filesystem::path& outputDir)
        {
            if (!std::filesystem::is_directory(outputDir))
            {
                throw std::runtime_error("outputDir does not exist");
            }

            outputDir_ = outputDir;
        }

        /**
         * @brief Sets the output directory. This should be called BEFORE any type loggers
         *        have been created, and will NOT reset the output directory afterwards!
         *
         * @param outputDir: the output directory
         */
        void setOutputDir(std::string_view outputDir)
        {
            setOutputDir(std::filesystem::path(outputDir));
        }

        /**
         * @brief Gets the logger instance for the specific data type
         *
         * @returns data type logger instance
         */
        template<typename DataType>
        detail::BinaryDataLogger<DataType>& getTypeLogger()
        {
            static detail::BinaryDataLogger<DataType> typeLogger(outputDir_);
            return typeLogger;
        }

    private:
        std::filesystem::path outputDir_{ "." };

        /**
         * @brief Constructor
         */
        BinaryLogger() = default;
    };
} // namespace nc::logger

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: BinaryLogger.hpp ***/


/*** Start of inlined file: Logger.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Text file loggger
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <filesystem>
#include <fstream>
#include <ostream>
#include <sstream>
#include <string>

#include "boost/core/null_deleter.hpp"
#include "boost/log/attributes.hpp"
#include "boost/log/core/core.hpp"
#include "boost/log/expressions.hpp"
#include "boost/log/expressions/formatters/date_time.hpp"
#include "boost/log/sinks/sync_frontend.hpp"
#include "boost/log/sinks/text_ostream_backend.hpp"
#include "boost/log/sources/global_logger_storage.hpp"
#include "boost/log/sources/severity_logger.hpp"
#include "boost/log/support/date_time.hpp"
#include "boost/log/trivial.hpp"
#include "boost/log/utility/manipulators/add_value.hpp"
#include "boost/log/utility/setup/common_attributes.hpp"
#include "boost/make_shared.hpp"
#include "boost/shared_ptr.hpp"

namespace nc::logger
{
    /**
     * @brief Register a global logger
     */
    BOOST_LOG_GLOBAL_LOGGER(fileLogger, boost::log::sources::severity_logger_mt<boost::log::trivial::severity_level>)

    /**
     * Boost log attributes
     */
    BOOST_LOG_ATTRIBUTE_KEYWORD(lineId, "LineID", uint32_t)
    BOOST_LOG_ATTRIBUTE_KEYWORD(timestamp, "TimeStamp", boost::posix_time::ptime)
    BOOST_LOG_ATTRIBUTE_KEYWORD(severity, "Severity", boost::log::trivial::severity_level)
    BOOST_LOG_ATTRIBUTE_KEYWORD(filename, "Filename", std::string)
    BOOST_LOG_ATTRIBUTE_KEYWORD(functionName, "FunctionName", std::string)
    BOOST_LOG_ATTRIBUTE_KEYWORD(lineNumber, "LineNumber", uint32_t)

    namespace detail
    {
        // just log messages with severity >= SEVERITY_THRESHOLD are written
        constexpr boost::log::trivial::severity_level INIT_LOGLEVEL{ boost::log::trivial::severity_level::trace };

        // log file extension
        constexpr char OUTPUT_LOG_FILE_EXT[] = "log";

        // typedefs
        using text_sink = boost::log::sinks::synchronous_sink<boost::log::sinks::text_ostream_backend>;

        /**
         * @brief local variables to hold the sink pointers
         */
        inline boost::shared_ptr<text_sink> sinkConsole{};
        inline boost::shared_ptr<text_sink> sinkFile{};

        /**
         * @brief function to define the format of the output
         */
        [[nodiscard]] inline boost::log::formatter createOutputFormat()
        {
            // specify the format of the log message
            constexpr auto        counterWidth = 7;
            boost::log::formatter formatter =
                boost::log::expressions::stream
                << std::setw(counterWidth) << std::setfill('0') << lineId << std::setfill(' ') << " ["
                << boost::log::expressions::format_date_time(timestamp, "%Y-%m-%d %H:%M:%S.%f") << "] "
                << "[" << boost::log::trivial::severity << "] "
                << "[" << filename << ":" << functionName << "():" << lineNumber << "] "
                << boost::log::expressions::smessage;
            return formatter;
        }
    } // namespace detail

    /**
     * @brief Global intializer and constructor for the global logger
     *        Sets the initial sink to console backend and sets the default severity level
     */
    [[nodiscard]] inline BOOST_LOG_GLOBAL_LOGGER_INIT(fileLogger, boost::log::sources::severity_logger_mt)
    {
        boost::log::sources::severity_logger_mt<boost::log::trivial::severity_level> logger;

        // add attributes
        logger.add_attribute("LineID", boost::log::attributes::counter<uint32_t>(1));
        logger.add_attribute("TimeStamp", boost::log::attributes::local_clock());

        detail::sinkConsole = boost::make_shared<detail::text_sink>();

        // add "console" output stream to our sink
        detail::sinkConsole->locked_backend()->add_stream(
            boost::shared_ptr<std::ostream>(&std::clog, boost::null_deleter()));

        // specify the format of the log message
        const auto formatter = detail::createOutputFormat();

        // set the formatting
        detail::sinkConsole->set_formatter(formatter);

        // just log messages with severity >= INIT_LOGLEVEL are written
        detail::sinkConsole->set_filter(severity >= detail::INIT_LOGLEVEL);

        // "register" our sink
        boost::log::core::get()->add_sink(detail::sinkConsole);

        return logger;
    }

    /**
     * @brief Function to add the name of the output log file
     * @note This function will attempt to create any parent directories, if necessary
     * @throws std::runtime_error if it cannot create the appropiate directories
     *
     * @param logFileName  path of log file to write to
     */
    inline void addOutputFileLog(std::filesystem::path logFileName)
    {
        logFileName = std::filesystem::absolute(logFileName.replace_extension(detail::OUTPUT_LOG_FILE_EXT));

        // create the parent directories as needed
        const auto errorCode = [&]
        {
            auto error = std::error_code{};
            std::filesystem::create_directories(logFileName.parent_path(), error);
            return error;
        }();
        if (errorCode)
        {
            auto ss = std::stringstream{};
            ss << "Failed to create " << logFileName << " -- " << errorCode.message();
            throw std::runtime_error{ ss.str() };
        }

        // add a text sink
        detail::sinkFile = boost::make_shared<detail::text_sink>();

        // add a logfile stream to our sink
        detail::sinkFile->locked_backend()->add_stream(boost::make_shared<std::ofstream>(logFileName));

        // specify the format of the log message
        const auto formatter = detail::createOutputFormat();

        // set the formatting
        detail::sinkFile->set_formatter(formatter);

        // just log messages with severity >= INIT_LOGLEVEL are written
        detail::sinkFile->set_filter(severity >= detail::INIT_LOGLEVEL);

        // "register" our sink
        boost::log::core::get()->add_sink(detail::sinkFile);
    }

    /**
     * @brief Function to set the severity level to report back to console and log file
     *
     * @param level: level at which to report the logs
     */
    inline void setLogLevel(boost::log::trivial::severity_level level)
    {
        detail::sinkConsole->set_filter(severity >= level);
        if (detail::sinkFile)
        {
            detail::sinkFile->set_filter(severity >= level);
        }
    }
} // namespace nc::logger

// just a helper macro used by the macros below - don't use it in your code
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define BOOST_LOGGER(severity)                                                                           \
    BOOST_LOG_SEV(nc::logger::fileLogger::get(), boost::log::trivial::severity)                          \
        << boost::log::add_value("Filename", std::filesystem::path(__FILE__).filename().stem().string()) \
        << boost::log::add_value("FunctionName", __FUNCTION__)                                           \
        << boost::log::add_value("LineNumber", uint32_t{ __LINE__ })

// ===== log macros =====
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_TRACE BOOST_LOGGER(trace)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_DEBUG BOOST_LOGGER(debug)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_INFO BOOST_LOGGER(info)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_WARNING BOOST_LOGGER(warning)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_ERROR BOOST_LOGGER(error)
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define LOG_FATAL BOOST_LOGGER(fatal)

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: Logger.hpp ***/

/*** End of inlined file: Logging.hpp ***/


/*** Start of inlined file: Polynomial.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Simple Vector classes
///
#pragma once


/*** Start of inlined file: chebyshev_t.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/chebyshev.hpp"

namespace nc::polynomial
{

    // Method Description:
    /// Chebyshev Polynomial of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the chebyshev polynomial
    /// @param x: the input value
    /// @return double
    ///
    template<typename dtype>
    double chebyshev_t(uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::chebyshev_t(n, static_cast<double>(x));
    }

    // Method Description:
    /// Chebyshev Polynomial of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the chebyshev polynomial
    /// @param inArrayX: the input value
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> chebyshev_t(uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return chebyshev_t(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: chebyshev_t.hpp ***/


/*** Start of inlined file: chebyshev_u.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/chebyshev.hpp"

namespace nc::polynomial
{

    // Method Description:
    /// Chebyshev Polynomial of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the chebyshev polynomial
    /// @param x: the input value
    /// @return double
    ///
    template<typename dtype>
    double chebyshev_u(uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::chebyshev_u(n, static_cast<double>(x));
    }

    // Method Description:
    /// Chebyshev Polynomial of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the chebyshev polynomial
    /// @param inArrayX: the input value
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> chebyshev_u(uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return chebyshev_u(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: chebyshev_u.hpp ***/


/*** Start of inlined file: hermite.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/hermite.hpp"
#endif

namespace nc::polynomial
{

    // Method Description:
    /// Hermite Polynomial
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the hermite polynomial
    /// @param x: the input value
    /// @return double
    ///
    template<typename dtype>
    double hermite(uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::hermite(n, static_cast<double>(x));
#else
        return boost::math::hermite(n, static_cast<double>(x));
#endif
    }

    // Method Description:
    /// Hermite Polynomial.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the hermite polynomial
    /// @param inArrayX: the input value
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> hermite(uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return hermite(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: hermite.hpp ***/


/*** Start of inlined file: laguerre.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/laguerre.hpp"
#endif

namespace nc::polynomial
{

    // Method Description:
    /// Laguerre Polynomial.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the leguerre polynomial
    /// @param x: the input value
    /// @return double
    ///
    template<typename dtype>
    double laguerre(uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::laguerre(n, static_cast<double>(x));
#else
        return boost::math::laguerre(n, static_cast<double>(x));
#endif
    }

    // Method Description:
    /// Associated Laguerre Polynomial.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the leguerre polynomial
    /// @param m: the degree of the legendre polynomial
    /// @param x: the input value
    /// @return double
    ///
    template<typename dtype>
    double laguerre(uint32 n, uint32 m, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::assoc_laguerre(m, n, static_cast<double>(x));
#else
        return boost::math::laguerre(m, n, static_cast<double>(x));
#endif
    }

    // Method Description:
    /// Laguerre Polynomial.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the leguerre polynomial
    /// @param inArrayX: the input value
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> laguerre(uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return laguerre(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Associated Laguerre Polynomial.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the order of the leguerre polynomial
    /// @param m: the degree of the legendre polynomial
    /// @param inArrayX: the input value
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> laguerre(uint32 n, uint32 m, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n, m](dtype x) -> double { return laguerre(n, m, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: laguerre.hpp ***/


/*** Start of inlined file: legendre_p.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/legendre.hpp"
#endif

namespace nc::polynomial
{

    // Method Description:
    /// Legendre Polynomial of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the degree of the legendre polynomial
    /// @param x: the input value. Requires -1 <= x <= 1
    /// @return double
    ///
    template<typename dtype>
    double legendre_p(uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (x < -1. || x > 1.)
        {
            THROW_INVALID_ARGUMENT_ERROR("input x must be of the range [-1, 1].");
        }

#ifdef __cpp_lib_math_special_functions
        return std::legendre(n, static_cast<double>(x));
#else
        return boost::math::legendre_p(n, static_cast<double>(x));
#endif
    }

    // Method Description:
    /// Associated Legendre Polynomial of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param m: the order of the legendre polynomial
    /// @param n: the degree of the legendre polynomial
    /// @param x: the input value. Requires -1 <= x <= 1
    /// @return double
    ///
    template<typename dtype>
    double legendre_p(uint32 m, uint32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (x < -1. || x > 1.)
        {
            THROW_INVALID_ARGUMENT_ERROR("input x must be of the range [-1, 1].");
        }

#ifdef __cpp_lib_math_special_functions

        auto value = std::assoc_legendre(n, m, static_cast<double>(x));

#ifdef __GNUC__
#if __GNUC__ != 7 && __GNUC__ != 8

        // gcc std::assoc_legendre is not standard compliant
        value *= n % 2 == 0 ? 1 : -1;

#endif // #if __GNUC__ != 7 && __GNUC__ != 8
#endif // #ifdef __GNUC__

#ifdef __clang__
#if __clang_major__ != 7 && __clang_major__ != 8

        // clang uses gcc headers where std::assoc_legendre is not standard compliant
        value *= n % 2 == 0 ? 1 : -1;

#endif // #if __clang_major__ != 6 && __clang_major__ != 7 && __clang_major__ != 8
#endif // #ifdef __clang__

#ifdef _MSC_VER

        value *= n % 2 == 0 ? 1 : -1;

#endif // #ifdef _MSC_VER

        return value;

#else // #ifdef __cpp_lib_math_special_functions

        return boost::math::legendre_p(n, m, static_cast<double>(x));

#endif // #ifdef __cpp_lib_math_special_functions
    }

    // Method Description:
    /// Legendre Polynomial of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param n: the degree of the legendre polynomial
    /// @param inArrayX: the input value. Requires -1 <= x <= 1
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> legendre_p(uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return legendre_p(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }

    // Method Description:
    /// Associated Legendre Polynomial of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param m: the order of the legendre polynomial
    /// @param n: the degree of the legendre polynomial
    /// @param inArrayX: the input value. Requires -1 <= x <= 1
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> legendre_p(uint32 m, uint32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [m, n](dtype x) -> double { return legendre_p(m, n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: legendre_p.hpp ***/


/*** Start of inlined file: legendre_q.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/legendre.hpp"

namespace nc::polynomial
{

    // Method Description:
    /// Legendre Polynomial of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the legendre polynomial
    /// @param x: the input value. Requires -1 <= x <= 1
    /// @return double
    ///
    template<typename dtype>
    double legendre_q(int32 n, dtype x)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        if (x < -1. || x > 1.)
        {
            THROW_INVALID_ARGUMENT_ERROR("input x must be of the range [-1, 1].");
        }

        return boost::math::legendre_q(n, static_cast<double>(x));
    }

    // Method Description:
    /// Legendre Polynomial of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the order of the legendre polynomial
    /// @param inArrayX: the input value. Requires -1 <= x <= 1
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> legendre_q(int32 n, const NdArray<dtype>& inArrayX)
    {
        NdArray<double> returnArray(inArrayX.shape());

        const auto function = [n](dtype x) -> double { return legendre_q(n, x); };

        stl_algorithms::transform(inArrayX.cbegin(), inArrayX.cend(), returnArray.begin(), function);

        return returnArray;
    }
} // namespace nc::polynomial

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: legendre_q.hpp ***/


/*** Start of inlined file: spherical_harmonic.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <complex>

#include "boost/math/special_functions/spherical_harmonic.hpp"

namespace nc::polynomial
{

    // Method Description:
    /// Returns the value of the Spherical Harmonic Ynm(theta, phi).
    /// The spherical harmonics Ynm(theta, phi) are the angular portion of the
    /// solution to Laplace's equation in spherical coordinates where azimuthal
    /// symmetry is not present.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: order of the harmonic
    /// @param m: degree of the harmonic
    /// @param theta: Azimuthal (longitudinal) coordinate; must be in [0, 2*pi].
    /// @param phi: Polar (colatitudinal) coordinate; must be in [0, pi].
    /// @return double
    ///
    template<typename dtype1, typename dtype2>
    std::complex<double> spherical_harmonic(uint32 n, int32 m, dtype1 theta, dtype2 phi)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::spherical_harmonic(m, n, static_cast<double>(phi), static_cast<double>(theta));
    }

    // Method Description:
    /// Returns the real part of the Spherical Harmonic Ynm(theta, phi).
    /// The spherical harmonics Ynm(theta, phi) are the angular portion of the
    /// solution to Laplace's equation in spherical coordinates where azimuthal
    /// symmetry is not present.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: order of the harmonic
    /// @param m: degree of the harmonic
    /// @param theta: Azimuthal (longitudinal) coordinate; must be in [0, 2*pi].
    /// @param phi: Polar (colatitudinal) coordinate; must be in [0, pi].
    /// @return double
    ///
    template<typename dtype1, typename dtype2>
    double spherical_harmonic_r(uint32 n, int32 m, dtype1 theta, dtype2 phi)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::spherical_harmonic_r(m, n, static_cast<double>(phi), static_cast<double>(theta));
    }

    // Method Description:
    /// Returns the imaginary part of the Spherical Harmonic Ynm(theta, phi).
    /// The spherical harmonics Ynm(theta, phi) are the angular portion of the
    /// solution to Laplace's equation in spherical coordinates where azimuthal
    /// symmetry is not present.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: order of the harmonic
    /// @param m: degree of the harmonic
    /// @param theta: Azimuthal (longitudinal) coordinate; must be in [0, 2*pi].
    /// @param phi: Polar (colatitudinal) coordinate; must be in [0, pi].
    /// @return double
    ///
    template<typename dtype1, typename dtype2>
    double spherical_harmonic_i(uint32 n, int32 m, dtype1 theta, dtype2 phi)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::spherical_harmonic_i(m, n, static_cast<double>(phi), static_cast<double>(theta));
    }
} // namespace nc::polynomial

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: spherical_harmonic.hpp ***/

/*** End of inlined file: Polynomial.hpp ***/


/*** Start of inlined file: PythonInterface.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A module for interacting with python
///
#pragma once


/*** Start of inlined file: BoostInterface.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A module for interacting with python with boost interface
///
#pragma once

#if defined(NUMCPP_INCLUDE_BOOST_PYTHON_INTERFACE) && !defined(NUMCPP_NO_USE_BOOST)

#include <map>
#include <string>

#include "boost/python.hpp"
#include "boost/python/numpy.hpp"


/*** Start of inlined file: BoostNumpyNdarrayHelper.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A wrapper class for interacting with the boost numpy arrays
///
#pragma once

#if defined(NUMCPP_INCLUDE_BOOST_PYTHON_INTERFACE) && !defined(NUMCPP_NO_USE_BOOST)

#include <cmath>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "boost/python.hpp"
#include "boost/python/numpy.hpp"

namespace nc
{
    namespace boostPythonInterface
    {

        /// Helper class for ndarray
        template<typename dtype>
        class BoostNdarrayHelper
        {
        public:

            /// C or Fortran ordering from python
            enum class Order
            {
                F,
                C
            };

            /// Constructor
            ///
            /// @param inArray:  ndarray
            ///
            explicit BoostNdarrayHelper(const boost::python::numpy::ndarray& inArray) :
                theArray_(inArray.astype(boost::python::numpy::dtype::get_builtin<dtype>())),
                numDimensions_(static_cast<uint8>(inArray.get_nd())),
                shape_(numDimensions_),
                strides_(numDimensions_),
                order_(Order::C)

            {
                Py_intptr_t const* shapePtr = inArray.get_shape();
                for (uint8 i = 0; i < numDimensions_; ++i)
                {
                    strides_[i] = static_cast<uint32>(theArray_.strides(i));
                    shape_[i]   = shapePtr[i];
                }

                if (numDimensions_ > 1 && inArray.strides(0) < inArray.strides(1))
                {
                    order_ = Order::F;
                }
            }

            /// Constructor
            ///
            /// @param inShape
            ///
            explicit BoostNdarrayHelper(boost::python::tuple inShape) :
                theArray_(boost::python::numpy::zeros(inShape, boost::python::numpy::dtype::get_builtin<dtype>())),
                numDimensions_(static_cast<uint8>(theArray_.get_nd())),
                shape_(numDimensions_),
                strides_(numDimensions_),
                order_(Order::C)
            {
                Py_intptr_t const* shapePtr = theArray_.get_shape();
                for (uint8 i = 0; i < numDimensions_; ++i)
                {
                    strides_[i] = static_cast<uint32>(theArray_.strides(i));
                    shape_[i]   = shapePtr[i];
                }

                if (numDimensions_ > 1 && theArray_.strides(0) < theArray_.strides(1))
                {
                    order_ = Order::F;
                }
            }

            /// Returns the internaly held ndarray
            ///
            /// @return reference to the held ndarray
            ///
            const boost::python::numpy::ndarray& getArray() noexcept
            {
                return theArray_;
            }

            /// Returns the internaly held ndarray as a numpy matrix
            ///
            /// @return matrix
            ///
            boost::python::numpy::matrix getArrayAsMatrix()
            {
                return boost::python::numpy::matrix(theArray_);
            }

            /// Returns the number of dimensions of the array
            ///
            /// @return num dimensions
            ///
            uint8 numDimensions() noexcept
            {
                return numDimensions_;
            }

            /// Returns the shape of the array
            ///
            /// @return vector
            ///
            const std::vector<Py_intptr_t>& shape() noexcept
            {
                return shape_;
            }

            /// Returns the size of the array
            ///
            /// @return size
            ///
            uint32 size()
            {
                uint32 theSize = 1;
                for (auto dimSize : shape_)
                {
                    theSize *= static_cast<uint32>(dimSize);
                }
                return theSize;
            }

            /// Returns the strides of the array
            ///
            /// @return vector
            ///
            const std::vector<uint32>& strides()
            {
                return strides_;
            }

            /// Returns the memory order of the array (C or Fortran)
            ///
            /// @return Order
            ///
            Order order()
            {
                return order_;
            }

            /// Returns if the shapes of the two array helpers are equal
            ///
            /// @param otherNdarrayHelper
            ///
            /// @return boolean
            ///
            bool shapeEqual(BoostNdarrayHelper& otherNdarrayHelper)
            {
                if (shape_.size() != otherNdarrayHelper.shape_.size())
                {
                    return false;
                }

                return stl_algorithms::equal(shape_.begin(), shape_.end(), otherNdarrayHelper.shape_.begin());
            }

            /// 1D access operator
            ///
            /// @param index
            ///
            /// @return dtype
            ///
            dtype& operator()(uint32 index)
            {
                checkIndices1D(index);

                return *reinterpret_cast<dtype*>(theArray_.get_data() + strides_.front() * index);
            }

            /// 2D access operator
            ///
            /// @param index1
            /// @param index2
            ///
            /// @return dtype
            ///
            dtype& operator()(uint32 index1, uint32 index2)
            {
                checkIndices2D(index1, index2);

                return *reinterpret_cast<dtype*>(theArray_.get_data() + strides_.front() * index1 +
                                                 strides_[1] * index2);
            }

            /// Prints a 1D array
            ///
            void printArray1D()
            {
                printf("array = \n");
                if (numDimensions_ != 1)
                {
                    std::cout << "printArray1D can only be used on a 1D array." << std::endl;
                    return;
                }

                for (int32 i = 0; i < shape_.front(); ++i)
                {
                    printf("\t%f\n", operator()(i));
                }
            }

            /// Prints a 2D array
            ///
            void printArray2D()
            {
                printf("array = \n");
                if (numDimensions_ != 2)
                {
                    std::cout << "printArray2D can only be used on a 2D array." << std::endl;
                    return;
                }

                for (int32 index1 = 0; index1 < shape_.front(); ++index1)
                {
                    for (int32 index2 = 0; index2 < shape_.back(); ++index2)
                    {
                        printf("\t%f", operator()(index1, index2));
                    }
                    printf('\n');
                }
            }

        private:
            //====================================Attributes==============================
            boost::python::numpy::ndarray theArray_;
            uint8                         numDimensions_;
            std::vector<Py_intptr_t>      shape_;
            std::vector<uint32>           strides_;
            Order                         order_;

            /// Generic check of input indices
            ///
            /// @param indices
            ///
            void checkIndicesGeneric(boost::python::tuple indices)
            {
                if (boost::python::len(indices) != numDimensions_)
                {
                    std::string errStr =
                        "Error: BoostNdarrayHelper::checkIndicesGeneric: Array has " + utils::num2str(numDimensions_);
                    errStr += " dimensions, you asked for " +
                              utils::num2str(static_cast<int>(boost::python::len(indices))) + "!";
                    PyErr_SetString(PyExc_RuntimeError, errStr.c_str());
                }

                for (int i = 0; i < numDimensions_; ++i)
                {
                    int index = boost::python::extract<int>(indices[i]);
                    if (index > shape_[i])
                    {
                        std::string errStr =
                            "Error: BoostNdarrayHelper::checkIndicesGeneric: Input index [" + utils::num2str(index);
                        errStr += "] is larger than the size of the array [" + utils::num2str(shape_[i]) + "].";
                        PyErr_SetString(PyExc_RuntimeError, errStr.c_str());
                    }
                }
            }

            /// Checks 1D input indices
            ///
            /// @param index
            ///
            void checkIndices1D(uint32 index)
            {
                boost::python::tuple indices = boost::python::make_tuple(index);
                checkIndicesGeneric(indices);
            }

            /// Checks 2D input indices
            ///
            /// @param index1
            /// @param index2
            ///
            void checkIndices2D(uint32 index1, uint32 index2)
            {
                boost::python::tuple indices = boost::python::make_tuple(index1, index2);
                checkIndicesGeneric(indices);
            }
        };
    } // namespace boostPythonInterface
} // namespace nc

#endif // #if defined(NUMCPP_INCLUDE_BOOST_PYTHON_INTERFACE) && !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: BoostNumpyNdarrayHelper.hpp ***/

namespace nc
{
    namespace boostPythonInterface
    {

        /// Converts from a boost ndarray to a NumCpp NdArray<T>
        ///
        /// @param inArray
        ///
        /// @return NdArray<T>
        ///
        template<typename dtype>
        inline NdArray<dtype> boost2Nc(const boost::python::numpy::ndarray& inArray)
        {
            BoostNdarrayHelper<dtype> helper(inArray);
            if (helper.numDimensions() > 2)
            {
                THROW_RUNTIME_ERROR("Can only convert 1 and 2 dimensional arrays.");
            }

            Shape arrayShape;
            if (helper.numDimensions() == 1)
            {
                arrayShape.rows = 1;
                arrayShape.cols = static_cast<uint32>(helper.shape().front());

                NdArray<dtype> returnArray(arrayShape);
                for (uint32 i = 0; i < arrayShape.size(); ++i)
                {
                    returnArray[i] = helper(i);
                }

                return returnArray;
            }

            arrayShape.rows = static_cast<uint32>(helper.shape().front());
            arrayShape.cols = static_cast<uint32>(helper.shape()[1]);

            NdArray<dtype> returnArray(arrayShape);
            for (uint32 row = 0; row < arrayShape.rows; ++row)
            {
                for (uint32 col = 0; col < arrayShape.cols; ++col)
                {
                    returnArray(row, col) = helper(row, col);
                }
            }

            return returnArray;
        }

        /// Converts from a NumCpp NdArray<T> to a boost ndarray
        ///
        /// @param inArray
        ///
        /// @return ndarray
        ///
        template<typename dtype>
        inline boost::python::numpy::ndarray nc2Boost(const NdArray<dtype>& inArray)
        {
            const Shape               inShape = inArray.shape();
            boost::python::tuple      shape   = boost::python::make_tuple(inShape.rows, inShape.cols);
            BoostNdarrayHelper<dtype> newNdArrayHelper(shape);

            for (uint32 row = 0; row < inShape.rows; ++row)
            {
                for (uint32 col = 0; col < inShape.cols; ++col)
                {
                    newNdArrayHelper(row, col) = inArray(row, col);
                }
            }
            return newNdArrayHelper.getArray();
        }

        /// converts a boost python list to a std::vector
        ///
        /// @param inList
        ///
        /// @return std::vector<T>
        ///
        template<typename T>
        inline std::vector<T> list2vector(const boost::python::list& inList)
        {
            return std::vector<T>(boost::python::stl_input_iterator<T>(inList), boost::python::stl_input_iterator<T>());
        }

        /// converts a std::vector to a boost python list
        ///
        /// @param inVector
        ///
        /// @return boost::python::list
        ///
        template<typename T>
        inline boost::python::list vector2list(std::vector<T>& inVector)
        {
            boost::python::list outList;
            for (auto& value : inVector)
            {
                outList.append(value);
            }

            return outList;
        }

        /// converts a std::map in to a boost python dictionary
        ///
        /// @param inMap
        ///
        /// @return boost::python::dict
        ///
        template<class Key, class Value>
        inline boost::python::dict map2dict(const std::map<Key, Value>& inMap)
        {
            boost::python::dict dictionary;
            for (auto& keyValue : inMap)
            {
                dictionary[keyValue.first] = keyValue.second;
            }
            return dictionary;
        }
    } // namespace boostPythonInterface
} // namespace nc

#endif // #if defined(NUMCPP_INCLUDE_BOOST_PYTHON_INTERFACE) && !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: BoostInterface.hpp ***/


/*** Start of inlined file: PybindInterface.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// A module for interacting with python with pybind11 interface
///
#pragma once

#ifdef NUMCPP_INCLUDE_PYBIND_PYTHON_INTERFACE

#include "pybind11/numpy.h"
#include "pybind11/pybind11.h"

#include <map>
#include <utility>

namespace nc::pybindInterface
{
    /// Enum for the pybind array return policy
    enum class ReturnPolicy
    {
        COPY,
        REFERENCE,
        TAKE_OWNERSHIP
    };

    static const std::map<ReturnPolicy, std::string> returnPolicyStringMap = { { ReturnPolicy::COPY, "COPY" },
                                                                               { ReturnPolicy::REFERENCE, "REFERENCE" },
                                                                               { ReturnPolicy::TAKE_OWNERSHIP,
                                                                                 "TAKE_OWNERSHIP" } };

    template<typename dtype>
    using pbArray        = pybind11::array_t<dtype, pybind11::array::c_style>;
    using pbArrayGeneric = pybind11::array;

    /// converts a numpy array to a numcpp NdArray using pybind bindings
    /// Python will still own the underlying data.
    ///
    /// @param numpyArray
    ///
    /// @return NdArray<dtype>
    ///
    template<typename dtype>
    NdArray<dtype> pybind2nc(pbArray<dtype>& numpyArray)
    {
        const auto dataPtr = numpyArray.mutable_data();
        switch (numpyArray.ndim())
        {
            case 0:
            {
                return NdArray<dtype>(dataPtr, 0, 0, PointerPolicy::COPY);
            }
            case 1:
            {
                const auto size = static_cast<uint32>(numpyArray.size());
                return NdArray<dtype>(dataPtr, 1, size, PointerPolicy::COPY);
            }
            case 2:
            {
                const auto numRows = static_cast<uint32>(numpyArray.shape(0));
                const auto numCols = static_cast<uint32>(numpyArray.shape(1));
                return NdArray<dtype>(dataPtr, numRows, numCols, PointerPolicy::COPY);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("input array must be no more than 2 dimensional.");
                return {};
            }
        }
    }

    /// converts a numpy array to a numcpp NdArray using pybind bindings
    /// Python will still own the underlying data.
    ///
    /// @param numpyArray
    ///
    /// @return NdArray<dtype>
    ///
    template<typename dtype>
    NdArray<dtype> pybind2nc_copy(const pbArray<dtype>& numpyArray)
    {
        const auto dataPtr = numpyArray.data();
        switch (numpyArray.ndim())
        {
            case 0:
            {
                return NdArray<dtype>(dataPtr, 0, 0);
            }
            case 1:
            {
                const auto size = static_cast<uint32>(numpyArray.size());
                return NdArray<dtype>(dataPtr, 1, size);
            }
            case 2:
            {
                const auto numRows = static_cast<uint32>(numpyArray.shape(0));
                const auto numCols = static_cast<uint32>(numpyArray.shape(1));
                return NdArray<dtype>(dataPtr, numRows, numCols);
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("input array must be no more than 2 dimensional.");
                return {};
            }
        }
    }

    /// converts a numcpp NdArray to numpy array using pybind bindings
    ///
    /// @param inArray: the input array
    ///
    /// @return pybind11::array_t
    ///
    template<typename dtype>
    pbArrayGeneric nc2pybind(const NdArray<dtype>& inArray)
    {
        const Shape                          inShape = inArray.shape();
        const std::vector<pybind11::ssize_t> shape{ static_cast<pybind11::ssize_t>(inShape.rows),
                                                    static_cast<pybind11::ssize_t>(inShape.cols) };
        const std::vector<pybind11::ssize_t> strides{ static_cast<pybind11::ssize_t>(inShape.cols * sizeof(dtype)),
                                                      static_cast<pybind11::ssize_t>(sizeof(dtype)) };
        return pbArrayGeneric(shape, strides, inArray.data());
    }

    /// converts a numcpp NdArray to numpy array using pybind bindings
    ///
    /// @param inArray: the input array
    /// @param returnPolicy: the return policy
    ///
    /// @return pybind11::array_t
    ///
    template<typename dtype>
    pbArrayGeneric nc2pybind(NdArray<dtype>& inArray, ReturnPolicy returnPolicy)
    {
        const Shape                          inShape = inArray.shape();
        const std::vector<pybind11::ssize_t> shape{ static_cast<pybind11::ssize_t>(inShape.rows),
                                                    static_cast<pybind11::ssize_t>(inShape.cols) };
        const std::vector<pybind11::ssize_t> strides{ static_cast<pybind11::ssize_t>(inShape.cols * sizeof(dtype)),
                                                      static_cast<pybind11::ssize_t>(sizeof(dtype)) };

        switch (returnPolicy)
        {
            case ReturnPolicy::COPY:
            {
                return nc2pybind(inArray);
            }
            case ReturnPolicy::REFERENCE:
            {
                typename pybind11::capsule reference(inArray.data(), [](void* /*ptr*/) {});
                return pbArrayGeneric(shape, strides, inArray.data(), reference);
            }
            case ReturnPolicy::TAKE_OWNERSHIP:
            {
                typename pybind11::capsule garbageCollect(inArray.dataRelease(),
                                                          [](void* ptr)
                                                          {
                                                              auto* dataPtr = reinterpret_cast<dtype*>(ptr);
                                                              delete[] dataPtr;
                                                          });
                return pbArrayGeneric(shape, strides, inArray.data(), garbageCollect);
            }
            default:
            {
                std::stringstream sstream;
                sstream << "ReturnPolicy " << returnPolicyStringMap.at(returnPolicy) << " has not been implemented yet"
                        << std::endl;
                THROW_INVALID_ARGUMENT_ERROR(sstream.str());
            }
        }
    }
} // namespace nc::pybindInterface
#endif

/*** End of inlined file: PybindInterface.hpp ***/

/*** End of inlined file: PythonInterface.hpp ***/


/*** Start of inlined file: Random.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Random number distributions
///
#pragma once


/*** Start of inlined file: RNG.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
/// @version 1.1
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Random Number Generater Class with non-global state
///
#pragma once

#include <random>


/*** Start of inlined file: bernoulli.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "bernoulli" distribution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>


/*** Start of inlined file: generator.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Seeds the random number generator
///
#pragma once

#include <random>

namespace nc::random
{
    /// generator function
    static std::mt19937_64 generator_;

    // Method Description:
    /// Seeds the random number generator
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.seed.html#numpy.random.seed
    ///
    /// @param inSeed
    ///
    inline void seed(int inSeed)
    {
        generator_.seed(inSeed);
    }
} // namespace nc::random

/*** End of inlined file: generator.hpp ***/

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "bernoulli" distribution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inP (probability of success [0, 1]). Default 0.5
        /// @return NdArray
        ///
        template<typename GeneratorType = std::mt19937>
        bool bernoulli(GeneratorType& generator, double inP = 0.5)
        {
            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of success must be of the range [0, 1].");
            }

            std::bernoulli_distribution dist(inP);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "bernoulli" distribution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inP (probability of success [0, 1]). Default 0.5
        /// @return NdArray
        ///
        template<typename GeneratorType = std::mt19937>
        NdArray<bool> bernoulli(GeneratorType& generator, const Shape& inShape, double inP = 0.5)
        {
            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of success must be of the range [0, 1].");
            }

            NdArray<bool> returnArray(inShape);

            std::bernoulli_distribution dist(inP);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](bool& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "bernoulli" distribution.
    ///
    /// @param inP (probability of success [0, 1]). Default 0.5
    /// @return NdArray
    ///
    inline bool bernoulli(double inP = 0.5)
    {
        return detail::bernoulli(generator_, inP);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "bernoulli" distribution.
    ///
    /// @param inShape
    /// @param inP (probability of success [0, 1]). Default 0.5
    /// @return NdArray
    ///
    inline NdArray<bool> bernoulli(const Shape& inShape, double inP = 0.5)
    {
        return detail::bernoulli(generator_, inShape, inP);
    }
} // namespace nc::random

/*** End of inlined file: bernoulli.hpp ***/


/*** Start of inlined file: beta.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "beta" distribution.
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>
#include <string>

#include "boost/random/beta_distribution.hpp"

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the from the "beta" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
        ///
        /// @param generator: instance of a random number generator
        /// @param inAlpha
        /// @param inBeta
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype beta(GeneratorType& generator, dtype inAlpha, dtype inBeta)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inAlpha < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input alpha must be greater than zero.");
            }

            if (inBeta < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input beta must be greater than zero.");
            }

            boost::random::beta_distribution<dtype> dist(inAlpha, inBeta);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "beta" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inAlpha
        /// @param inBeta
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> beta(GeneratorType& generator, const Shape& inShape, dtype inAlpha, dtype inBeta)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inAlpha < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input alpha must be greater than zero.");
            }

            if (inBeta < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input beta must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            boost::random::beta_distribution<dtype> dist(inAlpha, inBeta);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the from the "beta" distribution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
    ///
    /// @param inAlpha
    /// @param inBeta
    /// @return NdArray
    ///
    template<typename dtype>
    dtype beta(dtype inAlpha, dtype inBeta)
    {
        return detail::beta(generator_, inAlpha, inBeta);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "beta" distribution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
    ///
    /// @param inShape
    /// @param inAlpha
    /// @param inBeta
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> beta(const Shape& inShape, dtype inAlpha, dtype inBeta)
    {
        return detail::beta(generator_, inShape, inAlpha, inBeta);
    }
} // namespace nc::random

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: beta.hpp ***/


/*** Start of inlined file: binomial.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "binomial" distribution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the from the "binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
        ///
        /// @param generator: instance of a random number generator
        /// @param inN (number of trials)
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype binomial(GeneratorType& generator, dtype inN, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inN < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input number of trials must be greater than or equal to zero.");
            }

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            std::binomial_distribution<dtype> dist(inN, inP);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inN (number of trials)
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> binomial(GeneratorType& generator, const Shape& inShape, dtype inN, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inN < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input number of trials must be greater than or equal to zero.");
            }

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            NdArray<dtype> returnArray(inShape);

            std::binomial_distribution<dtype> dist(inN, inP);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the from the "binomial" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
    ///
    /// @param inN (number of trials)
    /// @param inP (probablity of success [0, 1])
    /// @return NdArray
    ///
    template<typename dtype>
    dtype binomial(dtype inN, double inP = 0.5)
    {
        return detail::binomial(generator_, inN, inP);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "binomial" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
    ///
    /// @param inShape
    /// @param inN (number of trials)
    /// @param inP (probablity of success [0, 1])
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> binomial(const Shape& inShape, dtype inN, double inP = 0.5)
    {
        return detail::binomial(generator_, inShape, inN, inP);
    }
} // namespace nc::random

/*** End of inlined file: binomial.hpp ***/


/*** Start of inlined file: cauchy.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "cauchy" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the from the "cauchy" distrubution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype cauchy(GeneratorType& generator, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            std::cauchy_distribution<dtype> dist(inMean, inSigma);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "cauchy" distrubution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> cauchy(GeneratorType& generator, const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::cauchy_distribution<dtype> dist(inMean, inSigma);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the from the "cauchy" distrubution.
    ///
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype cauchy(dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::cauchy(generator_, inMean, inSigma);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "cauchy" distrubution.
    ///
    /// @param inShape
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> cauchy(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::cauchy(generator_, inShape, inMean, inSigma);
    }
} // namespace nc::random

/*** End of inlined file: cauchy.hpp ***/


/*** Start of inlined file: chiSquare.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "chi square" distribution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the from the "chi square" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
        ///
        /// @param generator: instance of a random number generator
        /// @param inDof (independent random variables)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype chiSquare(GeneratorType& generator, dtype inDof)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDof <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("numerator degrees of freedom must be greater than zero.");
            }

            std::chi_squared_distribution<dtype> dist(inDof);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "chi square" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inDof (independent random variables)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> chiSquare(GeneratorType& generator, const Shape& inShape, dtype inDof)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDof <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("numerator degrees of freedom must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::chi_squared_distribution<dtype> dist(inDof);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the from the "chi square" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
    ///
    /// @param inDof (independent random variables)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype chiSquare(dtype inDof)
    {
        return detail::chiSquare(generator_, inDof);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "chi square" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
    ///
    /// @param inShape
    /// @param inDof (independent random variables)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> chiSquare(const Shape& inShape, dtype inDof)
    {
        return detail::chiSquare(generator_, inShape, inDof);
    }
} // namespace nc::random

/*** End of inlined file: chiSquare.hpp ***/


/*** Start of inlined file: choice.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Chooses a random sample from an input array.
///
#pragma once

#include <algorithm>


/*** Start of inlined file: permutation.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Randomly permute a sequence, or return a permuted range
///
#pragma once

#include <algorithm>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Randomly permute a sequence, or return a permuted range.
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements randomly.
        ///
        /// @param generator: instance of a random number generator
        /// @param inValue
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> permutation(GeneratorType& generator, dtype inValue)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            NdArray<dtype> returnArray = arange(inValue);
            std::shuffle(returnArray.begin(), returnArray.end(), generator);
            return returnArray;
        }

        // Method Description:
        /// Randomly permute a sequence, or return a permuted range.
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements randomly.
        ///
        /// @param generator: instance of a random number generator
        /// @param inArray
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> permutation(GeneratorType& generator, const NdArray<dtype>& inArray)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            NdArray<dtype> returnArray(inArray);
            std::shuffle(returnArray.begin(), returnArray.end(), generator);
            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Randomly permute a sequence, or return a permuted range.
    /// If x is an integer, randomly permute np.arange(x).
    /// If x is an array, make a copy and shuffle the elements randomly.
    ///
    /// @param inValue
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> permutation(dtype inValue)
    {
        return detail::permutation(generator_, inValue);
    }

    // Method Description:
    /// Randomly permute a sequence, or return a permuted range.
    /// If x is an integer, randomly permute np.arange(x).
    /// If x is an array, make a copy and shuffle the elements randomly.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> permutation(const NdArray<dtype>& inArray)
    {
        return detail::permutation(generator_, inArray);
    }
} // namespace nc::random

/*** End of inlined file: permutation.hpp ***/


/*** Start of inlined file: randInt.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
/// @version 1.1
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Return random integers from low (inclusive) to high (exclusive),
/// with the given shape
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Return random integer from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
        ///
        /// @param generator: instance of a random number generator
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype randInt(GeneratorType& generator, dtype inLow, dtype inHigh = 0)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inLow == inHigh)
            {
                THROW_INVALID_ARGUMENT_ERROR("input low value must be less than the input high value.");
            }
            else if (inLow > inHigh)
            {
                std::swap(inLow, inHigh);
            }

            std::uniform_int_distribution<dtype> dist(inLow, inHigh - 1);
            return dist(generator);
        }

        // Method Description:
        /// Return random integers from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> randInt(GeneratorType& generator, const Shape& inShape, dtype inLow, dtype inHigh = 0)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inLow == inHigh)
            {
                THROW_INVALID_ARGUMENT_ERROR("input low value must be less than the input high value.");
            }
            else if (inLow > inHigh - 1)
            {
                std::swap(inLow, inHigh);
            }

            NdArray<dtype> returnArray(inShape);

            std::uniform_int_distribution<dtype> dist(inLow, inHigh - 1);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&dist, &generator](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Return random integer from low (inclusive) to high (exclusive),
    /// with the given shape. If no high value is input then the range will
    /// go from [0, low).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
    ///
    /// @param inLow
    /// @param inHigh default 0.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype randInt(dtype inLow, dtype inHigh = 0)
    {
        return detail::randInt(generator_, inLow, inHigh);
    }

    // Method Description:
    /// Return random integers from low (inclusive) to high (exclusive),
    /// with the given shape. If no high value is input then the range will
    /// go from [0, low).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
    ///
    /// @param inShape
    /// @param inLow
    /// @param inHigh default 0.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> randInt(const Shape& inShape, dtype inLow, dtype inHigh = 0)
    {
        return detail::randInt(generator_, inShape, inLow, inHigh);
    }
} // namespace nc::random

/*** End of inlined file: randInt.hpp ***/

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Chooses a random sample from an input array.
        ///
        /// @param generator: instance of a random number generator
        /// @param inArray
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype choice(GeneratorType& generator, const NdArray<dtype>& inArray)
        {
            uint32 randIdx = detail::randInt<uint32>(generator, inArray.size());
            return inArray[randIdx];
        }

        // Method Description:
        /// Chooses inNum random samples from an input array.
        ///
        /// @param generator: instance of a random number generator
        /// @param inArray
        /// @param inNum
        /// @param replace: Whether the sample is with or without replacement
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> choice(GeneratorType&        generator,
                              const NdArray<dtype>& inArray,
                              uint32                inNum,
                              Replace               replace = Replace::YES)
        {
            if (replace == Replace::NO && inNum > inArray.size())
            {
                THROW_INVALID_ARGUMENT_ERROR("when Replace::NO 'inNum' must be <= inArray.size()");
            }

            if (replace == Replace::YES)
            {
                NdArray<dtype> outArray(1, inNum);
                std::for_each(outArray.begin(),
                              outArray.end(),
                              [&generator, &inArray](dtype& value) -> void { value = choice(generator, inArray); });

                return outArray;
            }

            return detail::permutation(generator, inArray)[Slice(inNum)];
        }
    } // namespace detail

    // Method Description:
    /// Chooses a random sample from an input array.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    dtype choice(const NdArray<dtype>& inArray)
    {
        return detail::choice(generator_, inArray);
    }

    // Method Description:
    /// Chooses inNum random samples from an input array.
    ///
    /// @param inArray
    /// @param inNum
    /// @param replace: Whether the sample is with or without replacement
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> choice(const NdArray<dtype>& inArray, uint32 inNum, Replace replace = Replace::YES)
    {
        return detail::choice(generator_, inArray, inNum, replace);
    }
} // namespace nc::random

/*** End of inlined file: choice.hpp ***/


/*** Start of inlined file: discrete.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "discrete" distrubution.
///
#pragma once

#include <algorithm>
#include <random>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the from the
        /// "discrete" distrubution.  It produces integers in the
        /// range [0, n) with the probability of producing each value
        /// is specified by the parameters of the distribution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inWeights
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype discrete(GeneratorType& generator, const NdArray<double>& inWeights)
        {
            STATIC_ASSERT_INTEGER(dtype);

            std::discrete_distribution<dtype> dist(inWeights.cbegin(), inWeights.cend());
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "discrete" distrubution.  It produces
        /// integers in the range [0, n) with the probability of
        /// producing each value is specified by the parameters
        /// of the distribution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inWeights
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> discrete(GeneratorType& generator, const Shape& inShape, const NdArray<double>& inWeights)
        {
            STATIC_ASSERT_INTEGER(dtype);

            NdArray<dtype> returnArray(inShape);

            std::discrete_distribution<dtype> dist(inWeights.cbegin(), inWeights.cend());

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the from the
    /// "discrete" distrubution.  It produces integers in the
    /// range [0, n) with the probability of producing each value
    /// is specified by the parameters of the distribution.
    ///
    /// @param inWeights
    /// @return NdArray
    ///
    template<typename dtype>
    dtype discrete(const NdArray<double>& inWeights)
    {
        return detail::discrete<dtype>(generator_, inWeights);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "discrete" distrubution.  It produces
    /// integers in the range [0, n) with the probability of
    /// producing each value is specified by the parameters
    /// of the distribution.
    ///
    /// @param inShape
    /// @param inWeights
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> discrete(const Shape& inShape, const NdArray<double>& inWeights)
    {
        return detail::discrete<dtype>(generator_, inShape, inWeights);
    }
} // namespace nc::random

/*** End of inlined file: discrete.hpp ***/


/*** Start of inlined file: exponential.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "exponential" distrubution
///
#pragma once

#include <algorithm>
#include <random>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "exponential" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
        ///
        /// @param generator: instance of a random number generator
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype exponential(GeneratorType& generator, dtype inScaleValue = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            std::exponential_distribution<dtype> dist(inScaleValue);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "exponential" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> exponential(GeneratorType& generator, const Shape& inShape, dtype inScaleValue = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            NdArray<dtype> returnArray(inShape);

            std::exponential_distribution<dtype> dist(inScaleValue);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "exponential" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
    ///
    /// @param inScaleValue (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype exponential(dtype inScaleValue = 1)
    {
        return detail::exponential(generator_, inScaleValue);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "exponential" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
    ///
    /// @param inShape
    /// @param inScaleValue (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> exponential(const Shape& inShape, dtype inScaleValue = 1)
    {
        return detail::exponential(generator_, inShape, inScaleValue);
    }
} // namespace nc::random

/*** End of inlined file: exponential.hpp ***/


/*** Start of inlined file: extremeValue.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "extreme value" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "extreme value" distrubution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype extremeValue(GeneratorType& generator, dtype inA = 1, dtype inB = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inA <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input a must be greater than zero.");
            }

            if (inB <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input b must be greater than zero.");
            }

            std::extreme_value_distribution<dtype> dist(inA, inB);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "extreme value" distrubution.
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> extremeValue(GeneratorType& generator, const Shape& inShape, dtype inA = 1, dtype inB = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inA <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input a must be greater than zero.");
            }

            if (inB <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input b must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::extreme_value_distribution<dtype> dist(inA, inB);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "extreme value" distrubution.
    ///
    /// @param inA (default 1)
    /// @param inB (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype extremeValue(dtype inA = 1, dtype inB = 1)
    {
        return detail::extremeValue<dtype>(generator_, inA, inB);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "extreme value" distrubution.
    ///
    /// @param inShape
    /// @param inA (default 1)
    /// @param inB (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> extremeValue(const Shape& inShape, dtype inA = 1, dtype inB = 1)
    {
        return detail::extremeValue<dtype>(generator_, inShape, inA, inB);
    }
} // namespace nc::random

/*** End of inlined file: extremeValue.hpp ***/


/*** Start of inlined file: f.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "F" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "F" distrubution.
        ///
        /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
        ///
        /// @param generator: instance of a random number generator
        /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
        /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype f(GeneratorType& generator, dtype inDofN, dtype inDofD)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDofN <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("numerator degrees of freedom should be greater than zero.");
            }

            if (inDofD <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("denominator degrees of freedom should be greater than zero.");
            }

            std::fisher_f_distribution<dtype> dist(inDofN, inDofD);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "F" distrubution.
        ///
        /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
        /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> f(GeneratorType& generator, const Shape& inShape, dtype inDofN, dtype inDofD)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDofN <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("numerator degrees of freedom should be greater than zero.");
            }

            if (inDofD <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("denominator degrees of freedom should be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::fisher_f_distribution<dtype> dist(inDofN, inDofD);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "F" distrubution.
    ///
    /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
    ///
    /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
    /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype f(dtype inDofN, dtype inDofD)
    {
        return detail::f(generator_, inDofN, inDofD);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "F" distrubution.
    ///
    /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
    ///
    /// @param inShape
    /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
    /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> f(const Shape& inShape, dtype inDofN, dtype inDofD)
    {
        return detail::f(generator_, inShape, inDofN, inDofD);
    }
} // namespace nc::random

/*** End of inlined file: f.hpp ***/


/*** Start of inlined file: gamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "gamma" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "gamma" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
        ///
        /// @param generator: instance of a random number generator
        /// @param inGammaShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype gamma(GeneratorType& generator, dtype inGammaShape, dtype inScaleValue = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inGammaShape <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input gamma shape should be greater than zero.");
            }

            if (inScaleValue <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input scale should be greater than zero.");
            }

            std::gamma_distribution<dtype> dist(inGammaShape, inScaleValue);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "gamma" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inGammaShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> gamma(GeneratorType& generator, const Shape& inShape, dtype inGammaShape, dtype inScaleValue = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inGammaShape <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input gamma shape should be greater than zero.");
            }

            if (inScaleValue <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input scale should be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::gamma_distribution<dtype> dist(inGammaShape, inScaleValue);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "gamma" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
    ///
    /// @param inGammaShape
    /// @param inScaleValue (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype gamma(dtype inGammaShape, dtype inScaleValue = 1)
    {
        return detail::gamma(generator_, inGammaShape, inScaleValue);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "gamma" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
    ///
    /// @param inShape
    /// @param inGammaShape
    /// @param inScaleValue (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> gamma(const Shape& inShape, dtype inGammaShape, dtype inScaleValue = 1)
    {
        return detail::gamma(generator_, inShape, inGammaShape, inScaleValue);
    }
} // namespace nc::random

/*** End of inlined file: gamma.hpp ***/


/*** Start of inlined file: geometric.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "geometric" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "geometric" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
        ///
        /// @param generator: instance of a random number generator
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype geometric(GeneratorType& generator, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            std::geometric_distribution<dtype> dist(inP);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "geometric" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> geometric(GeneratorType& generator, const Shape& inShape, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            NdArray<dtype> returnArray(inShape);

            std::geometric_distribution<dtype> dist(inP);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "geometric" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
    ///
    /// @param inP (probablity of success [0, 1])
    /// @return NdArray
    ///
    template<typename dtype>
    dtype geometric(double inP = 0.5)
    {
        return detail::geometric<dtype>(generator_, inP);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "geometric" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
    ///
    /// @param inShape
    /// @param inP (probablity of success [0, 1])
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> geometric(const Shape& inShape, double inP = 0.5)
    {
        return detail::geometric<dtype>(generator_, inShape, inP);
    }
} // namespace nc::random

/*** End of inlined file: geometric.hpp ***/


/*** Start of inlined file: laplace.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "laplace" distrubution.
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>

#include "boost/random/laplace_distribution.hpp"

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "laplace" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
        ///
        /// @param generator: instance of a random number generator
        /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
        /// @param inScale: (float optional the exponential decay. Default is 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype laplace(GeneratorType& generator, dtype inLoc = 0, dtype inScale = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            boost::random::laplace_distribution<dtype> dist(inLoc, inScale);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "laplace" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
        /// @param inScale: (float optional the exponential decay. Default is 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> laplace(GeneratorType& generator, const Shape& inShape, dtype inLoc = 0, dtype inScale = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            NdArray<dtype> returnArray(inShape);

            boost::random::laplace_distribution<dtype> dist(inLoc, inScale);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "laplace" distrubution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
    ///
    /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
    /// @param inScale: (float optional the exponential decay. Default is 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype laplace(dtype inLoc = 0, dtype inScale = 1)
    {
        return detail::laplace(generator_, inLoc, inScale);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "laplace" distrubution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
    ///
    /// @param inShape
    /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
    /// @param inScale: (float optional the exponential decay. Default is 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> laplace(const Shape& inShape, dtype inLoc = 0, dtype inScale = 1)
    {
        return detail::laplace(generator_, inShape, inLoc, inScale);
    }
} // namespace nc::random

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: laplace.hpp ***/


/*** Start of inlined file: lognormal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "lognormal" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "lognormal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
        ///
        /// @param generator: instance of a random number generator
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype lognormal(GeneratorType& generator, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            std::lognormal_distribution<dtype> dist(inMean, inSigma);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "lognormal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> lognormal(GeneratorType& generator, const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::lognormal_distribution<dtype> dist(inMean, inSigma);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "lognormal" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
    ///
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype lognormal(dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::lognormal(generator_, inMean, inSigma);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "lognormal" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
    ///
    /// @param inShape
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> lognormal(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::lognormal(generator_, inShape, inMean, inSigma);
    }
} // namespace nc::random

/*** End of inlined file: lognormal.hpp ***/


/*** Start of inlined file: negativeBinomial.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "negative Binomial" distribution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "negative Binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
        ///
        /// @param generator: instance of a random number generator
        /// @param inN: number of trials
        /// @param inP: probablity of success [0, 1]
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype negativeBinomial(GeneratorType& generator, dtype inN, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inN < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input number of trials must be greater than or equal to zero.");
            }

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            std::negative_binomial_distribution<dtype> dist(inN, inP);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "negative Binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inN: number of trials
        /// @param inP: probablity of success [0, 1]
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> negativeBinomial(GeneratorType& generator, const Shape& inShape, dtype inN, double inP = 0.5)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inN < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input number of trials must be greater than or equal to zero.");
            }

            if (inP < 0 || inP > 1)
            {
                THROW_INVALID_ARGUMENT_ERROR("input probability of sucess must be of the range [0, 1].");
            }

            NdArray<dtype> returnArray(inShape);

            std::negative_binomial_distribution<dtype> dist(inN, inP);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "negative Binomial" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
    ///
    /// @param inN: number of trials
    /// @param inP: probablity of success [0, 1]
    /// @return NdArray
    ///
    template<typename dtype>
    dtype negativeBinomial(dtype inN, double inP = 0.5)
    {
        return detail::negativeBinomial(generator_, inN, inP);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "negative Binomial" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
    ///
    /// @param inShape
    /// @param inN: number of trials
    /// @param inP: probablity of success [0, 1]
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> negativeBinomial(const Shape& inShape, dtype inN, double inP = 0.5)
    {
        return detail::negativeBinomial(generator_, inShape, inN, inP);
    }
} // namespace nc::random

/*** End of inlined file: negativeBinomial.hpp ***/


/*** Start of inlined file: nonCentralChiSquared.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "non central chi squared" distrubution.
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>
#include <string>

#include "boost/random/non_central_chi_squared_distribution.hpp"

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "non central chi squared" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
        ///
        /// @param generator: instance of a random number generator
        /// @param inK (default 1)
        /// @param inLambda (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype nonCentralChiSquared(GeneratorType& generator, dtype inK = 1, dtype inLambda = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inK <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input k must be greater than zero.");
            }

            if (inLambda <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input lambda must be greater than zero.");
            }

            boost::random::non_central_chi_squared_distribution<dtype> dist(inK, inLambda);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "non central chi squared" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inK (default 1)
        /// @param inLambda (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype>
            nonCentralChiSquared(GeneratorType& generator, const Shape& inShape, dtype inK = 1, dtype inLambda = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inK <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input k must be greater than zero.");
            }

            if (inLambda <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input lambda must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            boost::random::non_central_chi_squared_distribution<dtype> dist(inK, inLambda);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "non central chi squared" distrubution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
    ///
    /// @param inK (default 1)
    /// @param inLambda (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype nonCentralChiSquared(dtype inK = 1, dtype inLambda = 1)
    {
        return detail::nonCentralChiSquared(generator_, inK, inLambda);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "non central chi squared" distrubution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
    ///
    /// @param inShape
    /// @param inK (default 1)
    /// @param inLambda (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> nonCentralChiSquared(const Shape& inShape, dtype inK = 1, dtype inLambda = 1)
    {
        return detail::nonCentralChiSquared(generator_, inShape, inK, inLambda);
    }
} // namespace nc::random

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: nonCentralChiSquared.hpp ***/


/*** Start of inlined file: normal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "normal" distrubution.
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "normal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
        ///
        /// @param generator: instance of a random number generator
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype normal(GeneratorType& generator, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            std::normal_distribution<dtype> dist(inMean, inSigma);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "normal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> normal(GeneratorType& generator, const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inSigma <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input sigma must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::normal_distribution<dtype> dist(inMean, inSigma);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "normal" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
    ///
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype normal(dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::normal(generator_, inMean, inSigma);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "normal" distrubution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
    ///
    /// @param inShape
    /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
    /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
    /// Default is 1.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> normal(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
    {
        return detail::normal(generator_, inShape, inMean, inSigma);
    }
} // namespace nc::random

/*** End of inlined file: normal.hpp ***/


/*** Start of inlined file: poisson.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "poisson" distribution
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "poisson" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
        ///
        /// @param generator: instance of a random number generator
        /// @param inMean (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype poisson(GeneratorType& generator, double inMean = 1)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inMean <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input mean must be greater than zero.");
            }

            std::poisson_distribution<dtype> dist(inMean);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "poisson" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inMean (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> poisson(GeneratorType& generator, const Shape& inShape, double inMean = 1)
        {
            STATIC_ASSERT_INTEGER(dtype);

            if (inMean <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input mean must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::poisson_distribution<dtype> dist(inMean);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "poisson" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
    ///
    /// @param inMean (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype poisson(double inMean = 1)
    {
        return detail::poisson<dtype>(generator_, inMean);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "poisson" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
    ///
    /// @param inShape
    /// @param inMean (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> poisson(const Shape& inShape, double inMean = 1)
    {
        return detail::poisson<dtype>(generator_, inShape, inMean);
    }
} // namespace nc::random

/*** End of inlined file: poisson.hpp ***/


/*** Start of inlined file: rand.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Create an array of the given shape and populate it with
/// random samples from a uniform distribution over [0, 1).
///
#pragma once

#include <algorithm>
#include <random>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the uniform distribution over [0, 1).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
        ///
        /// @param generator: instance of a random number generator
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype rand(GeneratorType& generator)
        {
            STATIC_ASSERT_FLOAT(dtype);

            std::uniform_real_distribution<dtype> dist(static_cast<dtype>(0.),
                                                       static_cast<dtype>(1.) - DtypeInfo<dtype>::epsilon());
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a uniform distribution over [0, 1).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> rand(GeneratorType& generator, const Shape& inShape)
        {
            STATIC_ASSERT_FLOAT(dtype);

            NdArray<dtype> returnArray(inShape);

            std::uniform_real_distribution<dtype> dist(static_cast<dtype>(0.),
                                                       static_cast<dtype>(1.) - DtypeInfo<dtype>::epsilon());

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the uniform distribution over [0, 1).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    dtype rand()
    {
        return detail::rand<dtype>(generator_);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a uniform distribution over [0, 1).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> rand(const Shape& inShape)
    {
        return detail::rand<dtype>(generator_, inShape);
    }
} // namespace nc::random

/*** End of inlined file: rand.hpp ***/


/*** Start of inlined file: randFloat.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Return random floats from low (inclusive) to high (exclusive),
/// with the given shape
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Return a single random float from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
        ///
        /// @param generator: instance of a random number generator
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype randFloat(GeneratorType& generator, dtype inLow, dtype inHigh = 0.)
        {
            STATIC_ASSERT_FLOAT(dtype);

            if (utils::essentiallyEqual(inLow, inHigh))
            {
                THROW_INVALID_ARGUMENT_ERROR("input low value must be less than the input high value.");
            }
            else if (inLow > inHigh)
            {
                std::swap(inLow, inHigh);
            }

            std::uniform_real_distribution<dtype> dist(inLow, inHigh - DtypeInfo<dtype>::epsilon());
            return dist(generator);
        }

        // Method Description:
        /// Return random floats from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> randFloat(GeneratorType& generator, const Shape& inShape, dtype inLow, dtype inHigh = 0.)
        {
            STATIC_ASSERT_FLOAT(dtype);

            if (utils::essentiallyEqual(inLow, inHigh))
            {
                THROW_INVALID_ARGUMENT_ERROR("input low value must be less than the input high value.");
            }
            else if (inLow > inHigh)
            {
                std::swap(inLow, inHigh);
            }

            NdArray<dtype> returnArray(inShape);

            std::uniform_real_distribution<dtype> dist(inLow, inHigh - DtypeInfo<dtype>::epsilon());

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Return a single random float from low (inclusive) to high (exclusive),
    /// with the given shape. If no high value is input then the range will
    /// go from [0, low).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
    ///
    /// @param inLow
    /// @param inHigh default 0.
    /// @return NdArray
    ///
    template<typename dtype>
    dtype randFloat(dtype inLow, dtype inHigh = 0.)
    {
        return detail::randFloat(generator_, inLow, inHigh);
    }

    // Method Description:
    /// Return random floats from low (inclusive) to high (exclusive),
    /// with the given shape. If no high value is input then the range will
    /// go from [0, low).
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
    ///
    /// @param inShape
    /// @param inLow
    /// @param inHigh default 0.
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> randFloat(const Shape& inShape, dtype inLow, dtype inHigh = 0.)
    {
        return detail::randFloat(generator_, inShape, inLow, inHigh);
    }
} // namespace nc::random

/*** End of inlined file: randFloat.hpp ***/


/*** Start of inlined file: randN.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "standard normal" distribution.
///
#pragma once

#include <algorithm>
#include <random>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Returns a single random value sampled from the "standard normal" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
        ///
        /// @param generator: instance of a random number generator
        /// @return dtype
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype randN(GeneratorType& generator)
        {
            STATIC_ASSERT_FLOAT(dtype);

            std::normal_distribution<dtype> dist;
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "standard normal" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> randN(GeneratorType& generator, const Shape& inShape)
        {
            STATIC_ASSERT_FLOAT(dtype);

            NdArray<dtype> returnArray(inShape);

            std::normal_distribution<dtype> dist;

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Returns a single random value sampled from the "standard normal" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
    ///
    /// @return dtype
    ///
    template<typename dtype>
    dtype randN()
    {
        return detail::randN<dtype>(generator_);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "standard normal" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> randN(const Shape& inShape)
    {
        return detail::randN<dtype>(generator_, inShape);
    }
} // namespace nc::random

/*** End of inlined file: randN.hpp ***/


/*** Start of inlined file: shuffle.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
/// @version 1.1
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Modify a sequence in-place by shuffling its contents.
///
#pragma once

#include <algorithm>

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Modify a sequence in-place by shuffling its contents.
        ///
        /// @param generator: instance of a random number generator
        /// @param inArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        void shuffle(GeneratorType& generator, NdArray<dtype>& inArray)
        {
            std::shuffle(inArray.begin(), inArray.end(), generator);
        }
    } // namespace detail

    // Method Description:
    /// Modify a sequence in-place by shuffling its contents.
    ///
    /// @param inArray
    ///
    template<typename dtype>
    void shuffle(NdArray<dtype>& inArray)
    {
        return detail::shuffle(generator_, inArray);
    }
} // namespace nc::random

/*** End of inlined file: shuffle.hpp ***/


/*** Start of inlined file: standardNormal.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "standard normal" distrubution
///
#pragma once

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "standard normal" distrubution with
        /// mean = 0 and std = 1
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
        ///
        /// @param generator: instance of a random number generator
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype standardNormal(GeneratorType& generator)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return detail::normal<dtype>(generator, 0, 1);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "standard normal" distrubution with
        /// mean = 0 and std = 1
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> standardNormal(GeneratorType& generator, const Shape& inShape)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            return detail::normal<dtype>(generator, inShape, 0, 1);
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "standard normal" distrubution with
    /// mean = 0 and std = 1
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
    ///
    /// @return NdArray
    ///
    template<typename dtype>
    dtype standardNormal()
    {
        return detail::standardNormal<dtype>(generator_);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from a "standard normal" distrubution with
    /// mean = 0 and std = 1
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
    ///
    /// @param inShape
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> standardNormal(const Shape& inShape)
    {
        return detail::standardNormal<dtype>(generator_, inShape);
    }
} // namespace nc::random

/*** End of inlined file: standardNormal.hpp ***/


/*** Start of inlined file: studentT.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "student-T" distribution
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {
        // Method Description:
        /// Single random value sampled from the "student-T" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
        ///
        /// @param generator: instance of a random number generator
        /// @param inDof independent random variables
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype studentT(GeneratorType& generator, dtype inDof)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDof <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("degrees of freedom must be greater than zero.");
            }

            std::student_t_distribution<dtype> dist(inDof);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "student-T" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inDof independent random variables
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> studentT(GeneratorType& generator, const Shape& inShape, dtype inDof)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inDof <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("degrees of freedom must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::student_t_distribution<dtype> dist(inDof);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "student-T" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
    ///
    /// @param inDof independent random variables
    /// @return NdArray
    ///
    template<typename dtype>
    dtype studentT(dtype inDof)
    {
        return detail::studentT(generator_, inDof);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "student-T" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
    ///
    /// @param inShape
    /// @param inDof independent random variables
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> studentT(const Shape& inShape, dtype inDof)
    {
        return detail::studentT(generator_, inShape, inDof);
    }
} // namespace nc::random

/*** End of inlined file: studentT.hpp ***/


/*** Start of inlined file: triangle.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Create an array of the given shape and populate it with
/// random samples from the "triangle" distribution.
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>
#include <string>

#include "boost/random/triangle_distribution.hpp"

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Single random value sampled from the "triangle" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
        ///
        /// @param generator: instance of a random number generator
        /// @param inA
        /// @param inB
        /// @param inC
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype triangle(GeneratorType& generator, dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
        {
            STATIC_ASSERT_FLOAT(dtype);

            if (inA < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input A must be greater than or equal to zero.");
            }

            if (inB < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input B must be greater than or equal to zero.");
            }

            if (inC < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input C must be greater than or equal to zero.");
            }

            const bool aLessB = inA <= inB;
            const bool bLessC = inB <= inC;
            if (!(aLessB && bLessC))
            {
                THROW_INVALID_ARGUMENT_ERROR("inputs must be a <= b <= c.");
            }

            boost::random::triangle_distribution<dtype> dist(inA, inB, inC);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "triangle" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inA
        /// @param inB
        /// @param inC
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype>
            triangle(GeneratorType& generator, const Shape& inShape, dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
        {
            STATIC_ASSERT_FLOAT(dtype);

            if (inA < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input A must be greater than or equal to zero.");
            }

            if (inB < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input B must be greater than or equal to zero.");
            }

            if (inC < 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input C must be greater than or equal to zero.");
            }

            const bool aLessB = inA <= inB;
            const bool bLessC = inB <= inC;
            if (!(aLessB && bLessC))
            {
                THROW_INVALID_ARGUMENT_ERROR("inputs must be a <= b <= c.");
            }

            NdArray<dtype> returnArray(inShape);

            boost::random::triangle_distribution<dtype> dist(inA, inB, inC);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the "triangle" distribution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
    ///
    /// @param inA
    /// @param inB
    /// @param inC
    /// @return NdArray
    ///
    template<typename dtype>
    dtype triangle(dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
    {
        return detail::triangle(generator_, inA, inB, inC);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "triangle" distribution.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
    ///
    /// @param inShape
    /// @param inA
    /// @param inB
    /// @param inC
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> triangle(const Shape& inShape, dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
    {
        return detail::triangle(generator_, inShape, inA, inB, inC);
    }
} // namespace nc::random

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: triangle.hpp ***/


/*** Start of inlined file: uniform.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Draw samples from a uniform distribution.
///
#pragma once

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Draw sample from a uniform distribution.
        ///
        /// Samples are uniformly distributed over the half -
        /// open interval[low, high) (includes low, but excludes high)
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
        ///
        /// @param generator: instance of a random number generator
        /// @param inLow
        /// @param inHigh
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype uniform(GeneratorType& generator, dtype inLow, dtype inHigh)
        {
            STATIC_ASSERT_FLOAT(dtype);

            return detail::randFloat(generator, inLow, inHigh);
        }

        // Method Description:
        /// Draw samples from a uniform distribution.
        ///
        /// Samples are uniformly distributed over the half -
        /// open interval[low, high) (includes low, but excludes high)
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inLow
        /// @param inHigh
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> uniform(GeneratorType& generator, const Shape& inShape, dtype inLow, dtype inHigh)
        {
            STATIC_ASSERT_FLOAT(dtype);

            return detail::randFloat(generator, inShape, inLow, inHigh);
        }
    } // namespace detail

    // Method Description:
    /// Draw sample from a uniform distribution.
    ///
    /// Samples are uniformly distributed over the half -
    /// open interval[low, high) (includes low, but excludes high)
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
    ///
    /// @param inLow
    /// @param inHigh
    /// @return NdArray
    ///
    template<typename dtype>
    dtype uniform(dtype inLow, dtype inHigh)
    {
        return detail::uniform(generator_, inLow, inHigh);
    }

    // Method Description:
    /// Draw samples from a uniform distribution.
    ///
    /// Samples are uniformly distributed over the half -
    /// open interval[low, high) (includes low, but excludes high)
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
    ///
    /// @param inShape
    /// @param inLow
    /// @param inHigh
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> uniform(const Shape& inShape, dtype inLow, dtype inHigh)
    {
        return detail::uniform(generator_, inShape, inLow, inHigh);
    }
} // namespace nc::random

/*** End of inlined file: uniform.hpp ***/


/*** Start of inlined file: uniformOnSphere.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Such a distribution produces random numbers uniformly
/// distributed on the unit sphere of arbitrary dimension dim.
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <algorithm>
#include <string>

#include "boost/random/uniform_on_sphere.hpp"

namespace nc::random
{
    namespace detail
    {

        // Method Description:
        /// Such a distribution produces random numbers uniformly
        /// distributed on the unit sphere of arbitrary dimension dim.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// @param generator: instance of a random number generator
        /// @param inNumPoints
        /// @param inDims: dimension of the sphere (default 2)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> uniformOnSphere(GeneratorType& generator, uint32 inNumPoints, uint32 inDims = 2)
        {
            STATIC_ASSERT_FLOAT(dtype);

            if (inNumPoints == 0)
            {
                return {};
            }

            boost::random::uniform_on_sphere<dtype> dist(static_cast<int>(inDims));

            NdArray<dtype> returnArray(inNumPoints, inDims);
            for (uint32 row = 0; row < inNumPoints; ++row)
            {
                const auto& point = dist(generator);
                std::copy(point.begin(), point.end(), returnArray.begin(row));
            }

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Such a distribution produces random numbers uniformly
    /// distributed on the unit sphere of arbitrary dimension dim.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inNumPoints
    /// @param inDims: dimension of the sphere (default 2)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> uniformOnSphere(uint32 inNumPoints, uint32 inDims = 2)
    {
        return detail::uniformOnSphere<dtype>(generator_, inNumPoints, inDims);
    }
} // namespace nc::random

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: uniformOnSphere.hpp ***/


/*** Start of inlined file: weibull.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// "weibull" distribution
///
#pragma once

#include <algorithm>
#include <random>
#include <string>

namespace nc::random
{
    namespace detail
    {
        // Method Description:
        /// Single random value sampled from the  "weibull" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
        ///
        /// @param generator: instance of a random number generator
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        dtype weibull(GeneratorType& generator, dtype inA = 1, dtype inB = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inA <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input a must be greater than zero.");
            }

            if (inB <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input b must be greater than zero.");
            }

            std::weibull_distribution<dtype> dist(inA, inB);
            return dist(generator);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "weibull" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
        ///
        /// @param generator: instance of a random number generator
        /// @param inShape
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype, typename GeneratorType = std::mt19937>
        NdArray<dtype> weibull(GeneratorType& generator, const Shape& inShape, dtype inA = 1, dtype inB = 1)
        {
            STATIC_ASSERT_ARITHMETIC(dtype);

            if (inA <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input a must be greater than zero.");
            }

            if (inB <= 0)
            {
                THROW_INVALID_ARGUMENT_ERROR("input b must be greater than zero.");
            }

            NdArray<dtype> returnArray(inShape);

            std::weibull_distribution<dtype> dist(inA, inB);

            std::for_each(returnArray.begin(),
                          returnArray.end(),
                          [&generator, &dist](dtype& value) -> void { value = dist(generator); });

            return returnArray;
        }
    } // namespace detail

    // Method Description:
    /// Single random value sampled from the  "weibull" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
    ///
    /// @param inA (default 1)
    /// @param inB (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    dtype weibull(dtype inA = 1, dtype inB = 1)
    {
        return detail::weibull(generator_, inA, inB);
    }

    // Method Description:
    /// Create an array of the given shape and populate it with
    /// random samples from the "weibull" distribution.
    ///
    /// NumPy Reference:
    /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
    ///
    /// @param inShape
    /// @param inA (default 1)
    /// @param inB (default 1)
    /// @return NdArray
    ///
    template<typename dtype>
    NdArray<dtype> weibull(const Shape& inShape, dtype inA = 1, dtype inB = 1)
    {
        return detail::weibull(generator_, inShape, inA, inB);
    }
} // namespace nc::random

/*** End of inlined file: weibull.hpp ***/

namespace nc::random
{

    // Class Description:
    /// Random Number Generater Class with non-global state
    ///
    template<typename GeneratorType = std::mt19937_64>
    class RNG
    {
    public:

        // Method Description:
        /// Defualt Constructor
        ///
        RNG() = default;

        // Method Description:
        /// Seed Constructor
        ///
        /// @param seed: the seed value
        ///
        explicit RNG(int seed) :
            generator_(seed){};

        // Method Description:
        /// Single random value sampled from the "bernoulli" distribution.
        ///
        /// @param inP (probability of success [0, 1]). Default 0.5
        /// @return NdArray
        ///
        bool bernoulli(double inP = 0.5)
        {
            return detail::bernoulli(generator_, inP);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "bernoulli" distribution.
        ///
        /// @param inShape
        /// @param inP (probability of success [0, 1]). Default 0.5
        /// @return NdArray
        ///
        NdArray<bool> bernoulli(const Shape& inShape, double inP = 0.5)
        {
            return detail::bernoulli(generator_, inShape, inP);
        }

#ifndef NUMCPP_NO_USE_BOOST

        // Method Description:
        /// Single random value sampled from the from the "beta" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
        ///
        /// @param inAlpha
        /// @param inBeta
        /// @return NdArray
        ///
        template<typename dtype>
        dtype beta(dtype inAlpha, dtype inBeta)
        {
            return detail::beta(generator_, inAlpha, inBeta);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "beta" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html#numpy.random.beta
        ///
        /// @param inShape
        /// @param inAlpha
        /// @param inBeta
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> beta(const Shape& inShape, dtype inAlpha, dtype inBeta)
        {
            return detail::beta(generator_, inShape, inAlpha, inBeta);
        }
#endif

        // Method Description:
        /// Single random value sampled from the from the "binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
        ///
        /// @param inN (number of trials)
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype>
        dtype binomial(dtype inN, double inP = 0.5)
        {
            return detail::binomial(generator_, inN, inP);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html#numpy.random.binomial
        ///
        /// @param inShape
        /// @param inN (number of trials)
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> binomial(const Shape& inShape, dtype inN, double inP = 0.5)
        {
            return detail::binomial(generator_, inShape, inN, inP);
        }

        // Method Description:
        /// Single random value sampled from the from the "cauchy" distrubution.
        ///
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype cauchy(dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::cauchy(generator_, inMean, inSigma);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "cauchy" distrubution.
        ///
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> cauchy(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::cauchy(generator_, inShape, inMean, inSigma);
        }

        // Method Description:
        /// Single random value sampled from the from the "chi square" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
        ///
        /// @param inDof (independent random variables)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype chiSquare(dtype inDof)
        {
            return detail::chiSquare(generator_, inDof);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "chi square" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html#numpy.random.chisquare
        ///
        /// @param inShape
        /// @param inDof (independent random variables)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> chiSquare(const Shape& inShape, dtype inDof)
        {
            return detail::chiSquare(generator_, inShape, inDof);
        }

        // Method Description:
        /// Chooses a random sample from an input array.
        ///
        /// @param inArray
        /// @return NdArray
        ///
        template<typename dtype>
        dtype choice(const NdArray<dtype>& inArray)
        {
            return detail::choice(generator_, inArray);
        }

        // Method Description:
        /// Chooses inNum random samples from an input array.
        ///
        /// @param inArray
        /// @param inNum
        /// @param replace: Whether the sample is with or without replacement
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> choice(const NdArray<dtype>& inArray, uint32 inNum, Replace replace = Replace::YES)
        {
            return detail::choice(generator_, inArray, inNum, replace);
        }

        // Method Description:
        /// Single random value sampled from the from the
        /// "discrete" distrubution.  It produces integers in the
        /// range [0, n) with the probability of producing each value
        /// is specified by the parameters of the distribution.
        ///
        /// @param inWeights
        /// @return NdArray
        ///
        template<typename dtype>
        dtype discrete(const NdArray<double>& inWeights)
        {
            return detail::discrete<dtype>(generator_, inWeights);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "discrete" distrubution.  It produces
        /// integers in the range [0, n) with the probability of
        /// producing each value is specified by the parameters
        /// of the distribution.
        ///
        /// @param inShape
        /// @param inWeights
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> discrete(const Shape& inShape, const NdArray<double>& inWeights)
        {
            return detail::discrete<dtype>(generator_, inShape, inWeights);
        }

        // Method Description:
        /// Single random value sampled from the "exponential" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
        ///
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype exponential(dtype inScaleValue = 1)
        {
            return detail::exponential(generator_, inScaleValue);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "exponential" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html#numpy.random.exponential
        ///
        /// @param inShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> exponential(const Shape& inShape, dtype inScaleValue = 1)
        {
            return detail::exponential(generator_, inShape, inScaleValue);
        }

        // Method Description:
        /// Single random value sampled from the "extreme value" distrubution.
        ///
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype extremeValue(dtype inA = 1, dtype inB = 1)
        {
            return detail::extremeValue(generator_, inA, inB);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "extreme value" distrubution.
        ///
        /// @param inShape
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> extremeValue(const Shape& inShape, dtype inA = 1, dtype inB = 1)
        {
            return detail::extremeValue(generator_, inShape, inA, inB);
        }

        // Method Description:
        /// Single random value sampled from the "F" distrubution.
        ///
        /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
        ///
        /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
        /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype f(dtype inDofN, dtype inDofD)
        {
            return detail::f(generator_, inDofN, inDofD);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "F" distrubution.
        ///
        /// NumPy Reference: https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html#numpy.random.f
        ///
        /// @param inShape
        /// @param inDofN: Degrees of freedom in numerator. Should be greater than zero.
        /// @param inDofD: Degrees of freedom in denominator. Should be greater than zero.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> f(const Shape& inShape, dtype inDofN, dtype inDofD)
        {
            return detail::f(generator_, inShape, inDofN, inDofD);
        }

        // Method Description:
        /// Single random value sampled from the "gamma" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
        ///
        /// @param inGammaShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype gamma(dtype inGammaShape, dtype inScaleValue = 1)
        {
            return detail::gamma(generator_, inGammaShape, inScaleValue);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "gamma" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html#numpy.random.gamma
        ///
        /// @param inShape
        /// @param inGammaShape
        /// @param inScaleValue (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> gamma(const Shape& inShape, dtype inGammaShape, dtype inScaleValue = 1)
        {
            return detail::gamma(generator_, inShape, inGammaShape, inScaleValue);
        }

        // Method Description:
        /// Single random value sampled from the "geometric" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
        ///
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype>
        dtype geometric(double inP = 0.5)
        {
            return detail::geometric<dtype>(generator_, inP);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "geometric" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html#numpy.random.geometric
        ///
        /// @param inShape
        /// @param inP (probablity of success [0, 1])
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> geometric(const Shape& inShape, double inP = 0.5)
        {
            return detail::geometric<dtype>(generator_, inShape, inP);
        }

#ifndef NUMCPP_NO_USE_BOOST

        // Method Description:
        /// Single random value sampled from the "laplace" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
        ///
        /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
        /// @param inScale: (float optional the exponential decay. Default is 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype laplace(dtype inLoc = 0, dtype inScale = 1)
        {
            return detail::laplace(generator_, inLoc, inScale);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "laplace" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html#numpy.random.laplace
        ///
        /// @param inShape
        /// @param inLoc: (The position, mu, of the distribution peak. Default is 0)
        /// @param inScale: (float optional the exponential decay. Default is 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> laplace(const Shape& inShape, dtype inLoc = 0, dtype inScale = 1)
        {
            return detail::laplace(generator_, inShape, inLoc, inScale);
        }
#endif

        // Method Description:
        /// Single random value sampled from the "lognormal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
        ///
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype lognormal(dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::lognormal(generator_, inMean, inSigma);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "lognormal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html#numpy.random.lognormal
        ///
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> lognormal(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::lognormal(generator_, inShape, inMean, inSigma);
        }

        // Method Description:
        /// Single random value sampled from the "negative Binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
        ///
        /// @param inN: number of trials
        /// @param inP: probablity of success [0, 1]
        /// @return NdArray
        ///
        template<typename dtype>
        dtype negativeBinomial(dtype inN, double inP = 0.5)
        {
            return detail::negativeBinomial(generator_, inN, inP);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "negative Binomial" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html#numpy.random.negative_binomial
        ///
        /// @param inShape
        /// @param inN: number of trials
        /// @param inP: probablity of success [0, 1]
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> negativeBinomial(const Shape& inShape, dtype inN, double inP = 0.5)
        {
            return detail::negativeBinomial(generator_, inShape, inN, inP);
        }

#ifndef NUMCPP_NO_USE_BOOST

        // Method Description:
        /// Single random value sampled from the "non central chi squared" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
        ///
        /// @param inK (default 1)
        /// @param inLambda (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype nonCentralChiSquared(dtype inK = 1, dtype inLambda = 1)
        {
            return detail::nonCentralChiSquared(generator_, inK, inLambda);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "non central chi squared" distrubution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html#numpy.random.noncentral_chisquare
        ///
        /// @param inShape
        /// @param inK (default 1)
        /// @param inLambda (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> nonCentralChiSquared(const Shape& inShape, dtype inK = 1, dtype inLambda = 1)
        {
            return detail::nonCentralChiSquared(generator_, inShape, inK, inLambda);
        }
#endif

        // Method Description:
        /// Single random value sampled from the "normal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
        ///
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype normal(dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::normal(generator_, inMean, inSigma);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "normal" distrubution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html#numpy.random.normal
        ///
        /// @param inShape
        /// @param inMean: Mean value of the underlying normal distribution. Default is 0.
        /// @param inSigma: Standard deviation of the underlying normal distribution. Should be greater than zero.
        /// Default is 1.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> normal(const Shape& inShape, dtype inMean = 0, dtype inSigma = 1)
        {
            return detail::normal(generator_, inShape, inMean, inSigma);
        }

        // Method Description:
        /// Randomly permute a sequence, or return a permuted range.
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements randomly.
        ///
        /// @param inValue
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> permutation(dtype inValue)
        {
            return detail::permutation(generator_, inValue);
        }

        // Method Description:
        /// Randomly permute a sequence, or return a permuted range.
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements randomly.
        ///
        /// @param inArray
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> permutation(const NdArray<dtype>& inArray)
        {
            return detail::permutation(generator_, inArray);
        }

        // Method Description:
        /// Single random value sampled from the "poisson" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
        ///
        /// @param inMean (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype poisson(double inMean = 1)
        {
            return detail::poisson<dtype>(generator_, inMean);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "poisson" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html#numpy.random.poisson
        ///
        /// @param inShape
        /// @param inMean (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> poisson(const Shape& inShape, double inMean = 1)
        {
            return detail::poisson<dtype>(generator_, inShape, inMean);
        }

        // Method Description:
        /// Single random value sampled from the uniform distribution over [0, 1).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
        ///
        /// @return NdArray
        ///
        template<typename dtype>
        dtype rand()
        {
            return detail::rand<dtype>(generator_);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a uniform distribution over [0, 1).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand
        ///
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> rand(const Shape& inShape)
        {
            return detail::rand<dtype>(generator_, inShape);
        }

        // Method Description:
        /// Return a single random float from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
        ///
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype randFloat(dtype inLow, dtype inHigh = 0.)
        {
            return detail::randFloat(generator_, inLow, inHigh);
        }

        // Method Description:
        /// Return random floats from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html#numpy.random.ranf
        ///
        /// @param inShape
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> randFloat(const Shape& inShape, dtype inLow, dtype inHigh = 0.)
        {
            return detail::randFloat(generator_, inShape, inLow, inHigh);
        }

        // Method Description:
        /// Return random integer from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
        ///
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype>
        dtype randInt(dtype inLow, dtype inHigh = 0)
        {
            return detail::randInt(generator_, inLow, inHigh);
        }

        // Method Description:
        /// Return random integers from low (inclusive) to high (exclusive),
        /// with the given shape. If no high value is input then the range will
        /// go from [0, low).
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html#numpy.random.randint
        ///
        /// @param inShape
        /// @param inLow
        /// @param inHigh default 0.
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> randInt(const Shape& inShape, dtype inLow, dtype inHigh = 0)
        {
            return detail::randInt(generator_, inShape, inLow, inHigh);
        }

        // Method Description:
        /// Returns a single random value sampled from the "standard normal" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
        ///
        /// @return dtype
        ///
        template<typename dtype>
        dtype randN()
        {
            return detail::randN<dtype>(generator_);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "standard normal" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn
        ///
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> randN(const Shape& inShape)
        {
            return detail::randN<dtype>(generator_, inShape);
        }

        // Method Description:
        /// Seed Constructor
        ///
        /// @param value: the seed value
        ///
        void seed(int value) noexcept
        {
            generator_.seed(value);
        }

        // Method Description:
        /// Modify a sequence in-place by shuffling its contents.
        ///
        /// @param inArray
        ///
        template<typename dtype>
        void shuffle(NdArray<dtype>& inArray)
        {
            return detail::shuffle(generator_, inArray);
        }

        // Method Description:
        /// Single random value sampled from the "standard normal" distrubution with
        /// mean = 0 and std = 1
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
        ///
        /// @return NdArray
        ///
        template<typename dtype>
        dtype standardNormal()
        {
            return detail::standardNormal<dtype>(generator_);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from a "standard normal" distrubution with
        /// mean = 0 and std = 1
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html#numpy.random.standard_normal
        ///
        /// @param inShape
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> standardNormal(const Shape& inShape)
        {
            return detail::standardNormal<dtype>(generator_, inShape);
        }

        // Method Description:
        /// Single random value sampled from the "student-T" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
        ///
        /// @param inDof independent random variables
        /// @return NdArray
        ///
        template<typename dtype>
        dtype studentT(dtype inDof)
        {
            return detail::studentT(generator_, inDof);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "student-T" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html#numpy.random.standard_t
        ///
        /// @param inShape
        /// @param inDof independent random variables
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> studentT(const Shape& inShape, dtype inDof)
        {
            return detail::studentT(generator_, inShape, inDof);
        }

#ifndef NUMCPP_NO_USE_BOOST

        // Method Description:
        /// Single random value sampled from the "triangle" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
        ///
        /// @param inA
        /// @param inB
        /// @param inC
        /// @return NdArray
        ///
        template<typename dtype>
        dtype triangle(dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
        {
            return detail::triangle(generator_, inA, inB, inC);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "triangle" distribution.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html#numpy.random.triangular
        ///
        /// @param inShape
        /// @param inA
        /// @param inB
        /// @param inC
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> triangle(const Shape& inShape, dtype inA = 0, dtype inB = 0.5, dtype inC = 1)
        {
            return detail::triangle(generator_, inShape, inA, inB, inC);
        }
#endif

        // Method Description:
        /// Draw sample from a uniform distribution.
        ///
        /// Samples are uniformly distributed over the half -
        /// open interval[low, high) (includes low, but excludes high)
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
        ///
        /// @param inLow
        /// @param inHigh
        /// @return NdArray
        ///
        template<typename dtype>
        dtype uniform(dtype inLow, dtype inHigh)
        {
            return detail::uniform(generator_, inLow, inHigh);
        }

        // Method Description:
        /// Draw samples from a uniform distribution.
        ///
        /// Samples are uniformly distributed over the half -
        /// open interval[low, high) (includes low, but excludes high)
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html#numpy.random.uniform
        ///
        /// @param inShape
        /// @param inLow
        /// @param inHigh
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> uniform(const Shape& inShape, dtype inLow, dtype inHigh)
        {
            return detail::uniform(generator_, inShape, inLow, inHigh);
        }

#ifndef NUMCPP_NO_USE_BOOST

        // Method Description:
        /// Such a distribution produces random numbers uniformly
        /// distributed on the unit sphere of arbitrary dimension dim.
        /// NOTE: Use of this function requires using the Boost includes.
        ///
        /// @param inNumPoints
        /// @param inDims: dimension of the sphere (default 2)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> uniformOnSphere(uint32 inNumPoints, uint32 inDims = 2)
        {
            return detail::uniformOnSphere<dtype>(generator_, inNumPoints, inDims);
        }
#endif

        // Method Description:
        /// Single random value sampled from the  "weibull" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
        ///
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        dtype weibull(dtype inA = 1, dtype inB = 1)
        {
            return detail::weibull(generator_, inA, inB);
        }

        // Method Description:
        /// Create an array of the given shape and populate it with
        /// random samples from the "weibull" distribution.
        ///
        /// NumPy Reference:
        /// https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html#numpy.random.weibull
        ///
        /// @param inShape
        /// @param inA (default 1)
        /// @param inB (default 1)
        /// @return NdArray
        ///
        template<typename dtype>
        NdArray<dtype> weibull(const Shape& inShape, dtype inA = 1, dtype inB = 1)
        {
            return detail::weibull(generator_, inShape, inA, inB);
        }

    private:
        GeneratorType generator_{};
    };
} // namespace nc::random

/*** End of inlined file: RNG.hpp ***/

/*** End of inlined file: Random.hpp ***/


/*** Start of inlined file: Roots.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Simple Vector classes
///
#pragma once


/*** Start of inlined file: Bisection.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <cmath>
#include <functional>
#include <utility>


/*** Start of inlined file: Iteration.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <functional>

namespace nc::roots
{

    // Class Description:
    /// ABC for iteration classes to derive from
    class Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        ///
        explicit Iteration(double epsilon) noexcept :
            epsilon_(epsilon)
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        ///
        Iteration(double epsilon, uint32 maxNumIterations) noexcept :
            epsilon_(epsilon),
            maxNumIterations_(maxNumIterations)
        {
        }

        // Method Description:
        /// Destructor
        ///
        virtual ~Iteration() noexcept = default;

        // Method Description:
        /// Returns the number of iterations
        ///
        /// @return: number of iterations
        ///
        [[nodiscard]] uint32 numIterations() const noexcept
        {
            return numIterations_;
        }

    protected:

        // Method Description:
        /// Resets the number of iterations
        ///
        void resetNumberOfIterations() noexcept
        {
            numIterations_ = 0;
        }

        // Method Description:
        /// Incraments the number of iterations
        ///
        void incrementNumberOfIterations()
        {
            ++numIterations_;
            if (numIterations_ > maxNumIterations_)
            {
                THROW_RUNTIME_ERROR(
                    "Maximum number of iterations has been reached; no root has been found within epsilon.");
            }
        }

        //====================================Attributes==============================
        const double epsilon_;
        uint32       maxNumIterations_{ 1000 };
        uint32       numIterations_{ 0 };
    };
} // namespace nc::roots

/*** End of inlined file: Iteration.hpp ***/

namespace nc::roots
{

    // Class Description:
    /// Bisection root finding method
    ///
    class Bisection : public Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param f: the function
        ///
        Bisection(const double epsilon, std::function<double(double)> f) noexcept :
            Iteration(epsilon),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        /// @param f: the function
        ///
        Bisection(const double epsilon, const uint32 maxNumIterations, std::function<double(double)> f) noexcept :
            Iteration(epsilon, maxNumIterations),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Destructor
        ///
        ~Bisection() override = default;

        // Method Description:
        /// Solves for the root in the range [a, b]
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return root between the bound
        ///
        double solve(double a, double b)
        {
            resetNumberOfIterations();
            checkAndFixAlgorithmCriteria(a, b);

            double x  = 0.5 * (a + b);
            double fx = f_(x);

            while (std::fabs(fx) >= epsilon_)
            {
                x  = calculateX(x, a, b, fx);
                fx = f_(x);

                incrementNumberOfIterations();
            }

            return x;
        }

    private:

        const std::function<double(double)> f_;

        // Method Description:
        /// Checks the bounds criteria
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        ///
        void checkAndFixAlgorithmCriteria(double &a, double &b) const noexcept
        {
            // Algorithm works in range [a,b] if criteria f(a)*f(b) < 0 and f(a) > f(b) is fulfilled
            if (f_(a) < f_(b))
            {
                std::swap(a, b);
            }
        }

        // Method Description:
        /// Calculates the bisection point
        ///
        /// @param x: the evaluation point
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @param fx: the function evaluated at x
        /// @return x
        ///
        static double calculateX(double x, double &a, double &b, double fx) noexcept
        {
            if (fx < 0)
            {
                b = x;
            }
            else
            {
                a = x;
            }

            return 0.5 * (a + b);
        }
    };
} // namespace nc::roots

/*** End of inlined file: Bisection.hpp ***/


/*** Start of inlined file: Brent.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <cmath>
#include <functional>
#include <utility>

namespace nc::roots
{

    // Class Description:
    /// Brent root finding method
    ///
    class Brent : public Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param f: the function
        ///
        Brent(const double epsilon, std::function<double(double)> f) noexcept :
            Iteration(epsilon),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        /// @param f: the function
        ///
        Brent(const double epsilon, const uint32 maxNumIterations, std::function<double(double)> f) noexcept :
            Iteration(epsilon, maxNumIterations),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Destructor
        ///
        ~Brent() override = default;

        // Method Description:
        /// Solves for the root in the range [a, b]
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return root between the bound
        ///
        double solve(double a, double b)
        {
            resetNumberOfIterations();

            double fa = f_(a);
            double fb = f_(b);

            checkAndFixAlgorithmCriteria(a, b, fa, fb);

            double lastB        = a; // b_{k-1}
            double lastFb       = fa;
            double s            = DtypeInfo<double>::max();
            double fs           = DtypeInfo<double>::max();
            double penultimateB = a; // b_{k-2}

            bool bisection = true;
            while (std::fabs(fb) > epsilon_ && std::fabs(fs) > epsilon_ && std::fabs(b - a) > epsilon_)
            {
                if (useInverseQuadraticInterpolation(fa, fb, lastFb))
                {
                    s = calculateInverseQuadraticInterpolation(a, b, lastB, fa, fb, lastFb);
                }
                else
                {
                    s = calculateSecant(a, b, fa, fb);
                }

                if (useBisection(bisection, b, lastB, penultimateB, s))
                {
                    s         = calculateBisection(a, b);
                    bisection = true;
                }
                else
                {
                    bisection = false;
                }

                fs           = f_(s);
                penultimateB = lastB;
                lastB        = b;

                if (fa * fs < 0)
                {
                    b = s;
                }
                else
                {
                    a = s;
                }

                fa     = f_(a);
                lastFb = fb;
                fb     = f_(b);
                checkAndFixAlgorithmCriteria(a, b, fa, fb);

                incrementNumberOfIterations();
            }

            return fb < fs ? b : s;
        }

    private:

        const std::function<double(double)> f_;

        // Method Description:
        /// Calculates the bisection point
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return x
        ///
        static double calculateBisection(const double a, const double b) noexcept
        {
            return 0.5 * (a + b);
        }

        // Method Description:
        /// Calculates the secant point
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @param fa: the function evaluated at a
        /// @param fb: the function evaluated at b
        /// @return the secant point
        ///
        static double calculateSecant(const double a, const double b, const double fa, const double fb) noexcept
        {
            // No need to check division by 0, in this case the method returns NAN which is taken care by
            // useSecantMethod method
            return b - fb * (b - a) / (fb - fa);
        }

        // Method Description:
        /// Calculates the inverse quadratic interpolation
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @param lastB: the previous upper bound
        /// @param fa: the function evaluated at a
        /// @param fb: the function evaluated at b
        /// @param lastFb: the previous function evaluated at the upper bound
        /// @return the inverse quadratic interpolation
        ///
        static double calculateInverseQuadraticInterpolation(const double a,
                                                             const double b,
                                                             const double lastB,
                                                             const double fa,
                                                             const double fb,
                                                             const double lastFb) noexcept
        {
            return a * fb * lastFb / ((fa - fb) * (fa - lastFb)) + b * fa * lastFb / ((fb - fa) * (fb - lastFb)) +
                   lastB * fa * fb / ((lastFb - fa) * (lastFb - fb));
        }

        // Method Description:
        /// Uses the inverse quadratic interpolation
        ///
        /// @param fa: the function evaluated at a
        /// @param fb: the function evaluated at b
        /// @param lastFb: the previous function evaluated at the upper bound
        /// @return bool
        ///
        static bool useInverseQuadraticInterpolation(const double fa, const double fb, const double lastFb) noexcept
        {
            return !utils::essentiallyEqual(fa, lastFb) && utils::essentiallyEqual(fb, lastFb);
        }

        // Method Description:
        /// Checks the algorithm criteria
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @param fa: the function evaluated at a
        /// @param fb: the function evaluated at b
        ///
        static void checkAndFixAlgorithmCriteria(double &a, double &b, double &fa, double &fb) noexcept
        {
            // Algorithm works in range [a,b] if criteria f(a)*f(b) < 0 and f(a) > f(b) is fulfilled
            if (std::fabs(fa) < std::fabs(fb))
            {
                std::swap(a, b);
                std::swap(fa, fb);
            }
        }

        // Method Description:
        /// Uses the bisection
        ///
        /// @param bisection: the bisection point
        /// @param b: the upper bound
        /// @param lastB: the previous upper bound
        /// @param penultimateB:
        /// @param s:
        /// @return bool
        ///
        [[nodiscard]] bool useBisection(const bool   bisection,
                                        const double b,
                                        const double lastB,
                                        const double penultimateB,
                                        const double s) const noexcept
        {
            const double DELTA = epsilon_ + std::numeric_limits<double>::min();

            return (bisection &&
                    std::fabs(s - b) >=
                        0.5 * std::fabs(b - lastB)) || // Bisection was used in last step but |s-b|>=|b-lastB|/2 <-
                                                       // Interpolation step would be to rough, so still use bisection
                   (!bisection && std::fabs(s - b) >=
                                      0.5 * std::fabs(lastB - penultimateB)) || // Interpolation was used in last step
                                                                                // but |s-b|>=|lastB-penultimateB|/2 <-
                                                                                // Interpolation step would be to small
                   (bisection &&
                    std::fabs(b - lastB) < DELTA) || // If last iteration was using bisection and difference between
                                                     // b and lastB is < delta use bisection for next iteration
                   (!bisection && std::fabs(lastB - penultimateB) <
                                      DELTA); // If last iteration was using interpolation but difference between
                                              // lastB ond penultimateB is < delta use biscetion for next iteration
        }
    };
} // namespace nc::roots

/*** End of inlined file: Brent.hpp ***/


/*** Start of inlined file: Dekker.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <cmath>
#include <functional>
#include <utility>

namespace nc::roots
{

    // Class Description:
    /// Dekker root finding method
    ///
    class Dekker : public Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param f: the function
        ///
        Dekker(const double epsilon, std::function<double(double)> f) noexcept :
            Iteration(epsilon),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        /// @param f: the function
        ///
        Dekker(const double epsilon, const uint32 maxNumIterations, std::function<double(double)> f) noexcept :
            Iteration(epsilon, maxNumIterations),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Destructor
        ///
        ~Dekker() override = default;

        // Method Description:
        /// Solves for the root in the range [a, b]
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return root between the bound
        ///
        double solve(double a, double b)
        {
            resetNumberOfIterations();

            double fa = f_(a);
            double fb = f_(b);

            checkAndFixAlgorithmCriteria(a, b, fa, fb);

            double lastB  = a;
            double lastFb = fa;

            while (std::fabs(fb) > epsilon_ && std::fabs(b - a) > epsilon_)
            {
                const double s = calculateSecant(b, fb, lastB, lastFb);
                const double m = calculateBisection(a, b);

                lastB = b;

                b = useSecantMethod(b, s, m) ? s : m;

                lastFb = fb;
                fb     = f_(b);

                if (fa * fb > 0 && fb * lastFb < 0)
                {
                    a = lastB;
                }

                fa = f_(a);
                checkAndFixAlgorithmCriteria(a, b, fa, fb);

                incrementNumberOfIterations();
            }

            return b;
        }

    private:

        const std::function<double(double)> f_;

        // Method Description:
        /// Checks the bounds criteria
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @param fa: the function evalulated at the lower bound
        /// @param fb: the function evalulated at the upper bound
        ///
        static void checkAndFixAlgorithmCriteria(double &a, double &b, double &fa, double &fb) noexcept
        {
            // Algorithm works in range [a,b] if criteria f(a)*f(b) < 0 and f(a) > f(b) is fulfilled
            if (std::fabs(fa) < std::fabs(fb))
            {
                std::swap(a, b);
                std::swap(fa, fb);
            }
        }

        // Method Description:
        /// Calculates secant
        ///
        /// @param b: the upper bound
        /// @param fb: the function evalulated at the upper bound
        /// @param lastB: the last upper bound
        /// @param lastFb: the function evalulated at the last upper bound
        /// @ return secant value
        ///
        static double calculateSecant(double b, double fb, double lastB, double lastFb) noexcept
        {
            // No need to check division by 0, in this case the method returns NAN which is taken care by
            // useSecantMethod method
            return b - fb * (b - lastB) / (fb - lastFb);
        }

        // Method Description:
        /// Calculate the bisection point
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return bisection point
        ///
        static double calculateBisection(double a, double b) noexcept
        {
            return 0.5 * (a + b);
        }

        // Method Description:
        /// Whether or not to use the secant method
        ///
        /// @param b: the upper bound
        /// @param s:
        /// @param m:
        /// @ return bool
        ///
        static bool useSecantMethod(double b, double s, double m) noexcept
        {
            // Value s calculated by secant method has to be between m and b
            return (b > m && s > m && s < b) || (b < m && s > b && s < m);
        }
    };
} // namespace nc::roots

/*** End of inlined file: Dekker.hpp ***/


/*** Start of inlined file: Newton.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <cmath>
#include <functional>
#include <utility>

namespace nc::roots
{

    // Class Description:
    /// Newton root finding method
    ///
    class Newton : public Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param f: the function
        /// @param fPrime: the derivative of the function
        ///
        Newton(const double epsilon, std::function<double(double)> f, std::function<double(double)> fPrime) noexcept :
            Iteration(epsilon),
            f_(std::move(f)),
            fPrime_(std::move(fPrime))
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        /// @param f: the function
        /// @param fPrime: the derivative of the function
        ///
        Newton(const double                  epsilon,
               const uint32                  maxNumIterations,
               std::function<double(double)> f,
               std::function<double(double)> fPrime) noexcept :
            Iteration(epsilon, maxNumIterations),
            f_(std::move(f)),
            fPrime_(std::move(fPrime))
        {
        }

        // Method Description:
        /// Destructor
        ///
        ~Newton() noexcept override = default;

        // Method Description:
        /// Solves for the root in the range [a, b]
        ///
        /// @param x: the starting point
        /// @return root nearest the starting point
        ///
        double solve(double x)
        {
            resetNumberOfIterations();

            double fx      = f_(x);
            double fxPrime = fPrime_(x);

            while (std::fabs(fx) >= epsilon_)
            {
                x = calculateX(x, fx, fxPrime);

                fx      = f_(x);
                fxPrime = fPrime_(x);

                incrementNumberOfIterations();
            }

            return x;
        }

    private:

        const std::function<double(double)> f_;
        const std::function<double(double)> fPrime_;

        // Method Description:
        /// Calculates x
        ///
        /// @param x: the current x value
        /// @param fx: the function evaluated at the current x value
        /// @param fxPrime: the derivate of the function evaluated at the current x value
        /// @return x
        ///
        static double calculateX(double x, double fx, double fxPrime) noexcept
        {
            return x - fx / fxPrime;
        }
    };
} // namespace nc::roots

/*** End of inlined file: Newton.hpp ***/


/*** Start of inlined file: Secant.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2019 Benjamin Mahr
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Finds the roots of the polynomial
///
/// Code modified under MIT license from https://github.com/Ben1980/rootApproximation
/// as posted in
/// https://thoughts-on-coding.com/2019/06/06/numerical-methods-with-cpp-part-3-root-approximation-algorithms/
///
#pragma once

#include <cmath>
#include <functional>
#include <utility>

namespace nc::roots
{

    // Class Description:
    /// Secant root finding method
    ///
    class Secant : public Iteration
    {
    public:

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param f: the function
        ///
        Secant(const double epsilon, std::function<double(double)> f) noexcept :
            Iteration(epsilon),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Constructor
        ///
        /// @param epsilon: the epsilon value
        /// @param maxNumIterations: the maximum number of iterations to perform
        /// @param f: the function
        ///
        Secant(const double epsilon, const uint32 maxNumIterations, std::function<double(double)> f) noexcept :
            Iteration(epsilon, maxNumIterations),
            f_(std::move(f))
        {
        }

        // Method Description:
        /// Destructor
        ///
        ~Secant() override = default;

        // Method Description:
        /// Solves for the root in the range [a, b]
        ///
        /// @param a: the lower bound
        /// @param b: the upper bound
        /// @return root between the bound
        ///
        double solve(double a, double b)
        {
            resetNumberOfIterations();

            if (f_(a) > f_(b))
            {
                std::swap(a, b);
            }

            double x      = b;
            double lastX  = a;
            double fx     = f_(b);
            double lastFx = f_(a);

            while (std::fabs(fx) >= epsilon_)
            {
                const double x_tmp = calculateX(x, lastX, fx, lastFx);

                lastFx = fx;
                lastX  = x;
                x      = x_tmp;

                fx = f_(x);

                incrementNumberOfIterations();
            }

            return x;
        }

    private:

        const std::function<double(double)> f_;

        // Method Description:
        /// Calculates x
        ///
        /// @param x: the current x value
        /// @param lastX: the previous x value
        /// @param fx: the function evaluated at the current x value
        /// @param lastFx: the function evaluated at the previous x value
        /// @return x
        ///
        static double calculateX(double x, double lastX, double fx, double lastFx) noexcept
        {
            const double functionDifference = fx - lastFx;
            return x - fx * (x - lastX) / functionDifference;
        }
    };
} // namespace nc::roots

/*** End of inlined file: Secant.hpp ***/

/*** End of inlined file: Roots.hpp ***/


/*** Start of inlined file: Rotations.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Module for dealing with rotations
///
#pragma once


/*** Start of inlined file: DCM.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Factory methods for generating direction cosine matrices and vectors
///
#pragma once

namespace nc::rotations
{

    /// Factory methods for generating direction cosine matrices and vectors
    class DCM
    {
    public:

        // Method Description:
        /// returns a direction cosine matrix that rotates according
        /// to the input euler angles
        ///
        /// @param roll: euler roll angle in radians
        /// @param pitch: euler pitch angle in radians
        /// @param yaw: euler yaw angle in radians
        /// @return NdArray
        ///
        static NdArray<double> eulerAngles(double roll, double pitch, double yaw)
        {
            return Quaternion(roll, pitch, yaw).toDCM();
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates according
        /// to the input euler angles
        ///
        /// @param angles: euler roll, pitch, angles
        /// @return NdArray
        ///
        static NdArray<double> eulerAngles(const NdArray<double>& angles)
        {
            return Quaternion(angles).toDCM();
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates about
        /// the input axis by the input angle
        ///
        /// @param inAxis: euler axis cartesian vector with x,y,z components
        /// @param inAngle: euler angle in radians
        /// @return NdArray
        ///
        static NdArray<double> eulerAxisAngle(const NdArray<double>& inAxis, double inAngle)
        {
            return Quaternion(inAxis, inAngle).toDCM();
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates about
        /// the input axis by the input angle
        ///
        /// @param inAxis: euler axis cartesian vector with x,y,z components
        /// @param inAngle: euler angle in radians
        /// @return NdArray
        ///
        static NdArray<double> eulerAxisAngle(const Vec3& inAxis, double inAngle)
        {
            return Quaternion(inAxis, inAngle).toDCM();
        }

        // Method Description:
        /// returns whether the input array is a direction cosine
        /// matrix
        ///
        /// @param inArray
        /// @return bool
        ///
        static bool isValid(const NdArray<double>& inArray)
        {
            const Shape inShape = inArray.shape();
            return inShape.rows == inShape.cols &&
                   utils::essentiallyEqual(round(linalg::det<double>(inArray), 2), 1.) &&
                   utils::essentiallyEqual(round(linalg::det<double>(inArray.transpose()), 2), 1.);
        }

        // Method Description:
        /// The euler roll angle in radians
        ///
        /// @param dcm: a valid direction cosine matrix
        /// @return euler roll angle in radians
        ///
        static double roll(const NdArray<double>& dcm)
        {
            return Quaternion(dcm).roll();
        }

        // Method Description:
        /// The euler pitch angle in radians
        ///
        /// @param dcm: a valid direction cosine matrix
        /// @return euler pitch angle in radians
        ///
        static double pitch(const NdArray<double>& dcm)
        {
            return Quaternion(dcm).pitch();
        }

        // Method Description:
        /// The euler yaw angle in radians
        ///
        /// @param dcm: a valid direction cosine matrix
        /// @return euler yaw angle in radians
        ///
        static double yaw(const NdArray<double>& dcm)
        {
            return Quaternion(dcm).yaw();
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates about
        /// the x axis by the input angle
        ///
        /// @param inAngle (in radians)
        /// @return NdArray<double>
        ///
        static NdArray<double> xRotation(double inAngle)
        {
            return DCM::eulerAxisAngle(Vec3{ 1., 0., 0. }, inAngle);
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates about
        /// the x axis by the input angle
        ///
        /// @param inAngle (in radians)
        /// @return NdArray<double>
        ///
        static NdArray<double> yRotation(double inAngle)
        {
            return DCM::eulerAxisAngle(Vec3{ 0., 1., 0. }, inAngle);
        }

        // Method Description:
        /// returns a direction cosine matrix that rotates about
        /// the x axis by the input angle
        ///
        /// @param inAngle (in radians)
        /// @return NdArray<double>
        ///
        static NdArray<double> zRotation(double inAngle)
        {
            return DCM::eulerAxisAngle(Vec3{ 0., 0., 1. }, inAngle);
        }
    };
} // namespace nc::rotations

/*** End of inlined file: DCM.hpp ***/


/*** Start of inlined file: rodriguesRotation.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Performs Rodriques' rotation formula
/// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
///
#pragma once

#include <cmath>

namespace nc::rotations
{

    // Method Description:
    /// Performs Rodriques' rotation formula
    /// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
    ///
    /// @param k: the axis to rotate around
    /// @param theta: the angle in radians to rotate
    /// @param v: the vector to rotate
    ///
    /// @return Vec3
    ///
    inline Vec3 rodriguesRotation(const Vec3& k, double theta, const Vec3& v) noexcept
    {
        const auto kUnit = k.normalize();

        const auto vCosTheta = v * std::cos(theta);

        auto kCrossV = kUnit.cross(v);
        kCrossV *= std::sin(theta);

        const auto kDotV  = kUnit.dot(v);
        auto       kkDotV = kUnit * kDotV;
        kkDotV *= 1 - std::cos(theta);

        auto vec = vCosTheta + kCrossV;
        vec += kkDotV;

        return vec;
    }

    // Method Description:
    /// Performs Rodriques' rotation formula
    /// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
    ///
    /// @param k: the axis to rotate around
    /// @param theta: the angle in radians to rotate
    /// @param v: the vector to rotate
    ///
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> rodriguesRotation(const NdArray<dtype>& k, double theta, const NdArray<dtype>& v)
    {
        return rodriguesRotation(Vec3(k), theta, Vec3(v)).toNdArray();
    }
} // namespace nc::rotations
/*** End of inlined file: rodriguesRotation.hpp ***/


/*** Start of inlined file: wahbasProblem.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// In applied mathematics, Wahba's problem, first posed by Grace Wahba in 1965, seeks to
/// find a rotation matrix (special orthogonal matrix) between two coordinate systems from
/// a set of (weighted) vector observations. Solutions to Wahba's problem are often used in
/// satellite attitude determination utilising sensors such as magnetometers and multi-antenna
/// GPS receivers
/// https://en.wikipedia.org/wiki/Wahba%27s_problem
///
#pragma once

namespace nc::rotations
{

    // Method Description:
    /// Finds a rotation matrix (special orthogonal matrix) between two coordinate
    /// systems from a set of (weighted) vector observations. Solutions to Wahba's
    /// problem are often used in satellite attitude determination utilising sensors
    /// such as magnetometers and multi-antenna GPS receivers
    /// https://en.wikipedia.org/wiki/Wahba%27s_problem
    ///
    /// @param wk: k-th 3-vector measurement in the reference frame (n x 3 matrix)
    /// @param vk: corresponding k-th 3-vector measurement in the body frame (n x 3 matrix)
    /// @param ak: set of weights for each observation (1 x n or n x 1 matrix)
    ///
    /// @return NdArray rotation matrix
    ///
    template<typename dtype>
    NdArray<double> wahbasProblem(const NdArray<dtype>& wk, const NdArray<dtype>& vk, const NdArray<dtype>& ak)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        const auto wkShape = wk.shape();
        if (wkShape.cols != 3)
        {
            THROW_INVALID_ARGUMENT_ERROR("wk matrix must be of shape [n, 3]");
        }

        const auto vkShape = vk.shape();
        if (vkShape.cols != 3)
        {
            THROW_INVALID_ARGUMENT_ERROR("vk matrix must be of shape [n, 3]");
        }

        if (wkShape.rows != vkShape.rows)
        {
            THROW_INVALID_ARGUMENT_ERROR("wk and vk matrices must have the same number of rows");
        }

        if (ak.size() != wkShape.rows)
        {
            THROW_INVALID_ARGUMENT_ERROR("ak matrix must have the same number of elements as wk and vk rows");
        }

        auto       b      = zeros<dtype>(3, 3);
        const auto cSlice = wk.cSlice();
        for (uint32 row = 0; row < wkShape.rows; ++row)
        {
            const auto wkVec = wk(row, cSlice);
            const auto vkVec = vk(row, cSlice);
            b += ak[row] * dot(wkVec.transpose(), vkVec);
        }

        NdArray<double> u;
        NdArray<double> s;
        NdArray<double> vt;

        linalg::svd(b, u, s, vt);

        auto m  = eye<double>(3, 3);
        m(0, 0) = 1.;
        m(1, 1) = 1.;
        m(2, 2) = linalg::det(u) * linalg::det(vt.transpose());

        return dot(u, dot(m, vt));
    }

    // Method Description:
    /// Finds a rotation matrix (special orthogonal matrix) between two coordinate
    /// systems from a set of (weighted) vector observations. Solutions to Wahba's
    /// problem are often used in satellite attitude determination utilising sensors
    /// such as magnetometers and multi-antenna GPS receivers
    /// https://en.wikipedia.org/wiki/Wahba%27s_problem
    ///
    /// @param wk: k-th 3-vector measurement in the reference frame
    /// @param vk: corresponding k-th 3-vector measurement in the body frame
    ///
    /// @return NdArray rotation matrix
    ///
    template<typename dtype>
    NdArray<double> wahbasProblem(const NdArray<dtype>& wk, const NdArray<dtype>& vk)
    {
        const auto ak = ones<dtype>({ 1, wk.shape().rows });
        return wahbasProblem(wk, vk, ak);
    }
} // namespace nc::rotations

/*** End of inlined file: wahbasProblem.hpp ***/

/*** End of inlined file: Rotations.hpp ***/


/*** Start of inlined file: Special.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once


/*** Start of inlined file: airy_ai.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/airy.hpp"

namespace nc::special
{

    // Method Description:
    /// The first linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto airy_ai(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::airy_ai(inValue);
    }

    // Method Description:
    /// The first linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto airy_ai(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(airy_ai(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return airy_ai(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: airy_ai.hpp ***/


/*** Start of inlined file: airy_ai_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/airy.hpp"

namespace nc::special
{

    // Method Description:
    /// The derivative of the first linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto airy_ai_prime(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::airy_ai_prime(inValue);
    }

    // Method Description:
    /// The derivative of the first linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto airy_ai_prime(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(airy_ai_prime(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return airy_ai_prime(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: airy_ai_prime.hpp ***/


/*** Start of inlined file: airy_bi.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/airy.hpp"

namespace nc::special
{

    // Method Description:
    /// The second linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto airy_bi(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::airy_bi(inValue);
    }

    // Method Description:
    /// The second linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto airy_bi(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(airy_bi(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return airy_bi(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: airy_bi.hpp ***/


/*** Start of inlined file: airy_bi_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/airy.hpp"

namespace nc::special
{

    // Method Description:
    /// The derivative of the second linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto airy_bi_prime(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::airy_bi_prime(inValue);
    }

    // Method Description:
    /// The derivative of the second linearly independent solution to the differential equation y'' - yz = 0.
    /// http://mathworld.wolfram.com/AiryFunctions.html
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto airy_bi_prime(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(airy_bi_prime(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return airy_bi_prime(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: airy_bi_prime.hpp ***/


/*** Start of inlined file: bernoulli.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/bernoulli.hpp"

namespace nc::special
{

    // Method Description:
    /// Both return the nth Bernoulli number B2n.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n
    /// @return double
    ///
    inline double bernoilli(uint32 n)
    {
        if (n == 1)
        {
            return 0.5;
        }
        if (n % 2 != 0)
        {
            return 0.;
        }

        return boost::math::bernoulli_b2n<double>(n / 2);
    }

    // Method Description:
    /// Both return the nth Bernoulli number B2n.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray<double>
    ///
    inline NdArray<double> bernoilli(const NdArray<uint32>& inArray)
    {
        NdArray<double> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](uint32 inValue) -> double { return bernoilli(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: bernoulli.hpp ***/


/*** Start of inlined file: bessel_in_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <type_traits>

#include "boost/math/special_functions/bessel_prime.hpp"

namespace nc::special
{

    // Method Description:
    /// Derivcative of the Modified Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_in_prime(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_bessel_i_prime(inV, inX);
    }

    // Method Description:
    /// Derivcative of the Modified Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_in_prime(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_in_prime(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_in_prime(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: bessel_in_prime.hpp ***/


/*** Start of inlined file: bessel_jn.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_jn(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::cyl_bessel_j(static_cast<double>(inV), static_cast<double>(inX));
#else
        return boost::math::cyl_bessel_j(static_cast<double>(inV), static_cast<double>(inX));
#endif
    }

    // Method Description:
    /// Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_jn(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_jn(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_jn(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: bessel_jn.hpp ***/


/*** Start of inlined file: bessel_jn_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <type_traits>

#include "boost/math/special_functions/bessel_prime.hpp"

namespace nc::special
{

    // Method Description:
    /// Derivcative of the Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_jn_prime(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_bessel_j_prime(inV, inX);
    }

    // Method Description:
    /// Derivcative of the Cylindrical Bessel function of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_jn_prime(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_jn_prime(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_jn_prime(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: bessel_jn_prime.hpp ***/


/*** Start of inlined file: bessel_kn.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Modified Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_kn(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::cyl_bessel_k(static_cast<double>(inV), static_cast<double>(inX));
#else
        return boost::math::cyl_bessel_k(static_cast<double>(inV), static_cast<double>(inX));
#endif
    }

    // Method Description:
    /// Modified Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_kn(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_kn(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_kn(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: bessel_kn.hpp ***/


/*** Start of inlined file: bessel_kn_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <type_traits>

#include "boost/math/special_functions/bessel_prime.hpp"

namespace nc::special
{

    // Method Description:
    /// Derivcative of the Modified Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_kn_prime(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_bessel_k_prime(inV, inX);
    }

    // Method Description:
    /// Derivcative of the Modified Cylindrical Bessel function of the second kind
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_kn_prime(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_kn_prime(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_kn_prime(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: bessel_kn_prime.hpp ***/


/*** Start of inlined file: bessel_yn.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_yn(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::cyl_neumann(static_cast<double>(inV), static_cast<double>(inX));
#else
        return boost::math::cyl_neumann(static_cast<double>(inV), static_cast<double>(inX));
#endif
    }

    // Method Description:
    /// Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_yn(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_yn(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_yn(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: bessel_yn.hpp ***/


/*** Start of inlined file: bessel_yn_prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <type_traits>

#include "boost/math/special_functions/bessel.hpp"

namespace nc::special
{

    // Method Description:
    /// Derivcative of the Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_yn_prime(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_neumann_prime(inV, inX);
    }

    // Method Description:
    /// Derivcative of the Cylindrical Bessel function of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto bessel_yn_prime(dtype1 inV, const NdArray<dtype2>& inArrayX)
    {
        NdArray<decltype(bessel_yn_prime(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inX) -> auto { return bessel_yn_prime(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: bessel_yn_prime.hpp ***/


/*** Start of inlined file: beta.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/beta.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// The beta function.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param a
    /// @param b
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto beta(dtype1 a, dtype2 b)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::beta(a, b);
#else
        return boost::math::beta(a, b);
#endif
    }

    // Method Description:
    /// The beta function.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayA
    /// @param inArrayB
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto beta(const NdArray<dtype1>& inArrayA, const NdArray<dtype2>& inArrayB)
    {
        NdArray<decltype(beta(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayB.shape());

        stl_algorithms::transform(inArrayA.cbegin(),
                                  inArrayA.cend(),
                                  inArrayB.cbegin(),
                                  returnArray.begin(),
                                  [](dtype1 a, dtype2 b) -> auto { return beta(a, b); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: beta.hpp ***/


/*** Start of inlined file: cnr.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <string>


/*** Start of inlined file: factorial.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST
#include "boost/math/special_functions/factorials.hpp"
#endif

#include <limits>

namespace nc::special
{

    // Method Description:
    /// Returns the factorial of the input value
    ///
    /// @param inValue
    /// @return double
    ///
    inline double factorial(uint32 inValue)
    {
#ifndef NUMCPP_NO_USE_BOOST
        if (inValue <= boost::math::max_factorial<double>::value)
        {
            return boost::math::factorial<double>(inValue);
        }

        return std::numeric_limits<double>::infinity();
#else
        double result = 1.;
        for (uint32 i = 2; i <= inValue; ++i)
        {
            result *= static_cast<double>(i);
        }

        return result;
#endif
    }

    // Method Description:
    /// Returns the factorial of the input value
    ///
    /// @param inArray
    /// @return NdArray<double>
    ///
    inline NdArray<double> factorial(const NdArray<uint32>& inArray)
    {
        NdArray<double> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](uint32 inValue) -> double { return factorial(inValue); });

        return returnArray;
    }
} // namespace nc::special

/*** End of inlined file: factorial.hpp ***/


/*** Start of inlined file: pnr.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST
#include "boost/math/special_functions/factorials.hpp"
#endif

namespace nc::special
{

    // Method Description:
    /// Returns the number of permutaions of n choose r. P(n, r)
    ///
    /// @param n: the total number of items
    /// @param r: the number of items taken
    /// @return double
    ///
    inline double pnr(uint32 n, uint32 r)
    {
        if (r > n)
        {
            return 0.;
        }
        else if (r == n)
        {
            return factorial(n);
        }

        double combinations = 1.;

#ifndef NUMCPP_NO_USE_BOOST
        if (n <= boost::math::max_factorial<double>::value)
        {
            const double nFactorial      = factorial(n);
            const double nMinusRFactoral = factorial(n - r);

            combinations = nFactorial / nMinusRFactoral;
        }
        else
        {
#endif
            const uint32 lower = n - r + 1;
            combinations       = static_cast<double>(lower);
            for (uint32 i = lower + 1; i <= n; ++i)
            {
                combinations *= static_cast<double>(i);
            }
#ifndef NUMCPP_NO_USE_BOOST
        }
#endif

        return combinations;
    }
} // namespace nc::special

/*** End of inlined file: pnr.hpp ***/

namespace nc::special
{

    // Method Description:
    /// Returns the number of combinations of n choose r. C(n, r)
    ///
    /// @param n: the total number of items
    /// @param r: the number of items taken
    /// @return double
    ///
    inline double cnr(uint32 n, uint32 r)
    {
        return pnr(n, r) / factorial(r);
    }
} // namespace nc::special

/*** End of inlined file: cnr.hpp ***/


/*** Start of inlined file: comp_ellint_1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_1.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the complete elliptic integral of the first kind of k.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto comp_ellint_1(dtype inK)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::comp_ellint_1(inK);
#else
        return boost::math::ellint_1(inK);
#endif
    }

    // Method Description:
    /// Computes the complete elliptic integral of the first kind of k.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: elliptic modulus or eccentricity
    /// @return NdArray
    ///
    template<typename dtype>
    auto comp_ellint_1(const NdArray<dtype>& inArrayK)
    {
        NdArray<decltype(comp_ellint_1(dtype{ 0 }))> returnArray(inArrayK.shape());

        stl_algorithms::transform(inArrayK.cbegin(),
                                  inArrayK.cend(),
                                  returnArray.begin(),
                                  [](dtype inK) -> auto { return comp_ellint_1(inK); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: comp_ellint_1.hpp ***/


/*** Start of inlined file: comp_ellint_2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_2.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the complete elliptic integral of the second kind of k.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto comp_ellint_2(dtype inK)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::comp_ellint_2(inK);
#else
        return boost::math::ellint_2(inK);
#endif
    }

    // Method Description:
    /// Computes the complete elliptic integral of the second kind of k.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: elliptic modulus or eccentricity
    /// @return NdArray
    ///
    template<typename dtype>
    auto comp_ellint_2(const NdArray<dtype>& inArrayK)
    {
        NdArray<decltype(comp_ellint_2(dtype{ 0 }))> returnArray(inArrayK.shape());

        stl_algorithms::transform(inArrayK.cbegin(),
                                  inArrayK.cend(),
                                  returnArray.begin(),
                                  [](dtype inK) -> auto { return comp_ellint_2(inK); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: comp_ellint_2.hpp ***/


/*** Start of inlined file: comp_ellint_3.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_3.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the complete elliptic integral of the third kind of k and v.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @param inV: elliptic characteristic
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto comp_ellint_3(dtype1 inK, dtype2 inV)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::comp_ellint_3(inK, inV);
#else
        return boost::math::ellint_3(inK, inV);
#endif
    }

    // Method Description:
    /// Computes the complete elliptic integral of the third kind of k and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: the order of the bessel function
    /// @param inArrayV: elliptic characteristic
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto comp_ellint_3(const NdArray<dtype1>& inArrayK, const NdArray<dtype2>& inArrayV)
    {
        if (inArrayK.size() != inArrayV.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Shapes of inArrayk and inArrayV must match.");
        }

        NdArray<decltype(comp_ellint_3(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayK.shape());

        stl_algorithms::transform(inArrayK.cbegin(),
                                  inArrayK.cend(),
                                  inArrayV.cbegin(),
                                  returnArray.begin(),
                                  [](dtype1 inK, dtype2 inV) -> auto { return comp_ellint_3(inK, inV); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: comp_ellint_3.hpp ***/


/*** Start of inlined file: cyclic_hankel_1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <complex>
#include <type_traits>

#include "boost/math/special_functions/hankel.hpp"

namespace nc::special
{

    // Method Description:
    /// Hankel funcion of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return std::complex<double>
    ///
    template<typename dtype1, typename dtype2>
    auto cyclic_hankel_1(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_hankel_1(inV, inX);
    }

    // Method Description:
    /// Hankel funcion of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input array
    /// @return NdArray<std::complex>
    ///
    template<typename dtype1, typename dtype2>
    auto cyclic_hankel_1(dtype1 inV, const NdArray<dtype2>& inX)
    {
        NdArray<decltype(cyclic_hankel_1(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inX.shape());

        stl_algorithms::transform(inX.cbegin(),
                                  inX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 x) -> auto { return cyclic_hankel_1(inV, x); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: cyclic_hankel_1.hpp ***/


/*** Start of inlined file: cyclic_hankel_2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <complex>
#include <type_traits>

#include "boost/math/special_functions/hankel.hpp"

namespace nc::special
{

    // Method Description:
    /// Hankel funcion of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return std::complex<>
    ///
    template<typename dtype1, typename dtype2>
    auto cyclic_hankel_2(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::cyl_hankel_2(inV, inX);
    }

    // Method Description:
    /// Hankel funcion of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input array
    /// @return NdArray<std::complex>
    ///
    template<typename dtype1, typename dtype2>
    auto cyclic_hankel_2(dtype1 inV, const NdArray<dtype2>& inX)
    {
        NdArray<decltype(cyclic_hankel_2(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inX.shape());

        stl_algorithms::transform(inX.cbegin(),
                                  inX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 x) -> auto { return cyclic_hankel_2(inV, x); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: cyclic_hankel_2.hpp ***/


/*** Start of inlined file: digamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/digamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the digamma or psi function of inValue. Digamma is defined as the
    /// logarithmic derivative of the gamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto digamma(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::digamma(inValue);
    }

    // Method Description:
    /// Returns the digamma or psi function of values in inArray. Digamma is defined as the
    /// logarithmic derivative of the gamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto digamma(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(digamma(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return digamma(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: digamma.hpp ***/


/*** Start of inlined file: ellint_1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_1.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the incomplete elliptic integral of the first kind of k and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @param inP: Jacobi amplitude (measured in radians)
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto ellint_1(dtype1 inK, dtype2 inP)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::ellint_1(inK, inP);
#else
        return boost::math::ellint_1(inK, inP);
#endif
    }

    // Method Description:
    /// Computes the incomplete elliptic integral of the first kind of k and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: elliptic modulus or eccentricity
    /// @param inArrayP: Jacobi amplitude (measured in radians)
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto ellint_1(const NdArray<dtype1>& inArrayK, const NdArray<dtype2>& inArrayP)
    {
        if (inArrayK.size() != inArrayP.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Shapes of inArrayK and inArrayP must match.");
        }

        NdArray<decltype(ellint_1(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayK.shape());

        stl_algorithms::transform(inArrayK.cbegin(),
                                  inArrayK.cend(),
                                  inArrayP.cbegin(),
                                  returnArray.begin(),
                                  [](dtype1 inK, dtype2 inP) -> auto { return ellint_1(inK, inP); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: ellint_1.hpp ***/


/*** Start of inlined file: ellint_2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_2.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the incomplete elliptic integral of the second kind of k and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @param inP: Jacobi amplitude (measured in radians)
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto ellint_2(dtype1 inK, dtype2 inP)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

#ifdef __cpp_lib_math_special_functions
        return std::ellint_2(inK, inP);
#else
        return boost::math::ellint_2(inK, inP);
#endif
    }

    // Method Description:
    /// Computes the incomplete elliptic integral of the second kind of k and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: elliptic modulus or eccentricity
    /// @param inArrayP: Jacobi amplitude (measured in radians)
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto ellint_2(const NdArray<dtype1>& inArrayK, const NdArray<dtype2>& inArrayP)
    {
        if (inArrayK.size() != inArrayP.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Shapes of inArrayK and inArrayP must match.");
        }

        NdArray<decltype(ellint_2(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArrayK.shape());

        stl_algorithms::transform(inArrayK.cbegin(),
                                  inArrayK.cend(),
                                  inArrayP.cbegin(),
                                  returnArray.begin(),
                                  [](dtype1 inK, dtype2 inP) -> auto { return ellint_2(inK, inP); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: ellint_2.hpp ***/


/*** Start of inlined file: ellint_3.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/ellint_3.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Computes the incomplete elliptic integral of the second kind of k, v, and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inK: elliptic modulus or eccentricity
    /// @param inV: elliptic characteristic
    /// @param inP: Jacobi amplitude (measured in radians)
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2, typename dtype3>
    auto ellint_3(dtype1 inK, dtype2 inV, dtype3 inP)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);
        STATIC_ASSERT_ARITHMETIC(dtype3);

#ifdef __cpp_lib_math_special_functions
        return std::ellint_3(inK, inV, inP);
#else
        return boost::math::ellint_3(inK, inV, inP);
#endif
    }

    // Method Description:
    /// Computes the incomplete elliptic integral of the second kind of k, v, and p.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayK: the order of the bessel function
    /// @param inArrayV: elliptic characteristic
    /// @param inArrayP: Jacobi amplitude (measured in radians)
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2, typename dtype3>
    auto ellint_3(const NdArray<dtype1>& inArrayK, const NdArray<dtype2>& inArrayV, const NdArray<dtype3>& inArrayP)
    {
        if (inArrayK.size() != inArrayV.size() || inArrayK.size() != inArrayP.size())
        {
            THROW_INVALID_ARGUMENT_ERROR("Shapes of inArrayK, inArrayV, and inArrayP must match.");
        }

        NdArray<decltype(ellint_3(dtype1{ 0 }, dtype2{ 0 }, dtype3{ 0 }))> returnArray(inArrayK.shape());

        for (uint32 i = 0; i < inArrayK.size(); ++i)
        {
            returnArray[i] = ellint_3(inArrayK[i], inArrayV[i], inArrayP[i]);
        }

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: ellint_3.hpp ***/


/*** Start of inlined file: erf.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/erf.hpp"

namespace nc::special
{

    // Method Description:
    /// Calculate the error function of all elements in the input array.
    /// Integral (from [-x, x]) of np.exp(np.power(-t, 2)) dt, multiplied by 1/np.pi.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto erf(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::erf(inValue);
    }

    // Method Description:
    /// Calculate the error function of all elements in the input array.
    /// Integral (from [-x, x]) of np.exp(np.power(-t, 2)) dt, multiplied by 1/np.pi.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto erf(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(erf(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return erf(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: erf.hpp ***/


/*** Start of inlined file: erf_inv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/erf.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the inverse error function of z, that is a value x such that:
    /// z = erf(x).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto erf_inv(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::erf_inv(inValue);
    }

    // Method Description:
    /// Returns the inverse error function of z, that is a value x such that:
    /// z = erf(x).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto erf_inv(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(erf_inv(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return erf_inv(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: erf_inv.hpp ***/


/*** Start of inlined file: erfc.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/erf.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the complement of the error function of inValue.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto erfc(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::erfc(inValue);
    }

    // Method Description:
    /// Returns the element-wise complement of the error
    /// function of inValue.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto erfc(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(erfc(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return erfc(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: erfc.hpp ***/


/*** Start of inlined file: erfc_inv.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/erf.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the inverse complentary error function of z, that is a value x such that:
    /// z = erfc(x).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto erfc_inv(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::erfc_inv(inValue);
    }

    // Method Description:
    /// Returns the inverse complementary error function of z, that is a value x such that:
    /// z = erfc(x).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto erfc_inv(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(erfc_inv(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return erfc_inv(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: erfc_inv.hpp ***/


/*** Start of inlined file: expint.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/expint.hpp"
#endif

#include <type_traits>

namespace nc::special
{

    // Method Description:
    /// Exponential integral Ei.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inX: value
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto expint(dtype inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::expint(inX);
#else
        return boost::math::expint(inX);
#endif
    }

    // Method Description:
    /// Exponential integral Ei.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArrayX: value
    /// @return NdArray
    ///
    template<typename dtype>
    auto expint(const NdArray<dtype>& inArrayX)
    {
        NdArray<decltype(expint(dtype{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [](dtype inX) -> auto { return expint(inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: expint.hpp ***/


/*** Start of inlined file: gamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/gamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the "true gamma" of value z.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto gamma(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::tgamma(inValue);
    }

    // Method Description:
    /// Returns the "true gamma" of values in array.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto gamma(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(gamma(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return gamma(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: gamma.hpp ***/


/*** Start of inlined file: gamma1pm1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/gamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the true gamma(dz + 1) - 1 of value z.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto gamma1pm1(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::tgamma1pm1(inValue);
    }

    // Method Description:
    /// Returns the true gamma(dz + 1) - 1 of values in array.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto gamma1pm1(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(gamma1pm1(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return gamma1pm1(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: gamma1pm1.hpp ***/


/*** Start of inlined file: log_gamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/gamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns natural log of the true gamma of value z.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto log_gamma(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::lgamma(inValue);
    }

    // Method Description:
    /// Returns natural log of the true gamma of values in array.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto log_gamma(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(log_gamma(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return log_gamma(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: log_gamma.hpp ***/


/*** Start of inlined file: polygamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/polygamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the polygamma function of inValue. Polygamma is defined as the
    /// n'th derivative of the digamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the nth derivative
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto polygamma(uint32 n, dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::polygamma(n, inValue);
    }

    // Method Description:
    /// Returns the polygamma function of the values in inArray. Polygamma is defined as the
    /// n'th derivative of the digamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the nth derivative
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto polygamma(uint32 n, const NdArray<dtype>& inArray)
    {
        NdArray<decltype(polygamma(n, dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [n](dtype inValue) -> auto { return polygamma(n, inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: polygamma.hpp ***/


/*** Start of inlined file: prime.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <string>

#include "boost/math/special_functions/prime.hpp"

namespace nc::special
{

    // Method Description:
    /// The function prime provides fast table lookup to the first 10000 prime numbers
    /// (starting from 2 as the zeroth prime: as 1 isn't terribly useful in practice).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param n: the nth prime number to return
    /// @return uint32
    ///
    inline uint32 prime(uint32 n)
    {
        if (n > boost::math::max_prime)
        {
            THROW_INVALID_ARGUMENT_ERROR("input n must be less than or equal to " +
                                         std::to_string(boost::math::max_prime));
        }

        return boost::math::prime(n);
    }

    // Method Description:
    /// The function prime provides fast table lookup to the first 10000 prime numbers
    /// (starting from 2 as the zeroth prime: as 1 isn't terribly useful in practice).
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray<uint32>
    ///
    inline NdArray<uint32> prime(const NdArray<uint32>& inArray)
    {
        NdArray<uint32> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](uint32 inValue) -> uint32 { return prime(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: prime.hpp ***/


/*** Start of inlined file: riemann_zeta.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/zeta.hpp"
#endif

namespace nc::special
{

    // Method Description:
    /// The Riemann Zeta function
    /// https://en.wikipedia.org/wiki/Riemann_zeta_function
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto riemann_zeta(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::riemann_zeta(inValue);
#else
        return boost::math::zeta(inValue);
#endif
    }

    // Method Description:
    /// The Riemann Zeta function
    /// https://en.wikipedia.org/wiki/Riemann_zeta_function
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto riemann_zeta(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(riemann_zeta(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return riemann_zeta(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: riemann_zeta.hpp ***/


/*** Start of inlined file: softmax.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

namespace nc::special
{

    // Method Description:
    /// The softmax function transforms each element of a collection by computing
    /// the exponential of each element divided by the sum of the exponentials of all
    /// the elements. That is, if x is a one-dimensional numpy array:
    /// softmax(x) = np.exp(x)/sum(np.exp(x))
    ///
    /// @param inArray
    /// @param inAxis (Optional, default NONE)
    /// @return NdArray<double>
    ///
    template<typename dtype>
    NdArray<double> softmax(const NdArray<dtype>& inArray, Axis inAxis = Axis::NONE)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        switch (inAxis)
        {
            case Axis::NONE:
            {
                auto returnArray = exp(inArray).template astype<double>();
                returnArray /= static_cast<double>(returnArray.sum().item());
                return returnArray;
            }
            case Axis::COL:
            {
                auto returnArray = exp(inArray).template astype<double>();
                auto expSums     = returnArray.sum(inAxis);

                for (uint32 row = 0; row < returnArray.shape().rows; ++row)
                {
                    const auto rowExpSum = static_cast<double>(expSums[row]);
                    stl_algorithms::for_each(returnArray.begin(row),
                                             returnArray.end(row),
                                             [rowExpSum](double& value) { value /= rowExpSum; });
                }

                return returnArray;
            }
            case Axis::ROW:
            {
                auto returnArray = exp(inArray.transpose()).template astype<double>();
                auto expSums     = returnArray.sum(Axis::COL);

                for (uint32 row = 0; row < returnArray.shape().rows; ++row)
                {
                    const auto rowExpSum = static_cast<double>(expSums[row]);
                    stl_algorithms::for_each(returnArray.begin(row),
                                             returnArray.end(row),
                                             [rowExpSum](double& value) { value /= rowExpSum; });
                }

                return returnArray.transpose();
            }
            default:
            {
                THROW_INVALID_ARGUMENT_ERROR("Unimplemented axis type.");
                return {}; // get rid of compiler warning
            }
        }
    }
} // namespace nc::special

/*** End of inlined file: softmax.hpp ***/


/*** Start of inlined file: spherical_bessel_jn.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

namespace nc::special
{

    // Method Description:
    /// Spherical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto spherical_bessel_jn(uint32 inV, dtype inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::sph_bessel(inV, inX);
#else
        return boost::math::sph_bessel(inV, inX);
#endif
    }

    // Method Description:
    /// Spherical Bessel function of the first kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype>
    auto spherical_bessel_jn(uint32 inV, const NdArray<dtype>& inArrayX)
    {
        NdArray<decltype(spherical_bessel_jn(inV, dtype{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype inX) -> auto { return spherical_bessel_jn(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: spherical_bessel_jn.hpp ***/


/*** Start of inlined file: spherical_bessel_yn.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#include <cmath>

#if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

#ifndef __cpp_lib_math_special_functions
#include "boost/math/special_functions/bessel.hpp"
#endif

namespace nc::special
{

    // Method Description:
    /// Spherical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto spherical_bessel_yn(uint32 inV, dtype inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

#ifdef __cpp_lib_math_special_functions
        return std::sph_neumann(inV, inX);
#else
        return boost::math::sph_neumann(inV, inX);
#endif
    }

    // Method Description:
    /// Spherical Bessel function of the second kind.
    /// NOTE: Use of this function requires either using the Boost
    /// includes or a C++17 compliant compiler.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArrayX: the input values
    /// @return NdArray
    ///
    template<typename dtype>
    auto spherical_bessel_yn(uint32 inV, const NdArray<dtype>& inArrayX)
    {
        NdArray<decltype(spherical_bessel_yn(inV, dtype{ 0 }))> returnArray(inArrayX.shape());

        stl_algorithms::transform(inArrayX.cbegin(),
                                  inArrayX.cend(),
                                  returnArray.begin(),
                                  [inV](dtype inX) -> auto { return spherical_bessel_yn(inV, inX); });

        return returnArray;
    }
} // namespace nc::special

#endif // #if defined(__cpp_lib_math_special_functions) || !defined(NUMCPP_NO_USE_BOOST)

/*** End of inlined file: spherical_bessel_yn.hpp ***/


/*** Start of inlined file: spherical_hankel_1.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <complex>
#include <type_traits>

#include "boost/math/special_functions/hankel.hpp"

namespace nc::special
{

    // Method Description:
    /// Spherical Hankel funcion of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return calculated-result-type
    ///
    template<typename dtype1, typename dtype2>
    auto spherical_hankel_1(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::sph_hankel_1(inV, inX);
    }

    // Method Description:
    /// Spherical Hankel funcion of the first kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArray: the input values
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto spherical_hankel_1(dtype1 inV, const NdArray<dtype2>& inArray)
    {
        NdArray<decltype(spherical_hankel_1(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inValue) -> auto { return spherical_hankel_1(inV, inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: spherical_hankel_1.hpp ***/


/*** Start of inlined file: spherical_hankel_2.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include <complex>
#include <type_traits>

#include "boost/math/special_functions/hankel.hpp"

namespace nc::special
{

    // Method Description:
    /// Spherical Hankel funcion of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inX: the input value
    /// @return double
    ///
    template<typename dtype1, typename dtype2>
    std::complex<double> spherical_hankel_2(dtype1 inV, dtype2 inX)
    {
        STATIC_ASSERT_ARITHMETIC(dtype1);
        STATIC_ASSERT_ARITHMETIC(dtype2);

        return boost::math::sph_hankel_2(inV, inX);
    }

    // Method Description:
    /// Spherical Hankel funcion of the second kind.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inV: the order of the bessel function
    /// @param inArray: the input value
    /// @return NdArray
    ///
    template<typename dtype1, typename dtype2>
    auto spherical_hankel_2(dtype1 inV, const NdArray<dtype2>& inArray)
    {
        NdArray<decltype(spherical_hankel_2(dtype1{ 0 }, dtype2{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [inV](dtype2 inValue) -> auto { return spherical_hankel_2(inV, inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: spherical_hankel_2.hpp ***/


/*** Start of inlined file: trigamma.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Special Functions
///
#pragma once

#ifndef NUMCPP_NO_USE_BOOST

#include "boost/math/special_functions/trigamma.hpp"

namespace nc::special
{

    // Method Description:
    /// Returns the trigamma function of x. Trigamma is defined as the derivative
    /// of the digamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inValue
    /// @return calculated-result-type
    ///
    template<typename dtype>
    auto trigamma(dtype inValue)
    {
        STATIC_ASSERT_ARITHMETIC(dtype);

        return boost::math::trigamma(inValue);
    }

    // Method Description:
    /// Returns the trigamma function of x. Trigamma is defined as the derivative
    /// of the digamma function.
    /// NOTE: Use of this function requires using the Boost includes.
    ///
    /// @param inArray
    /// @return NdArray
    ///
    template<typename dtype>
    auto trigamma(const NdArray<dtype>& inArray)
    {
        NdArray<decltype(trigamma(dtype{ 0 }))> returnArray(inArray.shape());

        stl_algorithms::transform(inArray.cbegin(),
                                  inArray.cend(),
                                  returnArray.begin(),
                                  [](dtype inValue) -> auto { return trigamma(inValue); });

        return returnArray;
    }
} // namespace nc::special

#endif // #ifndef NUMCPP_NO_USE_BOOST

/*** End of inlined file: trigamma.hpp ***/

/*** End of inlined file: Special.hpp ***/


/*** Start of inlined file: Utils.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Usefull utility type functions
///
#pragma once


/*** Start of inlined file: timeit.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Function profiling/timing
///
#pragma once

#include <chrono>
#include <iostream>
#include <type_traits>

namespace nc::utils
{
    namespace timeit_detail
    {
        /// @brief  Result statistics of a timeit run
        template<typename TimeUnit>
        struct Result
        {
            TimeUnit min{};
            TimeUnit max{};
            TimeUnit mean{};
        };

        template<typename TimeUnit>
        std::ostream& operator<<(std::ostream& os, const Result<TimeUnit> result)
        {
            std::string unit{};
            if constexpr (std::is_same<TimeUnit, std::chrono::hours>::value)
            {
                unit = " hours";
            }
            else if constexpr (std::is_same<TimeUnit, std::chrono::minutes>::value)
            {
                unit = " minutes";
            }
            else if constexpr (std::is_same<TimeUnit, std::chrono::seconds>::value)
            {
                unit = " seconds";
            }
            else if constexpr (std::is_same<TimeUnit, std::chrono::milliseconds>::value)
            {
                unit = " milliseconds";
            }
            else if constexpr (std::is_same<TimeUnit, std::chrono::microseconds>::value)
            {
                unit = " microseconds";
            }
            else if constexpr (std::is_same<TimeUnit, std::chrono::nanoseconds>::value)
            {
                unit = " nanoseconds";
            }
            else
            {
                unit = " time units of some sort";
            }

            os << "Timeit results:\n";
            os << "\tmin: " << result.min.count() << unit << "\n";
            os << "\tmax: " << result.max.count() << unit << "\n";
            os << "\tmean: " << result.mean.count() << unit << "\n";

            return os;
        }
    } // namespace timeit_detail

    /// Timing of a function
    ///
    /// @param numIterations: number of iterations for the timing statistics
    /// @param printResults: true to print the results
    /// @param function: the function to time
    /// @param args: the arguements that are forwarded to the function input
    ///
    /// @return timing statistics
    ///
    template<typename TimeUnit, typename Function, typename... Args>
    timeit_detail::Result<TimeUnit>
        timeit(uint32 numIterations, PrintResults printResults, Function function, Args&&... args) noexcept
    {
        auto result = timeit_detail::Result<TimeUnit>{};
        auto timer  = Timer<TimeUnit>{};

        for (uint32 i = 0; i < numIterations; ++i)
        {
            if (i == 0)
            {
                result.min = TimeUnit::max();
            }

            timer.tic();

            using ResultType = std::invoke_result_t<Function, Args...>;
            if constexpr (std::is_same_v<ResultType, void>)
            {
                function(std::forward<Args>(args)...);
            }
            else
            {
                // cppcheck-suppress redundantAssignment
                [[maybe_unused]] const ResultType functionResult = function(std::forward<Args&>(args)...);
            }

            const auto elapsedTime = timer.toc(PrintElapsedTime::NO);

            result.mean = result.mean + elapsedTime;
            result.min  = std::min(result.min, elapsedTime);
            result.max  = std::max(result.max, elapsedTime);
        }

        result.mean = result.mean / numIterations;

        if (printResults == PrintResults::YES)
        {
            std::cout << result;
        }

        return result;
    }
} // namespace nc::utils

/*** End of inlined file: timeit.hpp ***/

/*** End of inlined file: Utils.hpp ***/


/*** Start of inlined file: Vector.hpp ***/
/// @file
/// @author David Pilger <dpilger26@gmail.com>
/// [GitHub Repository](https://github.com/dpilger26/NumCpp)
///
/// License
/// Copyright 2018-2023 David Pilger
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this
/// software and associated documentation files(the "Software"), to deal in the Software
/// without restriction, including without limitation the rights to use, copy, modify,
/// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to the following
/// conditions :
///
/// The above copyright notice and this permission notice shall be included in all copies
/// or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
/// PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
/// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
/// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///
/// Description
/// Simple Vector classes
///
#pragma once

/*** End of inlined file: Vector.hpp ***/

/// \example GaussNewtonNlls.cpp
/// Example for using the linalg::gaussNewtonNlls function
///
/// \example InterfaceWithEigen.cpp
/// Example for interfaceing with Eigen Matrix
///
/// \example InterfaceWithOpenCV.cpp
/// Example for interfaceing with OpenCV Mat
///
/// \example ReadMe.cpp
/// Examples from the Quick Start Guide in README.md at [GitHub Repository](https://github.com/dpilger26/NumCpp)
///

